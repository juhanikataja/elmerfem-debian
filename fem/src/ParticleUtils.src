 
MODULE ParticleUtils
  
  USE DefUtils
  USE Lists
  USE MeshUtils
  
  IMPLICIT NONE
  
  INTEGER, PARAMETER :: &
      PARTICLE_ALLOCATED = 1, &
      PARTICLE_WAITING = 2, &
      PARTICLE_INITIATED = 3, &
      PARTICLE_LOCATED = 4, &
      PARTICLE_FACEBOUNDARY = 5, &
      PARTICLE_WALLBOUNDARY = 6, &
      PARTICLE_PARTBOUNDARY = 7, &
      PARTICLE_HIT = 8, & 
      PARTICLE_READY = 9, &
      PARTICLE_FIXEDCOORD = 10, &
      PARTICLE_FIXEDVELO = 11, &
      PARTICLE_LOST = 12, &
      PARTICLE_GHOST = 13

CONTAINS



  !---------------------------------------------------------
  ! The following subroutines make the data structure 
  ! transparent in the user subrouines and thereby make
  ! them more recilient to time.
  !---------------------------------------------------------
  FUNCTION GetParticleCoord(Particles,No,DerOrder) RESULT ( Coord )
    TYPE(Particle_t) :: Particles
    INTEGER :: No, DerOrder
    REAL(KIND=dp) :: Coord(3) 
    
    INTEGER :: dim
    
    Coord(3) = 0.0_dp
    dim = Particles % dim
    
    IF( DerOrder == 0 ) THEN
      Coord(1:dim) = Particles % Coordinate(no,:)
    ELSE IF( DerOrder == 1 ) THEN
      Coord(1:dim) = Particles % Velocity(no,:)
    ELSE IF( DerOrder == 2 ) THEN
      Coord(1:dim) = Particles % Force(no,:)
    END IF
  END FUNCTION GetParticleCoord
  

  SUBROUTINE SetParticleCoord(Particles,No,DerOrder,Coord)
    TYPE(Particle_t) :: Particles
    INTEGER :: No, DerOrder
    REAL(KIND=dp) :: Coord(3) 
    
    INTEGER :: dim
    
    dim = Particles % dim
    
    IF( DerOrder == 0 ) THEN
      Particles % Coordinate(no,:) = Coord(1:dim)
    ELSE IF( DerOrder == 1 ) THEN
      Particles % Velocity(no,:) = Coord(1:dim)
    ELSE IF( DerOrder == 2 ) THEN
      Particles % Force(no,:) = Coord(1:dim)
    END IF
  END SUBROUTINE SetParticleCoord
  
  
  SUBROUTINE AddParticleCoord(Particles,No,DerOrder,Coord)
    TYPE(Particle_t) :: Particles
    INTEGER :: No, DerOrder
    REAL(KIND=dp) :: Coord(3) 
    
    INTEGER :: dim
    
    dim = Particles % dim
    
    IF( DerOrder == 0 ) THEN
      Particles % Coordinate(no,:) = &
          Particles % Coordinate(no,:) + Coord(1:dim)
    ELSE IF( DerOrder == 1 ) THEN
      Particles % Velocity(no,:) = &
          Particles % Velocity(no,:) + Coord(1:dim)
    ELSE IF( DerOrder == 2 ) THEN
      Particles % Force(no,:) = &
          Particles % Force(no,:) + Coord(1:dim)
    END IF
  END SUBROUTINE AddParticleCoord
  
  
  
  FUNCTION GetParticleStatus(Particles,No) RESULT ( Status )
    TYPE(Particle_t) :: Particles
    INTEGER :: No, DerOrder
    INTEGER :: Status
    
    Status = Particles % Status(No)
  END FUNCTION GetParticleStatus
  
  
  SUBROUTINE SetParticleStatus(Particles,No,Status )
    TYPE(Particle_t) :: Particles
    INTEGER :: No, DerOrder
    INTEGER :: Status
    
    Particles % Status(No) = Status
  END SUBROUTINE SetParticleStatus
  
  
  FUNCTION GetParticleElement(Particles,No) RESULT ( Index ) 
    TYPE(Particle_t) :: Particles
    INTEGER :: No, DerOrder
    INTEGER :: Index
    
    Index = Particles % ElementIndex(No)
  END FUNCTION GetParticleElement
  
  
  SUBROUTINE SetParticleElement(Particles,No,Index )
    TYPE(Particle_t) :: Particles
    INTEGER :: No, DerOrder
    INTEGER :: Index
    
    Particles % ElementIndex(No) = Index
  END SUBROUTINE SetParticleElement
  


  !---------------------------------------------------------
  ! The subroutine marks the elements which are not on the 
  ! boundary, either internal or external one. 
  ! This information may be used to speed up different 
  ! loops where particle-boundary interaction is needed.
  !---------------------------------------------------------
  SUBROUTINE MarkInternalElements( Particles )
    
    TYPE(Particle_t) :: Particles
    TYPE(Element_t), POINTER :: BulkElement, BulkElement2, BoundaryElement
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(ValueList_t), POINTER :: Body, Body2
    INTEGER :: t,i,j,imax,body_id,body_id2,mat_id,mat_id2,bf_id,bf_id2,dim,istat
    INTEGER :: NumberOfElements
    LOGICAL, POINTER :: InternalElements(:)
    LOGICAL :: Found,Hit
    
    Mesh => GetMesh()
    Dim = Mesh % MeshDim
    NumberOfElements = Mesh % NumberOfBulkElements
    
    IF(.NOT. ASSOCIATED( Particles % InternalElements )) THEN
      ALLOCATE( Particles % InternalElements(NumberOfElements),STAT=istat )
      IF( istat /= 0 ) THEN
        CALL Fatal('MarkInternalElements','Allocation error 1')
      END IF
    END IF
    
    InternalElements => Particles % InternalElements
    InternalElements = .TRUE.
    
    DO t=1,NumberOfElements
      
      BulkElement => Mesh % Elements(t)
      
      body_id = BulkElement % BodyId
      
      IF(.FALSE.) THEN
        Body => CurrentModel % Bodies(body_id) % Values
        mat_id = ListGetInteger( Body,'Material',Found)
        bf_id = ListGetInteger( Body,'Body Force',Found)
      END IF
      
      IF( dim == 3 ) THEN
        imax = BulkElement % TYPE % NumberOfFaces 
      ELSE
        imax = BulkElement % TYPE % NumberOfEdges  
      END IF
      
      Hit = .FALSE.
      
      DO i=1, imax
        IF( dim == 3 ) THEN
          j = BulkElement % FaceIndexes(i)
          BoundaryElement => Mesh % Faces( j )
        ELSE
          j = BulkElement % EdgeIndexes(i)
          BoundaryElement => Mesh % Edges(j)
        END IF
        
        IF( .NOT. ASSOCIATED( BoundaryElement % BoundaryInfo ) ) CYCLE
        
        IF( ASSOCIATED( BulkElement, BoundaryElement % BoundaryInfo % Right ) ) THEN
          BulkElement2 => BoundaryElement % BoundaryInfo % Left
        ELSE
          BulkElement2 => BoundaryElement % BoundaryInfo % Right
        END IF
        
        ! A true boundary element
        IF( .NOT. ASSOCIATED( BulkElement2 )) THEN
          Hit = .TRUE.
          EXIT
        END IF
        
        body_id2 = BulkElement2 % BodyId
        IF( body_id2 == body_id ) CYCLE
        
        ! If the bodies are the same then there is no boundary
        IF(.TRUE.) THEN
          IF( body_id2 /= body_id ) THEN
            Hit = .TRUE.
            EXIT
          END IF
        ELSE        
          Body2 => CurrentModel % Bodies(body_id2) % Values
          
          mat_id2 = ListGetInteger( Body2,'Material')
          IF( mat_id2 /= mat_id ) THEN
            Hit = .TRUE.
            EXIT
          END IF
          
          bf_id2 = ListGetInteger( Body2,'Body Force',Found)
          IF( bf_id2 /= bf_id ) THEN
            Hit = .TRUE.
            EXIT
          END IF
        END IF
      END DO
      
      IF( Hit ) InternalElements(t) = .FALSE.
    END DO
    
    i = COUNT( InternalElements )
    j = NumberOfElements - i
    
    PRINT *,'Internal Elements',i
    PRINT *,'Interface Elements',j
    
    
  END SUBROUTINE MarkInternalElements
  



  !---------------------------------------------------------
  ! Set up some preliminary information needed for the 
  ! particler tracker: timeorder, space dimension, 
  ! bounding box, and mesh edges/faces.
  !---------------------------------------------------------
  SUBROUTINE SetParticlePreliminaries(Particles,dim,TimeOrder)
    
    TYPE(Particle_t) :: Particles
    INTEGER, OPTIONAL :: dim
    INTEGER, OPTIONAL :: TimeOrder
    
    TYPE(Mesh_t), POINTER :: Mesh
    REAL(KIND=dp) :: MinCoord(3), MaxCoord(3), s(3)
    INTEGER :: ierr
    
    Mesh => GetMesh()
    IF( .NOT. ASSOCIATED( Mesh ) ) THEN
      CALL Fatal('SetParticleDimensions','No Mesh associated')
    END IF
    
    IF(PRESENT(TimeOrder)) THEN
      Particles % TimeOrder = TimeOrder
    ELSE
      Particles % TimeOrder = 2
    END IF
    
    IF( PRESENT( dim ) ) THEN
      IF( dim == 2 .OR. dim == 3 ) THEN
        Particles % dim = dim
      ELSE
        CALL Fatal('SetParticleDimensions','Invalid dimension')
      END IF
    ELSE
      Particles % dim = Mesh % Meshdim
    END IF
    
    MinCoord(1) = MINVAL(Mesh % Nodes % x )
    MinCoord(2) = MINVAL(Mesh % Nodes % y )
    MinCoord(3) = MINVAL(Mesh % Nodes % z )
    
    MaxCoord(1) = MAXVAL(Mesh % Nodes % x )
    MaxCoord(2) = MAXVAL(Mesh % Nodes % y )
    MaxCoord(3) = MAXVAL(Mesh % Nodes % z )
    
    Particles % LocalMinCoord = MinCoord
    Particles % LocalMaxCoord = MaxCoord
    
    
    ! Make a parallel reduction
    IF( ParEnv % PEs > 1 ) THEN
      s = MinCoord
      CALL MPI_ALLREDUCE( s, mincoord, 3, MPI_DOUBLE_PRECISION, &
          MPI_MIN, MPI_COMM_WORLD, ierr )
      
      s = MaxCoord
      CALL MPI_ALLREDUCE( s, maxcoord, 3, MPI_DOUBLE_PRECISION, &
          MPI_MAX, MPI_COMM_WORLD, ierr )
    END IF
    
    Particles % GlobalMinCoord = MinCoord
    Particles % GlobalMaxCoord = MaxCoord
    
    
    ! Create list of faces / edges 
    !-------------------------------------------------------------------------
    Mesh => GetMesh()
    CALL FindMeshEdges( Mesh, .FALSE.)
    IF ( ParEnv % PEs > 1 ) THEN
      CALL SParEdgeNumbering(Mesh,Allmesh=.TRUE.)
      CALL SParFaceNumbering(Mesh,Allmesh=.TRUE.)
    END IF
    
    ! Mark elements that are not on boundary to make life faster in the future
    !-------------------------------------------------------------------------
    CALL MarkInternalElements( Particles )
    
  END SUBROUTINE SetParticlePreliminaries



  !---------------------------------------------------------
  ! Allocate particles before launching them
  !---------------------------------------------------------
  SUBROUTINE AllocateParticles(Particles,NoParticles)
    
    TYPE(Particle_t) :: Particles
    INTEGER :: NoParticles
    
    REAL(KIND=dp), POINTER :: Velocity(:,:), Force(:,:), &
        Coordinate(:,:), Distance(:),Dt(:)
    INTEGER, POINTER :: Status(:), ElementIndex(:), FaceIndex(:), Closest(:)
    INTEGER :: PrevNoParticles, dofs, No, n, dim, TimeOrder
    
    IF( NoParticles <= Particles % MaxNumberOfParticles ) THEN
      CALL Info('AllocateParticles','There are already enough particles')
      RETURN
    ELSE
      WRITE(Message,*) 'Allocating number of particles:',NoParticles
      CALL Info('AllocateParticles',Message)    
    END IF
    
    TimeOrder = Particles % TimeOrder
    dim = Particles % dim 
    dofs = dim
    
    IF( Particles % MaxNumberOfParticles == 0 ) THEN
      ALLOCATE( Particles % Coordinate(NoParticles,dofs))
      ALLOCATE( Particles % Distance(NoParticles))
      ALLOCATE( Particles % Dt(NoParticles))
      ALLOCATE( Particles % Status(NoParticles))
      ALLOCATE( Particles % ElementIndex(NoParticles))
      
      Particles % Coordinate = 0.0_dp
      Particles % Distance = 0.0_dp
      Particles % Dt = 0.0_dp
      Particles % Status = PARTICLE_ALLOCATED
      Particles % ElementIndex = 0
      Particles % MaxNumberOfParticles = NoParticles
      
      ALLOCATE( Particles % Velocity(NoParticles,dofs))
      Particles % Velocity = 0.0_dp
      
      ALLOCATE( Particles % Force(NoParticles,dofs) )
      Particles % Force = 0.0_dp
      
      ALLOCATE( Particles % FaceIndex(NoParticles))
      Particles % FaceIndex = 0
    ELSE 
      PrevNoParticles = Particles % NumberOfParticles 
      
      Coordinate => Particles % Coordinate
      Velocity => Particles % Velocity
      Force => Particles % Force
      Distance => Particles % Distance
      Status => Particles % Status
      Dt => Particles % Dt
      Closest => Particles % ClosestNode
      FaceIndex => Particles % FaceIndex
      ElementIndex => Particles % ElementIndex
      
      ALLOCATE( Particles % Coordinate(NoParticles,dofs) )
      IF ( ASSOCIATED(Velocity) ) &
          ALLOCATE( Particles % Velocity(NoParticles,dofs) )
      
      IF ( ASSOCIATED(Force) ) &
          ALLOCATE( Particles % Force(NoParticles,dofs) )
      
      IF ( ASSOCIATED(Closest) ) &
          ALLOCATE( Particles % ClosestNode(NoParticles) )
      
      ALLOCATE( Particles % Distance(NoParticles) )
      ALLOCATE( Particles % Status(NoParticles) )
      ALLOCATE( Particles % Dt(NoParticles) )
      ALLOCATE( Particles % FaceIndex(NoParticles))
      ALLOCATE( Particles % ElementIndex(NoParticles) )
      
      ! Delete lost particles...
      ! ------------------------
      n = 0
      DO No=1,PrevNoParticles
        IF ( Status(No) == PARTICLE_LOST ) CYCLE
        n=n+1
        Particles % Coordinate(n,:) = Coordinate(No,:)
        IF ( ASSOCIATED(Velocity) ) Particles % Velocity(n,:)=Velocity(No,:)
        IF ( ASSOCIATED(Force) ) Particles % Force(n,:)=Force(No,:)
        IF ( ASSOCIATED(Closest) ) Particles % ClosestNode(n)=Closest(No)
        Particles % Distance(n) = Distance(No)
        Particles % Status(n) = Status(No)
        Particles % Dt(n) = Dt(No)
        Particles % FaceIndex(n) = FaceIndex(No)
        Particles % ElementIndex(n) = ElementIndex(No)
      END DO
      PrevNoParticles = n
      Particles % NumberOfParticles = n
      
      IF ( ASSOCIATED(Force) ) DEALLOCATE(Force)
      IF ( ASSOCIATED(Velocity) ) DEALLOCATE(Velocity)
      IF ( ASSOCIATED(Closest) ) DEALLOCATE(Closest)
      DEALLOCATE(Coordinate, Distance, Status, ElementIndex, Dt, FaceIndex )
      
      IF ( ASSOCIATED(Particles % Velocity) ) & 
          Particles % Velocity(PrevNoParticles+1:NoParticles,:) = 0.0_dp
      
      IF ( ASSOCIATED(Particles % Force) ) &
          Particles % Force(PrevNoParticles+1:NoParticles,:) = 0.0_dp
      
      IF ( ASSOCIATED(Particles % ClosestNode) ) &
          Particles % ClosestNode(PrevNoParticles+1:NoParticles) = 0
      
      Particles % Coordinate(PrevNoParticles+1:NoParticles,:) = 0.0_dp
      Particles % Dt(PrevNoParticles+1:NoParticles) = 0.0_dp
      Particles % Distance(PrevNoParticles+1:NoParticles) = 0.0_dp
      Particles % ElementIndex(PrevNoParticles+1:NoParticles) = 0
      Particles % Status(PrevNoParticles+1:NoParticles) = PARTICLE_ALLOCATED
      
      Particles % MaxNumberOfParticles = NoParticles
    END IF
  END SUBROUTINE AllocateParticles
  

  !----------------------------------------------------
  ! Delete lost particles:
  !----------------------------------------------------
  SUBROUTINE DeleteLostParticles(Particles)
    TYPE(Particle_t) :: Particles
    
    INTEGER :: No, n, PrevNoParticles
    
    PrevNoParticles = Particles % NumberOfParticles
    
    n = 0
    DO No=1,PrevNoParticles
      IF ( Particles % Status(No) == PARTICLE_LOST ) CYCLE
      
      n=n+1
      IF ( n==No ) CYCLE
      
      Particles % Coordinate(n,:) = Particles % Coordinate(No,:)
      IF ( ASSOCIATED(Particles % Velocity) ) &
          Particles % Velocity(n,:)=Particles % Velocity(No,:)
      IF ( ASSOCIATED(Particles % Force) ) &
          Particles % Force(n,:)=Particles % Force(No,:)
      IF ( ASSOCIATED(Particles % ClosestNode) ) &
          Particles % ClosestNode(n)=Particles % ClosestNode(No)
      Particles % Distance(n) = Particles % Distance(No)
      Particles % Status(n) = Particles % Status(No)
      Particles % Dt(n) = Particles % Dt(No)
      Particles % FaceIndex(n) = Particles % FaceIndex(No)
      Particles % ElementIndex(n) = Particles % ElementIndex(No)
    END DO
    Particles % NumberOfParticles = n
    
    IF ( n<PrevNoParticles ) THEN
      IF ( ASSOCIATED(Particles % Velocity) ) & 
          Particles % Velocity(n+1:PrevNoParticles,:) = 0.0_dp
      
      IF ( ASSOCIATED(Particles % Force) ) &
          Particles % Force(n+1:PrevNoParticles,:) = 0._dp
      
      IF ( ASSOCIATED(Particles % ClosestNode) ) &
          Particles % ClosestNode(n+1:PrevNoParticles) = 0
      
      Particles % Coordinate(n+1:PrevNoParticles,:) = 0._dp
      Particles % Dt(n+1:PrevNoParticles) = 0._dp
      Particles % Distance(n+1:PrevNoParticles) = 0._dp
      Particles % ElementIndex(n+1:PrevNoParticles) = 0
      Particles % Status(n+1:PrevNoParticles) = PARTICLE_ALLOCATED
    END IF
  END SUBROUTINE DeleteLostParticles
  


  !----------------------------------------------------
  ! Set particles that are still sitting on boundary to 
  ! leave the premises and call for their delition.
  !----------------------------------------------------
  SUBROUTINE EliminateExitingParticles( Particles )
    
    TYPE(Particle_t) :: Particles
    INTEGER :: NoParticles, No, DeletedParticles, dim, CumDeleted = 0, LimDeleted
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Element_t), POINTER :: BoundaryElement
    REAL(KIND=dp) :: Dist, Coord(3), Normal(3), SqrtElementMetric
    REAL(KIND=dp), POINTER :: Basis(:)
    TYPE(Nodes_t) :: BoundaryNodes
    INTEGER :: n
    LOGICAL :: Stat, Visited = .FALSE.
    
    SAVE Visited, CumDeleted, BoundaryNodes, Basis
    
    NoParticles = Particles % NumberOfParticles
    dim = Particles % dim
    Mesh => GetMesh()
    
    IF(.NOT. Visited ) THEN
      Visited = .TRUE.
      n = Mesh % MaxElementNodes
      ALLOCATE( Basis(n) )
    END IF

    ! Just set the wall particles to lost elements for now    
    IF(.TRUE.) THEN
      DO No=1, NoParticles
        IF( Particles % Status(No) == PARTICLE_WALLBOUNDARY ) THEN
          Particles % Status(No) = PARTICLE_LOST          
        END IF
      END DO
    ELSE
    
      ! Some heuristics is used when to activate the deleting of particles
      ! Check for co-operation with parallel stuff.
      !-------------------------------------------------------------------
      LimDeleted = MAX( NINT( SQRT( 1.0_dp * NoParticles ) ), 20 )
      !  LimDeleted = 0
      
      DeletedParticles = 0
      DO No=1, NoParticles
        IF( Particles % Status(No) == PARTICLE_WALLBOUNDARY ) THEN
          DeletedParticles = DeletedParticles + 1
          Particles % Status(No) = PARTICLE_LOST
        END IF
      END DO
      
      CumDeleted = CumDeleted + DeletedParticles
      
      IF( CumDeleted > LimDeleted ) THEN
        PRINT *,'Number of deleted particles:',CumDeleted, DeletedParticles, LimDeleted
        CALL DeleteLostParticles( Particles ) 
        CumDeleted = 0
      END IF
    END IF

  END SUBROUTINE EliminateExitingParticles
  

  !----------------------------------------------------
  ! Increase particle array size by given amount:
  !----------------------------------------------------
  SUBROUTINE IncreaseParticles(Particles,NoParticles)
    
    TYPE(Particle_t) :: Particles
    INTEGER :: NoParticles
    
    INTEGER :: Maxn
    
    ! Garbage collection:
    ! -------------------
    CALL DeleteLostParticles(Particles)
    
    ! Check if really need to allocate more space:
    ! --------------------------------------------
    Maxn = Particles % NumberOfParticles+NoParticles
    IF ( Maxn > Particles % MaxNumberOfParticles ) &
        CALL AllocateParticles( Particles,Maxn )
    
  END SUBROUTINE IncreaseParticles
  
  

  SUBROUTINE DestroyParticles(Particles) 
    TYPE(Particle_t) :: Particles
    
    IF ( ASSOCIATED(Particles % Velocity) ) &
        DEALLOCATE( Particles % Velocity ) 
    
    IF ( ASSOCIATED(Particles % Force) ) &
        DEALLOCATE( Particles % Force )
    
    DEALLOCATE( Particles % Coordinate ) 
    DEALLOCATE( Particles % Distance ) 
    DEALLOCATE( Particles % Dt ) 
    DEALLOCATE( Particles % Status ) 
    DEALLOCATE( Particles % FaceIndex )
    DEALLOCATE( Particles % ElementIndex ) 
    
    Particles % NumberOfParticles = 0
    Particles % MaxNumberOfParticles = 0
    
  END SUBROUTINE DestroyParticles
  


  !---------------------------------------------------------
  ! Subroutine for releaseing initiated but waiting particles.
  !---------------------------------------------------------
  SUBROUTINE ReleaseWaitingParticles(Particles) 
    TYPE(Particle_t) :: Particles
    
    TYPE(ValueList_t), POINTER :: Params
    INTEGER, POINTER :: Status(:)
    INTEGER :: i,j,NoParticles,ReleaseCount=0,ReleaseSet
    REAL(KIND=dp) :: ReleaseFraction
    LOGICAL :: Found,Visited = .FALSE.
    
    SAVE Visited, ReleaseCount
    
    ! Check whether all particles have already been released
    !-------------------------------------------------------
    NoParticles = Particles % NumberOfParticles
    IF( ReleaseCount >= NoParticles ) RETURN
    
    
    ! Get the size of the current release set
    !-------------------------------------------------------
    Params => GetSolverParams()
    ReleaseSet = GetInteger( Params,'Particle Release Number',Found)
    IF( .NOT. Found ) THEN
      ReleaseFraction = GetCReal( Params,'Particle Release Fraction',Found )
      IF(.NOT. Found ) THEN
        RETURN
      ELSE
        ReleaseSet = NINT( ReleaseFraction * NoParticles ) 
      END IF
    END IF
    PRINT *,'Releasing:',NoParticles,ReleaseCount, ReleaseSet
    
    
    IF( ReleaseSet <= 0 ) RETURN
    
    ! Release some waiting particles
    !-------------------------------------------------------
    Status => Particles % Status
    j = 0
    DO i=1,NoParticles
      IF( Status(i) == PARTICLE_WAITING ) THEN      
        Status(i) = PARTICLE_INITIATED 
        j = j + 1
        IF( j == ReleaseSet ) EXIT
      END IF
    END DO
    ReleaseCount = ReleaseCount + j
    
    
  END SUBROUTINE ReleaseWaitingParticles
  

  !---------------------------------------------------------
  ! Subroutine for chanching the partition of particles that
  ! cross the partition boundary.
  !---------------------------------------------------------
  FUNCTION ChangeParticlePartition(Particles) RESULT(nReceived)
    !---------------------------------------------------------
    TYPE(Particle_t) :: Particles
    !---------------------------------------------------------
    TYPE(Element_t), POINTER :: Face, Parent, Faces(:)
    
    INTEGER i,j,k,l,m,n,dim,NoPartitions, nextPart, nFaces, &
        Proc, ierr, status(MPI_STATUS_SIZE), n_part, nReceived
    
    INTEGER, ALLOCATABLE :: Perm(:), Indexes(:), Neigh(:), &
        Recv_parts(:), Requests(:)
    TYPE(Mesh_t), POINTER :: Mesh
    
    INTEGER, POINTER :: Neighbours(:)
    LOGICAL, POINTER :: FaceInterface(:), IsNeighbour(:)
    
    TYPE ExchgInfo_t
      INTEGER :: n=0
      INTEGER, POINTER :: Gindex(:), Particles(:)
    END TYPE ExchgInfo_t
    
    REAL(KIND=dp), ALLOCATABLE :: Buf(:)
    TYPE(ExchgInfo_t), ALLOCATABLE :: Info(:)
    !---------------------------------------------------------
    
    nReceived = 0
    IF( ParEnv% PEs == 1 ) RETURN
    
    Mesh => GetMesh()
    dim = Particles % dim
    
    ! Count & Identify neighbouring partitions:
    ! -----------------------------------------
    ALLOCATE(IsNeighbour(ParEnv % PEs))
    NoPartitions = MeshNeighbours(Mesh,IsNeighbour)
    ALLOCATE(Perm(ParEnv % PEs), Neigh(NoPartitions) )
    Perm = 0
    
    NoPartitions=0
    DO i=1,ParEnv % PEs
      IF ( i-1==ParEnv % Mype ) CYCLE
      IF ( IsNeighbour(i) ) THEN
        NoPartitions=NoPartitions+1
        Perm(i) = NoPartitions
        Neigh(NoPartitions) = i-1
      END IF
    END DO
    DEALLOCATE(IsNeighbour)
    
    !
    ! Count particles to be sent to neighbours:
    ! -----------------------------------------
    ALLOCATE(Info(NoPartitions))
    Info % n = 0
    
    DO i=1,Particles % NumberOfParticles
      IF( Particles % Status(i) /= PARTICLE_WALLBOUNDARY ) CYCLE
      
      IF ( dim==2 ) THEN
        Face => Mesh % Edges(Particles % FaceIndex(i))
        FaceInterface  => Mesh % ParallelInfo % EdgeInterface
        Neighbours => Mesh % ParallelInfo %  &
            EdgeNeighbourList(Face % ElementIndex) % Neighbours
      ELSE
        Face => Mesh % Faces(Particles % FaceIndex(i))
        FaceInterface => Mesh % ParallelInfo % FaceInterface
        Neighbours => Mesh % ParallelInfo %  &
            FaceNeighbourList(Face % ElementIndex) % Neighbours
      END IF
      
      IF ( FaceInterface(Face % ElementIndex) ) THEN
        IF ( Face % BoundaryInfo % Constraint > 0 ) &
            CALL Warn("ChangeParticlePartition", "is this a BC after all?")
        
        nextPart = ParEnv % MyPE
        DO j=1,SIZE(Neighbours)
          IF ( ParEnv % Mype /= Neighbours(j) ) THEN
            nextPart = Neighbours(j)
            k = Perm(nextPart+1)
            IF ( k>0 ) THEN
              Info(k) % n=Info(k) % n+1
              Particles % Status(i) = PARTICLE_PARTBOUNDARY
            ELSE 
              Particles % Status(i) = PARTICLE_LOST
            END IF
            EXIT
          END IF
        END DO
      END IF
    END DO
    
    !
    ! Receive interface sizes:
    !--------------------------
    ALLOCATE( Recv_Parts(NoPartitions), Requests(NoPartitions) )
    DO i=1,NoPartitions
      CALL MPI_iRECV( Recv_Parts(i),1, MPI_INTEGER, Neigh(i), &
          1000, MPI_COMM_WORLD, requests(i), ierr )
    END DO
    
    DO i=1,NoPartitions
      CALL MPI_BSEND( Info(i) % n, 1, MPI_INTEGER, Neigh(i), &
          1000, MPI_COMM_WORLD, ierr )
    END DO
    CALL MPI_WaitAll( NoPartitions, Requests, MPI_STATUSES_IGNORE, ierr )
    
    n = SUM(Recv_Parts)
    CALL MPI_ALLREDUCE( n, nReceived, 1, MPI_INTEGER, &
        MPI_SUM, MPI_COMM_WORLD, ierr )
    IF ( nReceived==0 ) THEN
      DEALLOCATE(Recv_Parts, Requests, Info, Perm, Neigh)
      RETURN
    END IF
    
    !
    ! Collect particles to be sent to neighbours:
    ! -------------------------------------------
    DO i=1,NoPartitions
      ALLOCATE( Info(i) % Gindex(Info(i) % n), Info(i) % Particles(Info(i) % n) )
      Info(i) % n = 0
    END DO
    
    DO i=1,Particles % NumberOfParticles
      IF( Particles % Status(i) /= PARTICLE_PARTBOUNDARY ) CYCLE
      
      IF ( dim==2 ) THEN
        Face => Mesh % Edges(Particles % FaceIndex(i))
        FaceInterface  => Mesh % ParallelInfo % EdgeInterface
        Neighbours => Mesh % ParallelInfo %  &
            EdgeNeighbourList(Face % ElementIndex) % Neighbours
      ELSE
        Face => Mesh % Faces(Particles % FaceIndex(i))
        FaceInterface => Mesh % ParallelInfo % FaceInterface
        Neighbours => Mesh % ParallelInfo %  &
            FaceNeighbourList(Face % ElementIndex) % Neighbours
      END IF
      
      IF ( FaceInterface(Face % ElementIndex) ) THEN
        nextPart = ParEnv % MyPE
        DO j=1,SIZE(Neighbours)
          IF ( ParEnv % Mype /= Neighbours(j) ) THEN
            nextPart = Neighbours(j);
            EXIT
          END IF
        END DO
        Particles % Status(i) = PARTICLE_LOST
        j = Perm(nextPart+1)
        IF ( j==0 ) THEN
          CALL Warn( 'ChangeParticlePartition', 'Neighbouring partition not found?')
          CYCLE
        END IF
        Info(j) % n = Info(j) % n+1
        n = Info(j) % n
        Info(j) % Particles(n) = i
        Info(j) % Gindex(n) = Face % GElementIndex
      END IF
    END DO
    

    n = 0
    DO i=1,NoPartitions
      n = n + Info(i) % n
    END DO
    n = 2*(n + 2*(2*n*dim+n) + MPI_BSEND_OVERHEAD*2*NoPartitions)
    CALL CheckBuffer(n)
    
    ! Send particles:
    ! ---------------
    DO j=1,NoPartitions
      n = Info(j) % n
      IF ( n<=0 ) CYCLE
      
      CALL MPI_BSEND( Info(j) % Gindex, n, MPI_INTEGER, Neigh(j), &
          1001, MPI_COMM_WORLD, ierr )
      
      ALLOCATE(Buf(2*n*dim+n))
      m = 0
      DO k=1,dim
        DO l=1,n
          m = m + 1
          Buf(m) = Particles % Coordinate(Info(j) % Particles(l),k)
        END DO
      END DO
      DO l=1,n
        m = m + 1
        Buf(m) = Particles % Dt(Info(j) % Particles(l))
      END DO
      
      IF ( ASSOCIATED(Particles % Velocity) ) THEN
        DO k=1,dim
          DO l=1,n
            m = m + 1
            Buf(m) = Particles % Velocity(Info(j) % Particles(l),k)
          END DO
        END DO
      END IF
      
      CALL MPI_BSEND( Buf, m, MPI_DOUBLE_PRECISION, &
          Neigh(j), 1002, MPI_COMM_WORLD, ierr )
      
      DEALLOCATE(Buf)
    END DO
    

    DEALLOCATE(Perm)
    DO i=1,NoPartitions
      DEALLOCATE( Info(i) % Gindex, Info(i) % Particles )
    END DO
    DEALLOCATE(Info)


    ! Recv particles:
    ! ---------------
    
    n = SUM(Recv_Parts)
    IF ( Particles % NumberOfParticles+n > Particles % MaxNumberOfParticles ) THEN
      CALL IncreaseParticles( Particles, Particles % NumberOfParticles+2*n - &
          Particles % MaxNumberOfParticles )
    END IF
    
    IF(Particles % dim==2 ) THEN
      nFaces = Mesh % NumberOfEdges
      Faces => Mesh % Edges
    ELSE
      Faces => Mesh % Faces
      nFaces = Mesh % NumberOfFaces
    END IF
    
    
    DO i=1,NoPartitions
      n = Recv_Parts(i)
      IF ( n<=0 ) CYCLE
      
      proc = Neigh(i)
      ALLOCATE(Indexes(n))
      
      CALL MPI_RECV( Indexes, n, MPI_INTEGER, proc, &
          1001, MPI_COMM_WORLD, status, ierr )
      
      n_part=Particles % NumberOfParticles
      DO j=1,n
        k=SearchElement( nFaces, Faces, Indexes(j) )
        IF ( k<=0 ) THEN
          PRINT*,ParEnv % myPE, 'failed'
          CYCLE
        END IF
        
        Face => Faces(k) 
        Parent => Face % BoundaryInfo % Left
        IF ( .NOT.ASSOCIATED(Parent) ) &
            Parent => Face % BoundaryInfo % Right
        
        n_part = n_part+1
        Particles % Status(n_part) = PARTICLE_PARTBOUNDARY
        Particles % ElementIndex(n_part) = Parent % ElementIndex
      END DO
      
      ALLOCATE(Buf(2*n*dim+n))
      
      m = n*dim+n
      IF ( ASSOCIATED(Particles % Velocity) ) m=m+n*dim
      CALL MPI_RECV( Buf, m, MPI_DOUBLE_PRECISION, proc, &
          1002, MPI_COMM_WORLD, status, ierr )
      
      n_part=Particles % NumberOfParticles
      m = 0
      DO k=1,dim
        DO l=1,n
          m = m + 1
          Particles % Coordinate(n_part+l,k)=Buf(m)
        END DO
      END DO
      
      DO l=1,n
        m = m + 1
        Particles % Dt(n_part+l) = Buf(m)
      END DO
      
      IF ( ASSOCIATED(Particles % Velocity) ) THEN
        DO k=1,dim
          DO l=1,n
            m = m + 1
            Particles % Velocity(n_part+l,k)=Buf(m)
          END DO
        END DO
      END IF
      DEALLOCATE(Buf)
      
      Particles % NumberOfParticles = Particles % NumberOfParticles+n
      DEALLOCATE(Indexes)
    END DO
    
    DEALLOCATE(Recv_Parts, Neigh, Requests)
    CALL MPI_BARRIER( MPI_COMM_WORLD, ierr )
    
  CONTAINS
    
    !
    ! Search an element Item from an ordered Element_t array(N) and return
    ! Index to that array element. Return value -1 means Item was not found.
    !
    FUNCTION SearchElement( N, IArray, Item ) RESULT(Indx)
      IMPLICIT NONE
      
      INTEGER :: Item, Indx, i
      INTEGER :: N
      TYPE(Element_t) :: Iarray(:)
      
      ! Local variables
      
      INTEGER :: Lower, Upper, lou
      
      !*********************************************************************
      
      Indx  = -1
      Upper =  N
      Lower =  1
      
      ! Handle the special case
      
      IF ( Upper < Lower ) RETURN
      
      DO WHILE( .TRUE. )
        IF ( IArray(Lower) % GelementIndex == Item ) THEN
          Indx = Lower
          EXIT
        ELSE IF ( IArray(Upper) % GelementIndex == Item ) THEN
          Indx = Upper
          EXIT
        END IF
        
        IF ( (Upper - Lower) > 1 ) THEN
          Lou = ISHFT((Upper + Lower), -1)
          IF ( IArray(lou) % GelementIndex < Item ) THEN
            Lower = Lou
          ELSE
            Upper = Lou
          END IF
        ELSE
          EXIT
        END IF
      END DO
    END FUNCTION SearchElement
  END FUNCTION ChangeParticlePartition
  

  !---------------------------------------------------------
  ! Computes the means of coordinates / velocities / force
  ! The statistics could be made more detailed...
  !---------------------------------------------------------
  SUBROUTINE ParticleStatistics( Particles, DerOrder ) 
    TYPE(Particle_t) :: Particles
    INTEGER :: DerOrder
    
    REAL(KIND=dp) :: Coord(3),MeanCoord(3),AbsCoord(3),VarCoord(3), &
        MinCoord(3), MaxCoord(3)
    
    INTEGER :: i,j,Cnt,NoParticles,TotParticles,dim
    REAL(KIND=dp), POINTER :: TargetVector(:,:)
    INTEGER, POINTER :: Status(:)
    
    MeanCoord = 0.0_dp
    AbsCoord = 0.0_dp
    VarCoord = 0.0_dp
    MinCoord = HUGE( MinCoord )
    MaxCoord = -HUGE( MaxCoord )
    
    Cnt = 0
    NoParticles =  Particles % NumberOfParticles
    dim = Particles % dim
    Coord = 0.0_dp
    
    IF( DerOrder == 0 ) THEN
      TargetVector => Particles % Coordinate
    ELSE IF( DerOrder == 1 ) THEN
      TargetVector => Particles % Velocity
    ELSE IF( DerOrder == 2 ) THEN
      TargetVector => Particles % Force
    ELSE
      CALL Fatal('ParticleStatistics','Unknown value for DerOrder!')
    END IF
    
    Status => Particles % Status
    
    DO i=1,NoParticles
      IF( Status(i) >= PARTICLE_LOST ) CYCLE
      IF( Status(i) < PARTICLE_INITIATED ) CYCLE
      
      Coord(1:dim) = TargetVector(i,1:dim)
      
      MeanCoord = MeanCoord + Coord
      AbsCoord = AbsCoord + ABS( Coord )
      VarCoord = VarCoord + Coord**2
      DO j=1,dim
        MinCoord(j) = MIN( MinCoord(j), Coord(j) )
        MaxCoord(j) = MAX( MaxCoord(j), Coord(j) )
      END DO
      Cnt = Cnt + 1
    END DO
    
    TotParticles = NINT( ParallelReduction( 1.0_dp * Cnt ) )
    
    IF( TotParticles > 0 ) THEN
      ! Compute parallel sums?
      DO j=1,dim
        MeanCoord(j) = ParallelReduction( MeanCoord(j) )
        AbsCoord(j) = ParallelReduction( AbsCoord(j) ) 
        VarCoord(j) = ParallelReduction( varCoord(j) )
        MinCoord(j) = ParallelReduction( MinCoord(j),1 )
        MaxCoord(j) = ParallelReduction( MaxCoord(j),2 )
      END DO
      
      MeanCoord = MeanCoord / TotParticles
      AbsCoord = AbsCoord / TotParticles
      VarCoord = SQRT( VarCoord / TotParticles - MeanCoord**2 ) 
      
      IF( ParEnv % myPE == 0 ) THEN
        IF( DerOrder == 0 ) THEN
          PRINT *,'Statistical info on coordinate values:'
        ELSE IF( DerOrder == 1 ) THEN
          PRINT *,'Statistical info on velocity values:'
        ELSE IF( DerOrder == 2 ) THEN
          PRINT *,'Statistical info on force values:'
        END IF
        
        PRINT *,'Mean:',MeanCoord(1:dim)
        PRINT *,'Abs: ',AbsCoord(1:dim)
        PRINT *,'Var: ',VarCoord(1:dim)
        PRINT *,'Min: ',MinCoord(1:dim)
        PRINT *,'Max: ',MaxCoord(1:dim)
      END IF
    ELSE
      CALL Warn('MeanParticleCoordinate','No active particles!')
    END IF
    
  END SUBROUTINE ParticleStatistics
  


  !---------------------------------------------------------
  ! Computes the characterestic speed for time integration.
  ! The speed may be either computed for the whole set or
  ! alternatively to just one particle.
  !---------------------------------------------------------
  FUNCTION CharacteristicSpeed( Particles, No ) RESULT ( CharSpeed )
    TYPE(Particle_t) :: Particles
    REAL(KIND=dp) :: CharSpeed
    INTEGER, OPTIONAL :: No
    
    REAL(KIND=dp) :: Velo(3),Speed,SumSpeed,MaxSpeed
    INTEGER :: i,j,Cnt,NoParticles,dim,ParallelParticles
    REAL(KIND=dp), POINTER :: Velocity(:,:)
    INTEGER, POINTER :: Status(:)
    TYPE(ValueList_t), POINTER :: Params
    LOGICAL :: UseMax, Visited = .FALSE.
    
    SAVE Visited, UseMax
    
    IF(.NOT. Visited ) THEN
      Params => GetSolverParams()
      UseMax = GetLogical( Params,'Max Characteristic Speed')
      Visited = .TRUE.
    END IF
    
    
    dim = Particles % dim
    Velocity => Particles % Velocity
    
    IF( PRESENT(No)) THEN
      Velo(1:dim) = Velocity(No,1:dim)
      CharSpeed = SQRT( SUM( Velo(1:dim) ** 2 ) )
      RETURN
    END IF
    
    NoParticles =  Particles % NumberOfParticles
    Status => Particles % Status
    CharSpeed = 0.0_dp
    Velo = 0.0_dp
    Cnt = 0
    
    ! Compute characteristic speed for square since it avoids taking the sqrt
    DO i=1,NoParticles
      IF( Status(i) >= PARTICLE_LOST ) CYCLE
      IF( Status(i) < PARTICLE_INITIATED ) CYCLE
      
      Cnt = Cnt + 1
      Velo(1:dim) = Velocity(i,1:dim)
      Speed = SUM( Velo(1:dim) ** 2 ) 
      SumSpeed = SumSpeed + Speed
      MaxSpeed = MAX( MaxSpeed, Speed ) 
    END DO
    
    IF( Cnt == 0 ) RETURN
    
    IF( UseMax ) THEN 
      CharSpeed = ParallelReduction( MaxSpeed, 2 )
    ELSE
      ParallelParticles = NINT( ParallelReduction( 1.0_dp * Cnt ) )
      CharSpeed = ParallelReduction( SumSpeed ) / ParallelParticles
    END IF
    CharSpeed = SQRT( CharSpeed ) 
    
    IF(.FALSE.) THEN
      WRITE( Message,'(A,E12.6)') 'Speed for timestep control: ',CharSpeed
      CALL Info('CharacteristicSpeed',Message )
    END IF
    
  END FUNCTION CharacteristicSpeed


  !---------------------------------------------------------
  ! Computes the characterestic time spent in an element
  ! Currently computed just for one element as computing the 
  ! size of element is a timeconsuming operation.
  !---------------------------------------------------------
  FUNCTION CharacteristicElementTime( Particles, No ) RESULT ( CharTime )
    
    TYPE(Particle_t) :: Particles
    REAL(KIND=dp) :: CharTime
    INTEGER, OPTIONAL :: No
    
    REAL(KIND=dp) :: CharSpeed, ElementSize, u, v, w, DetJ
    REAL(KIND=dp), POINTER :: Basis(:)
    LOGICAL :: Stat, Visited = .FALSE.
    TYPE(Element_t), POINTER :: Element
    TYPE(Nodes_t) :: Nodes
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER :: n, dim, ElementFamily
    
    SAVE Visited, ElementSize
    
    IF( .NOT. Visited ) THEN
      Visited = .TRUE.
      
      ! Note: the elements are assumed to be of equal size!!!
      Mesh => GetMesh()
      dim = Mesh % MeshDim
      Element => Mesh % Elements(1)
      
      CALL GetElementNodes( Nodes, Element ) 
      n = Element % TYPE % NumberOfNodes
      ALLOCATE( Basis(n) )
      ElementFamily  = GetElementFamily( Element )
      
      u = 0.0_dp
      v = 0.0_dp
      w = 0.0_dp
      
      IF( ElementFamily == 3 ) THEN
        u = 1.0/3.0_dp
        v = 1.0/3.0_dp
        w = 0.0_dp
      ELSEIF( ElementFamily == 5 ) THEN
        u = 0.25_dp
        v = 0.25_dp
        w = 0.25_dp
      END IF
      
      stat = ElementInfo( Element, Nodes, U, V, W, detJ, Basis )
      ElementSize = detJ ** ( 1.0_dp / dim )
      
      DEALLOCATE( Basis )
      PRINT *,'ElementSize:',ElementSize
    END IF
    
    CharSpeed = CharacteristicSpeed( Particles, No ) 
    CharTime = ElementSize / CharSpeed
    
  END FUNCTION CharacteristicElementTime
  


  !------------------------------------------------------------------------
  ! Initialize particle positions and velocities.
  !-------------------------------------------------------------------------
  SUBROUTINE InitializeParticles( Particles, InitParticles, AppendParticles ) 
    
    TYPE(Particle_t) :: Particles
    INTEGER, OPTIONAL :: InitParticles
    LOGICAL, OPTIONAL :: AppendParticles
    
    TYPE(ValueList_t), POINTER :: Params 
    TYPE(Variable_t), POINTER :: Var
    TYPE(Element_t), POINTER :: CurrentElement
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER :: Offset, NewParticles,LastParticle,NoElements
    INTEGER :: dim, ElementIndex
    REAL(KIND=dp), POINTER :: rWork(:,:),Coordinate(:,:), Velocity(:,:)
    REAL(KIND=dp) :: Velo(3), Coord(3), Center(3), time0, dist
    CHARACTER(LEN=MAX_NAME_LEN) :: InitMethod
    INTEGER :: i,j,k,n,nonodes, InitStatus, TotParticles
    INTEGER, POINTER :: MaskPerm(:), InvPerm(:), NodeIndexes(:)
    LOGICAL :: GotIt, GotMask, RequirePositivity
    REAL(KIND=dp), POINTER :: InitialValues(:,:)
    REAL(KIND=dp) :: mass,boltz,temp,coeff,eps,frac,meanval 
    REAL(KIND=dp) :: MinCoord(3), MaxCoord(3), Diam
    REAL(KIND=dp), POINTER :: MaskVal(:)
    INTEGER :: nx,ny,nz,nmax,ix,iy,iz,ind
    LOGICAL, POINTER :: DoneParticle(:)
    CHARACTER(LEN=MAX_NAME_LEN) :: VariableName
    
    
    Mesh => GetMesh()
    Params => GetSolverParams()
    dim = Particles % Dim
    
    !------------------------------------------------------------------------
    ! Position may be initialized using a given list, or using the nodal
    ! coordinates to initalize positions.
    !-------------------------------------------------------------------------
    
    InitMethod = ListGetString( Params,'Coordinate Initialization Method',gotIt ) 
    
    !------------------------------------------------------------------------
    ! The user may use a mask to initialize the particles only at a part of the 
    ! domain, or to utilize the ordeing of the permutation vector.
    ! Create the mask before deciding on the number which may be relative
    !-------------------------------------------------------------------------  
    GotMask = .FALSE.
    VariableName = ListGetString( Params,'Initialization Condition Variable',GotIt )
    IF(GotIt) THEN
      RequirePositivity = .TRUE.
    ELSE
      VariableName = ListGetString( Params,'Initialization Mask Variable',GotIt )
      RequirePositivity = .FALSE.
    END IF
    
    IF(GotIt) THEN
      Var => VariableGet( Mesh % Variables, TRIM(VariableName) )
      IF( .NOT. ASSOCIATED( Var ) ) THEN
        CALL Fatal('InitializeParticles','Mask / Condition variable does not exist!')
      END IF
      
      MaskPerm => Var % Perm
      MaskVal => Var % Values
      
      IF(.NOT. ( ASSOCIATED( MaskPerm ) .AND. ASSOCIATED(MaskVal)) ) THEN
        CALL Warn('InitializeParticles','Initialization variable does not exist?')
      ELSE IF( MAXVAL( MaskPerm ) == 0 ) THEN
        CALL Warn('InitializeParticles','Initialization variable of size zero?')
        nonodes = 0
        noelements = 0
        InvPerm => NULL()
      ELSE
        GotMask = .TRUE.
        IF( InitMethod(1:5) == 'nodal') THEN
          ALLOCATE( InvPerm(SIZE(MaskPerm)) )
          InvPerm = 0
          j = 0
          DO i=1,SIZE(MaskPerm)
            k = MaskPerm(i)
            IF( k == 0 ) CYCLE
            IF( RequirePositivity ) THEN
              IF( MaskVal( k ) < 0.0_dp ) CYCLE
            END IF
            j = j + 1
            InvPerm(j) = i
          END DO
          nonodes = j
          
          PRINT *,'Total nodes vs. masked',Mesh % NumberOfNodes,nonodes
        ELSE IF( InitMethod(1:9) == 'elemental') THEN
          ALLOCATE( InvPerm( MAX( Mesh % NumberOfBulkElements, Mesh % NumberOfBoundaryElements ) ) ) 
          InvPerm = 0
          
          j = 0
          DO i=1,Mesh % NumberOfBulkElements + Mesh % NumberOfBoundaryElements
            CurrentElement => Mesh % Elements(i)
            NodeIndexes =>  CurrentElement % NodeIndexes
            n = CurrentElement % TYPE % NumberOfNodes
            
            IF( i == Mesh % NumberOfBulkElements ) THEN
              IF( j > 0 ) EXIT
            END IF
            
            IF( ANY( MaskPerm( NodeIndexes ) == 0 ) ) CYCLE
            
            IF( RequirePositivity ) THEN
              meanval = SUM( MaskVal( MaskPerm( NodeIndexes ) ) ) 
              IF( meanval < 0.0_dp ) CYCLE
            END IF
            
            ! If some of bulk elements have been found avtive
            j = j + 1
            InvPerm(j) = i
            
          END DO
          noelements = j
          
          PRINT *,'Total elements vs. masked',Mesh % NumberOfBulkElements,noelements
        END IF
      END IF
    ELSE
      nonodes = Mesh % NumberOfNodes
      noelements = Mesh % NumberOfBulkElements
    END IF
    
    
    !------------------------------------------------------------------------
    ! Use a simple bounding box for initializatin
    ! By default a local bounding box is used...
    !-------------------------------------------------------------------------  
    IF( InitMethod(1:3) == 'box') THEN
      Eps = GetCReal( Params,'Wall Particle Radius',GotIt)
      IF(.NOT. GotIt) eps = 1.0d-8
      
      MinCoord(1) = GetCReal( Params,'Min Initial Coordinate 1',GotIt) 
      IF(.NOT. GotIt) MinCoord(1) = Particles % LocalMinCoord(1) + eps
      
      MaxCoord(1) = GetCReal( Params,'Max Initial Coordinate 1',GotIt) 
      IF(.NOT. GotIt) MaxCoord(1) = Particles % LocalMaxCoord(1) - eps
      
      MinCoord(2) = GetCReal( Params,'Min Initial Coordinate 2',GotIt) 
      IF(.NOT. GotIt) MinCoord(2) = Particles % LocalMinCoord(2) + eps
      
      MaxCoord(2) = GetCReal( Params,'Max Initial Coordinate 2',GotIt) 
      IF(.NOT. GotIt) MaxCoord(2) = Particles % LocalMaxCoord(2) - eps
      
      MinCoord(3) = GetCReal( Params,'Min Initial Coordinate 3',GotIt) 
      IF(.NOT. GotIt) MinCoord(3) = Particles % LocalMinCoord(3) 
      
      MaxCoord(3) = GetCReal( Params,'Max Initial Coordinate 3',GotIt) 
      IF(.NOT. GotIt) MaxCoord(3) = Particles % LocalMaxCoord(3) - eps
    END IF
    
    
    IF( InitMethod == 'box random cubic') THEN
      Diam = 2 * GetCReal( Params,'Particle Cell Radius',GotIt)
      IF(.NOT. GotIt ) THEN
        Diam = 2 * GetCReal( Params,'Particle Radius',GotIt)
      END IF
      IF(.NOT. GotIt ) THEN
        CALL Fatal('InitializeParticles','Size of unit cell not given')
      END IF
      
      nx = NINT ( ( MaxCoord(1) - MinCoord(1) ) / Diam )
      ny = NINT( ( MaxCoord(2) - MinCoord(2) ) / Diam )
      IF( dim == 3 ) THEN
        nz = NINT( ( MaxCoord(3) - MinCoord(3) ) / Diam )
      ELSE
        nz = 1
      END IF
      
      PRINT *,'n:',nx,ny,nz,nx*ny*nz
      PRINT *,'Min:',MinCoord
      PRINT *,'Max:',MaxCoord
    END IF
    
    
    !------------------------------------------------------------------------
    ! Now decide on the number of particles.
    !-------------------------------------------------------------------------  
    IF( PRESENT( AppendParticles ) ) THEN
      Offset = Particles % NumberOfParticles
    ELSE
      Offset = 0
    END IF
    
    IF( PRESENT( InitParticles ) ) THEN
      NewParticles = InitParticles
    ELSE
      NewParticles = GetInteger( Params,'Number of Particles',GotIt) 
      IF(.NOT. GotIt ) THEN
        frac = GetCReal( Params,'Particle Node Fraction',GotIt)      
        IF( GotIt ) THEN
          NewParticles = NINT( frac * nonodes )
        ELSE
          frac = GetCReal( Params,'Particle Element Fraction',GotIt)
          IF( GotIt ) THEN
            NewParticles = NINT( frac * noelements )
          ELSE
            frac = GetCReal( Params,'Particle Cell Fraction',GotIt)
            IF( GotIt ) THEN
              NewParticles = NINT( frac * nx * ny * nz )
            ELSE
              CALL Fatal('InitializeParticles','Could not determine the number of new particles!')
            END IF
          END IF
        END IF
      END IF
    END IF
    
    IF( ParEnv% PEs == 1 ) THEN
      TotParticles = NewParticles
    ELSE
      TotParticles = NINT( ParallelReduction( 1.0_dp * NewParticles ) )
    END IF
    
    IF( TotParticles == 0 ) THEN
      CALL Fatal('InitializeParticles','No Particles to Initialize')
    ELSE
      WRITE( Message,'(A,I8)') 'Total Number of Particles:',TotParticles
      CALL Info('InitializeParticles',Message)
    END IF

    !------------------------------------------------------------------------
    ! If there are no particles in this partition, nothing to do
    !------------------------------------------------------------------------- 
    IF( NewParticles == 0 ) RETURN
    
    
    !------------------------------------------------------------------------
    ! Interval of particles
    !-------------------------------------------------------------------------  
    IF( PRESENT( AppendParticles ) ) THEN
      Offset = Particles % NumberOfParticles
    ELSE
      Offset = 0
    END IF
    LastParticle = Offset + NewParticles
    
    
    !------------------------------------------------------------------------
    ! Allocate particles
    !-------------------------------------------------------------------------    
    CALL AllocateParticles( Particles, LastParticle )
    
    Particles % NumberOfParticles = LastParticle
    
    Velocity => Particles % Velocity
    Coordinate => Particles % Coordinate
    
    
    SELECT CASE ( InitMethod ) 
      
    CASE ('nodal ordered')
      NewParticles = MIN(NoElements,NewParticles)
      Particles % NumberOfParticles = NewParticles
      PRINT *,'Initializing particles in nodes:',NewParticles,nonodes
      DO i=1,NewParticles
        k = Offset + i
        j = (nonodes-1)*(i-1)/(NewParticles-1)+1
        j = MODULO( i * NewParticles -1 , nonodes ) + 1
        IF( GotMask ) j = InvPerm(j)
        Coordinate(k,1) = Mesh % Nodes % x(j)
        Coordinate(k,2) = Mesh % Nodes % y(j)
        IF( dim == 3 ) Coordinate(k,3) = Mesh % Nodes % z(j)
      END DO
      
    CASE ('elemental ordered')
      NewParticles = MIN(NoElements,NewParticles)
      Particles % NumberOfParticles = NewParticles
      PRINT *,'Initializing particles in elements:',NewParticles,noelements
      DO i=1,NewParticles
        k = Offset + i
        j = (NoElements-1)*(i-1)/(NewParticles-1)+1
        IF( GotMask ) j = InvPerm(j)
        
        
        IF( j > Mesh % NumberOfBulkElements ) THEN
          PRINT *,'j too large',j,i,k,(NoElements-1)*(i-1)/(NewParticles-1)+1
        END IF
        
        CurrentElement => Mesh % Elements(j)
        NodeIndexes =>  CurrentElement % NodeIndexes
        n = CurrentElement % TYPE % NumberOfNodes
        Coordinate(k,1) = SUM( Mesh % Nodes % x(NodeIndexes ) ) / n
        Coordinate(k,2) = SUM( Mesh % Nodes % y(NodeIndexes ) ) / n
        IF( dim == 3 ) Coordinate(k,3) = SUM( Mesh % Nodes % z(NodeIndexes ) ) / n
        
        ! Only a bulk element may own a particle
        IF( j <= Mesh % NumberOfBulkElements ) THEN
          Particles % ElementIndex(i) = j
        END IF
      END DO
      PRINT *,'done init'
      
    CASE ('sphere random')
      Diam = GetCReal( Params,'Initial Sphere Radius')
      rWork => ListGetConstRealArray( Params,'Initial Sphere Center')
      IF ( ASSOCIATED(rwork) ) THEN
        Center = rWork(1:3,1)
      ELSE
        Center = 0.0_dp
      END IF
      
      i = 0
      DO WHILE (.TRUE.) 
        DO j=1,dim
          Coord(j) = Diam*(2*EvenRandom()-1)
        END DO
        ! Is the point within sphere (or circle in 2d)
        IF( SUM( Coord(1:dim)**2 ) > Diam*Diam ) CYCLE
        
        i = i + 1
        k = Offset + i      
        Coordinate(k,:) = Center + Coord(1:dim)
        IF( i == NewParticles ) EXIT
      END DO
      
    CASE ('box random')
      DO i=1,NewParticles
        k = Offset + i      
        DO j=1,dim
          Coord(j) = MinCoord(j) + (MaxCoord(j)-MinCoord(j)) * EvenRandom()
        END DO
        Coordinate(k,:) = Coord(1:dim)
      END DO
      
    CASE ('box random cubic')
      nmax = nx * ny * nz
      IF( nmax < NewParticles ) THEN
        CALL Fatal('InitializeParticles','More particles than places in unit cell')
      END IF
      
      ALLOCATE( DoneParticle(nx*ny*nz) )
      
      IF( NewParticles == nmax ) THEN
        ! if the list is full just set all true
        DoneParticle = .TRUE.
      ELSE IF( NewParticles < nmax / 2 ) THEN
        ! If there are few particles start from an empty list and count upwards
        DoneParticle = .FALSE.
        i =  0
        DO WHILE(.TRUE.) 
          ind = NINT( NewParticles * EvenRandom() + 0.5 )
          IF( .NOT. DoneParticle(i) ) THEN
            DoneParticle(ind) = .TRUE.
            i = i + 1
            IF( i == NewParticles ) EXIT
          END IF
        END DO
      ELSE    
        ! if there are many particles start from a full list and count downwards
        DoneParticle = .TRUE.
        i = nmax
        DO WHILE(.TRUE.) 
          ind = NINT( NewParticles * EvenRandom() + 0.5 )
          IF( DoneParticle(i) ) THEN
            DoneParticle(ind) = .FALSE.
            i = i - 1
            IF( i == NewParticles ) EXIT
          END IF
        END DO
      END IF
      
      ! set the coordinates 
      i = 0
      DO ix = 1, nx
        DO iy = 1, ny
          DO iz = 1, nz
            ind = nx*ny*(iz-1) + nx*(iy-1) + ix
            IF( DoneParticle(ind) ) THEN
              i = i + 1
              k = Offset + i
              Coordinate(k,1) = MinCoord(1) + ( 1.0_dp*ix - 0.5) * Diam 
              Coordinate(k,2) = MinCoord(2) + ( 1.0_dp*iy - 0.5) * Diam 
              IF( dim == 3 ) THEN
                Coordinate(k,3) = MinCoord(3) + ( 1.0_dp*iz - 0.5) * Diam 
              END IF
            END IF
          END DO
        END DO
      END DO
      DEALLOCATE( DoneParticle ) 
      
      
    CASE DEFAULT 
      
      InitialValues => ListGetConstRealArray(Params,'Initial Coordinate',gotIt)    
      IF(gotIt) THEN
        IF( SIZE(InitialValues,2) /= dim ) THEN
          CALL Fatal('ParticleTracker','Wrong dimension in > Initial Coordinate <')
        ELSE IF( SIZE(InitialValues,1) == 1 ) THEN
          DO i=1,NewParticles
            k = offset + i
            Coordinate(k,1:dim) = InitialValues(1,1:dim)
          END DO
        ELSE IF( SIZE(InitialValues,1) /= NewParticles ) THEN
          CALL Fatal('ParticleTracker','Wrong number of particles in > Initial Coordinate <')
        ELSE
          DO i=1,NewParticles
            k = Offset + i
            Coordinate(k,1:dim) = InitialValues(i,1:dim)
          END DO
        END IF
      ELSE
        CALL Fatal('ParticleTracker','> Initial Coordinate < not given')
      END IF
    END SELECT

    IF( GotMask .AND. ASSOCIATED(InvPerm) ) DEALLOCATE( InvPerm ) 

    !------------------------------------------------------------------------
    ! Velocities may be initialized using a given list, or obtaining them
    ! from random even or maxwell boltzmann distributions. These are additive to 
    ! allow bulk velocities with the random one.
    !-------------------------------------------------------------------------

    InitialValues => ListGetConstRealArray(Params,'Initial Velocity',gotIt)
    IF(gotIt) THEN
      IF( SIZE(InitialValues,2) /= DIM ) THEN
        CALL Fatal('ParticleTracker','Wrong dimension in Initial Velocity')
      ELSE IF( SIZE(InitialValues,1) == 1 ) THEN
        DO i=1,NewParticles
          k = Offset + i
          Velocity(k,1:dim) = InitialValues(1,1:DIM)
        END DO
      ELSE IF( SIZE(InitialValues,1) /= NewParticles ) THEN
        CALL Fatal('ParticleTracker','Wrong number of particles in Initial Velocity')
      ELSE
        DO i=1,NewParticles
          k = Offset + i
          Velocity(k,1:dim) = InitialValues(i,1:dim)
        END DO
      END IF
    END IF


    InitMethod = ListGetString( Params,'Velocity Initialization Method',gotIt ) 
    coeff = ListGetCReal( Params,'Initial Velocity Amplitude',GotIt)

    SELECT CASE ( InitMethod ) 
      
    CASE ('thermal random')  
      
      IF(.NOT. GotIt) THEN
        mass = ListGetConstReal( Params,'Particle Mass')
        temp = ListGetConstReal( Params,'Particle Temperature')
        boltz = ListGetConstReal( CurrentModel % Constants,'Boltzmann constant')
        coeff = SQRT(boltz * temp / mass )
      END IF

      DO i=1,NewParticles
        k = Offset + i
        DO j=1,dim
          Velo(j) = coeff * NormalRandom()
        END DO
        Velocity(k,:) = Velocity(k,:) + Velo(1:dim)
      END DO

    CASE ('even random')
      DO i=1,NewParticles
        k = Offset + i
        DO j=1,dim
          Velo(j) = coeff * (2*EvenRandom()-1)
        END DO
        Velocity(k,:) = Velocity(k,:) + Velo(1:dim)
      END DO

    CASE ('constant random')
      DO i=1,NewParticles
        k = Offset + i
        DO j=1,dim
          Velo(j) =  coeff * (2*EvenRandom()-1)
        END DO
        Velo(1:dim) = Velo(1:dim) / SQRT(SUM(Velo(1:dim)**2))
        Velocity(k,:) = Velocity(k,:) + Velo(1:dim)
      END DO

    CASE DEFAULT

    END SELECT


    ! There may be a timestep related to initial velocity,
    ! which may be used to have the initial status developed
    ! from the initial coordinates.
    !-------------------------------------------------------
    time0 = ListGetCReal(Params,'Initial Velocity Time',gotIt)
    IF( GotIt ) THEN
      DO i=1,NewParticles
        k = Offset + i
        Coord(1:dim) = time0 * Velocity(k,:)
        Coordinate(k,:) = Coordinate(k,:) + Coord(1:dim)

        dist = SQRT( SUM( Coord(1:dim)**2 ) )
        Particles % Distance(k) = dist
      END DO
    END IF

    ! Initialize coordinate with octree if requested
    !-------------------------------------------------------
    IF( ListGetLogical(Params,'Initial Coordinate Search',gotIt) ) THEN
      Coord = 0.0_dp
      DO i=1,NewParticles
        k = Offset + i
        ElementIndex = Particles % ElementIndex(k)
        IF( ElementIndex > 0 ) CYCLE       
        Coord(1:dim) = Coordinate(k,:) 
        CALL LocateParticleInMeshOctree( ElementIndex, Coord )
        Particles % ElementIndex(k) = ElementIndex
      END DO
    END IF
    
    !------------------------------------------------------
    ! The initial status of particles is different if using 
    ! gradual release strategy. 
    !-------------------------------------------------------
    IF( ListCheckPresent( Params,'Particle Release Number') .OR. &
      ListCheckPresent( Params,'Particle Release Fraction') ) THEN
      InitStatus = PARTICLE_WAITING
    ELSE
      InitStatus = PARTICLE_INITIATED
    END IF
    
    DO i=1,NewParticles
      k = Offset + i
      Particles % Status(k) = InitStatus
    END DO
    
    
  END SUBROUTINE InitializeParticles

 

  !---------------------------------------------------------------------------
  ! This subroutine finds the possible intersection between elementfaces 
  ! and a line segment.
  !---------------------------------------------------------------------------
  SUBROUTINE SegmentElementIntersection(Mesh,BulkElement,&
      Rinit,Rfin,MinLambda,FaceElement)
    !---------------------------------------------------------------------------
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Element_t), POINTER   :: BulkElement
    REAL(KIND=dp) :: Rinit(3), Rfin(3), MinLambda
    TYPE(Element_t), POINTER :: FaceElement
    
    TYPE(Element_t), POINTER   :: BoundaryElement
    TYPE(Nodes_t), SAVE :: BoundaryNodes
    REAL(KIND=dp) :: Lambda, Epsilon
    INTEGER :: i,j,n
    INTEGER, POINTER :: NodeIndexes(:)
    LOGICAL :: AtBoundary, Visited = .FALSE.
    
    
    SAVE  Visited
    
    MinLambda = HUGE( MinLambda ) 
    Epsilon = TINY( Lambda ) 
    FaceElement => Null()
    
    IF( BulkElement % TYPE % DIMENSION == 3 ) THEN
      DO i=1, BulkElement % TYPE % NumberOfFaces  
        j = BulkElement % FaceIndexes(i)
        BoundaryElement => Mesh % Faces( j )
        CALL GetElementNodes(BoundaryNodes,BoundaryElement)
        
        Lambda = LineFaceIntersection(BoundaryElement,BoundaryNodes,&
            Rinit,Rfin) 
        IF( Lambda > Epsilon ) THEN
          IF( Lambda < MinLambda ) THEN
            MinLambda = Lambda
            FaceElement => BoundaryElement
          END IF
        ELSE IF( Lambda > -Epsilon ) THEN
          AtBoundary = .TRUE.
        END IF
      END DO
    ELSE
      DO i=1, BulkElement % TYPE % NumberOfEdges  
        j = BulkElement % EdgeIndexes(i)
        BoundaryElement => Mesh % Edges(j)
        CALL GetElementNodes(BoundaryNodes,BoundaryElement)
        
        Lambda = LineFaceIntersection(BoundaryElement,BoundaryNodes,&
            Rinit,Rfin) 
        
        IF( Lambda > Epsilon ) THEN
          IF( Lambda < MinLambda ) THEN
            MinLambda = Lambda
            FaceElement => BoundaryElement
          END IF
        ELSE IF( Lambda > -Epsilon ) THEN
          AtBoundary = .TRUE.
        END IF
      END DO
    END IF
    
  END SUBROUTINE SegmentElementIntersection
  
  
  !------------------------------------------------------------------------
  ! Find the particle in the mesh using actree based search. 
  ! This could be preferred in the initial finding of the correct elements.
  ! The major downside of the method is that there is no controlled face
  ! detection needed for wall interaction, for example.
  !------------------------------------------------------------------------
  SUBROUTINE LocateParticleInMeshOctree( ElementIndex, GlobalCoords, &
      LocalCoords )
    
    USE Lists
    
    INTEGER :: ElementIndex
    REAL(KIND=dp) :: GlobalCoords(3)
    REAL(KIND=dp), OPTIONAL :: LocalCoords(3)
    
    TYPE(ValueList_t), POINTER :: Params
    TYPE(Mesh_t), POINTER :: Mesh
    LOGICAL :: Hit, Stat
    INTEGER :: i,j,k,n
    TYPE(Nodes_t), SAVE :: ElementNodes
    INTEGER, POINTER :: NodeIndexes(:)
    TYPE(Element_t), POINTER :: Element
    TYPE(Quadrant_t), POINTER, SAVE :: RootQuadrant =>Null(), LeafQuadrant
    REAL(kind=dp) :: BoundingBox(6), eps2, eps1, uvw(3)
    
    
    Mesh => GetMesh()
    
    ! Check that the previous hit is not hit even now
    !-------------------------------------------------
    IF( ElementIndex > 0 ) THEN
      Element => Mesh % Elements( ElementIndex ) 
      n = GetElementNOFNodes(Element)
      CALL GetElementNodes(ElementNodes,Element)
      
      IF ( PointInElement( Element, ElementNodes, &
          GlobalCoords, LocalCoords ) ) RETURN
    END IF
    
    !-----------------------------------------------------------
    ! Find the right element using an octree search
    ! This is optimal when the particles are searched only once.
    !-----------------------------------------------------------
    IF ( .NOT.ASSOCIATED(Mesh % RootQuadrant) ) THEN
      BoundingBox(1) = MINVAL( Mesh % Nodes % x )
      BoundingBox(2) = MINVAL( Mesh % Nodes % y )
      BoundingBox(3) = MINVAL( Mesh % Nodes % z )
      BoundingBox(4) = MAXVAL( Mesh % Nodes % x )
      BoundingBox(5) = MAXVAL( Mesh % Nodes % y )
      BoundingBox(6) = MAXVAL( Mesh % Nodes % z )
      
      eps1 = 1.0e-3
      eps2 = eps1 * MAXVAL( BoundingBox(4:6) - BoundingBox(1:3) )
      BoundingBox(1:3) = BoundingBox(1:3) - eps2
      BoundingBox(4:6) = BoundingBox(4:6) + eps2
      
      CALL BuildQuadrantTree( Mesh,BoundingBox,Mesh % RootQuadrant)
    END IF
    RootQuadrant => Mesh % RootQuadrant
    
    Element => Null()
    ElementIndex = 0
    CALL FindLeafElements(GlobalCoords, Mesh % MeshDim, RootQuadrant, LeafQuadrant)
    IF ( ASSOCIATED(LeafQuadrant) ) THEN
      DO i = 1, LeafQuadrant % NElemsInQuadrant
        j = LeafQuadrant % Elements(i)
        Element => Mesh % Elements(j)
        
        n = GetElementNOFNodes( Element )
        CALL GetElementNodes( ElementNodes, Element)
        
        IF ( PointInElement( Element, ElementNodes, GlobalCoords, uvw ) ) THEN
          IF( PRESENT( LocalCoords) ) LocalCoords = uvw
          ElementIndex = j
          RETURN
        END IF
      END DO
    END IF
    
    IF( ElementIndex == 0 ) THEN
      CALL Warn('LocateParticleInMeshOctree','Could not locate particle in the mesh!')
    END IF
    
  END SUBROUTINE LocateParticleInMeshOctree


  !------------------------------------------------------------------------
  ! Locate the particle using controlled marching from element to element.
  ! The crossing point between given trajectory and all face elements is 
  ! computed. The one that is passed at first is associated to the next 
  ! bulk element.
  !-------------------------------------------------------------------------
  SUBROUTINE LocateParticleInMeshMarch( ElementIndex, Rinit, Rfin, Init, &
      ParticleStatus, StopFaceIndex, Lambda )
    
    INTEGER :: ElementIndex
    REAL(KIND=dp) :: Rinit(3), Rfin(3)
    LOGICAL :: Init
    REAL(KIND=dp), OPTIONAL :: Lambda
    INTEGER :: ParticleStatus
    INTEGER, OPTIONAL :: StopFaceIndex
    
    TYPE(ValueList_t), POINTER :: Params
    TYPE(Mesh_t), POINTER :: Mesh
    REAL(KIND=dp) :: Rtmp(3), MinLambda, eps 
    LOGICAL :: Hit, DoInit, Stat, StopAtFace, AtWall, Visited = .FALSE.,&
        Debug,UseCenter
    INTEGER :: i,j,k,n,FaceIndex,MaxTrials
    TYPE(Nodes_t), SAVE :: ElementNodes
    INTEGER, POINTER :: NodeIndexes(:)
    TYPE(Element_t), POINTER :: Element, FaceElement, LeftElement, RightElement, &
        NextElement
    
    INTEGER, POINTER :: Neighbours(:)
    INTEGER :: NextPartition
    LOGICAL, POINTER :: FaceInterface(:)
    
    SAVE :: Mesh, StopAtFace, Debug, MaxTrials
    
    Mesh => GetMesh()
    
    
    IF( .NOT. Visited ) THEN
      Params => GetSolverParams()
      StopAtFace = ListGetLogical( Params,'Particle Stop At Face',Stat)
      MaxTrials = ListGetInteger( Params,'Max Particle Search Trials',Stat)
      IF(.NOT. Stat) MaxTrials = Mesh % NumberOfBulkElements
      
      Debug = .FALSE.
      Visited = .TRUE.
    END IF
    
    ParticleStatus = PARTICLE_LOST
    IF( PRESENT (StopFaceIndex) ) StopFaceIndex = 0
    IF( PRESENT( Lambda ) ) Lambda = 1.0_dp
    
    !--------------------------------------------------------------------
    ! This is a recursive algorithm that checks the intersections 
    ! of line segments and points until correct element is found.
    ! This is optimal when the stepsize is small and there are many steps.
    !--------------------------------------------------------------------
    DoInit = Init
    IF( ElementIndex == 0 ) THEN
      DoInit = .TRUE.
      ElementIndex = 1
      UseCenter = .TRUE.
    ELSE	
      UseCenter = .NOT. StopAtFace
    END IF
    
    Element => Mesh % Elements( ElementIndex ) 
    eps = 1.0d-10
    
    DO i=1,MaxTrials
      n = GetElementNOFNOdes(Element)
      CALL GetElementNodes(ElementNodes,Element)
      
      ! Use the previous element center if the true path is of no importance
      !---------------------------------------------------------------------	
      IF( UseCenter ) THEN
        Rtmp(1) = SUM( ElementNodes % x(1:n) ) / n
        Rtmp(2) = SUM( ElementNodes % y(1:n) ) / n
        Rtmp(3) = SUM( ElementNodes % z(1:n) ) / n
      ELSE
        Rtmp = Rinit
      END IF
      
      CALL SegmentElementIntersection(Mesh,Element,&
          Rtmp,Rfin,MinLambda,FaceElement )
      
      IF( .NOT. ASSOCIATED( FaceElement ) ) THEN
        ! The likely cause for unsuccessful operation is that the 
        ! initial node and target node are the same
        IF( SUM ( ( Rtmp - Rfin )**2 ) < eps**2 ) THEN
          ParticleStatus = PARTICLE_HIT
          EXIT
        ELSE
          CALL Warn('LocateParticleInMesh','No intersection found?')
          PRINT *,'Rtmp',Rtmp
          PRINT *,'Rfin',Rfin
          EXIT
        END IF
      ELSE IF( MinLambda > 1.0 - eps ) THEN
        ParticleStatus = PARTICLE_HIT
        Rtmp = Rfin
        EXIT
      ELSE 
        LeftElement  => FaceElement % BoundaryInfo % Left
        RightElement => FaceElement % BoundaryInfo % Right
        
        IF( ASSOCIATED( LeftElement) .AND. ASSOCIATED(RightElement)) THEN
          IF( ASSOCIATED(Element, LeftElement)) THEN
            NextElement => RightElement
          ELSE
            NextElement => LeftElement
          END IF
          
          IF( StopAtFace .AND. .NOT. DoInit ) ParticleStatus = PARTICLE_FACEBOUNDARY
        ELSE
          ParticleStatus = PARTICLE_WALLBOUNDARY
        END IF
        
        ! There are different reasons why the particle is only integrated until the face
        IF( ParticleStatus == PARTICLE_WALLBOUNDARY .OR. &
            ParticleStatus == PARTICLE_FACEBOUNDARY ) THEN
          IF( PRESENT( Lambda ) ) Lambda = MinLambda
          Rtmp = Rinit + MinLambda * (Rfin - Rinit) 
          StopFaceIndex = FaceElement % ElementIndex
          EXIT                      
        END IF
      END IF
      
      ! continue the search to new elements
      Element => NextElement
    END DO
    ElementIndex = Element % ElementIndex
    
  END SUBROUTINE LocateParticleInMeshMarch



  !------------------------------------------------------------------------
  ! Locate all the new elements of the particles
  !-------------------------------------------------------------------------
  SUBROUTINE LocateParticles( Particles, PartitionChangesOnly )
    
    USE Lists
    
    TYPE(Particle_t) :: Particles
    LOGICAL, OPTIONAL :: PartitionChangesOnly
    
    INTEGER :: Status, ElementIndex, No, NoParticles, dim
    REAL(KIND=dp) :: Rinit(3), Rfin(3)
    LOGICAL :: InitLocation, Visited=.FALSE.
    INTEGER :: FaceIndex
    REAL(KIND=dp) :: Lambda
    TYPE(Mesh_t), POINTER :: Mesh
    
    
    NoParticles = Particles % NumberOfParticles
    dim = Particles % dim
    
    
    DO No = 1, NoParticles
      
      Status = Particles % Status( No )
      
      IF( Status >= PARTICLE_LOST ) CYCLE
      IF( Status < PARTICLE_INITIATED ) CYCLE
      
      IF ( PRESENT(PartitionChangesOnly) ) THEN
        IF ( PartitionChangesOnly .AND. Status /= PARTICLE_PARTBOUNDARY ) CYCLE
      END IF
      
      ElementIndex = Particles % ElementIndex( No )
      
      ! We only need to find the right element, path is not of importance
      InitLocation = ( Status < PARTICLE_LOCATED ) 
      Rfin(1:dim) = GetParticleCoord( Particles, No, 0 )
      ElementIndex = GetParticleElement( Particles, No )
      
      ! Note that if we want proper collisions with the boundary done within this
      ! routine the initial coordinates should really not be rfin!!
      !---------------------------------------------------------------------------
      CALL LocateParticleInMeshMarch(ElementIndex, Rfin, Rfin, InitLocation, &
          Status, FaceIndex, Lambda )
      
      Particles % FaceIndex(No) = FaceIndex
      Particles % Status(No) = Status
      Particles % ElementIndex(No) = ElementIndex
    END DO
    
  END SUBROUTINE LocateParticles
  
  
  
  !--------------------------------------------------------------------------
  ! Given the element & global coordinates returns the local coordinates.
  ! The idea of this routine is to transparently block the local coordinate
  ! search from the user by directly giving the basis function values related
  ! to a global coordinate.
  !--------------------------------------------------------------------------
  FUNCTION ParticleElementInfo( CurrentElement, GlobalCoord, &
      SqrtElementMetric, Basis, dBasisdx ) RESULT ( stat )
    
    TYPE(Element_t), POINTER :: CurrentElement
    REAL(KIND=dp) :: GlobalCoord(:), SqrtElementMetric
    REAL(KIND=dp) :: Basis(:)
    REAL(KIND=dp), OPTIONAL :: dBasisdx(:,:)
    LOGICAL :: Stat
    
    TYPE(Nodes_t) :: ElementNodes
    REAL(KIND=dp) :: LocalCoord(3),u,v,w
    INTEGER :: n
    
    SAVE ElementNodes
    
    n = CurrentElement % TYPE % NumberOfNodes
    CALL GetElementNodes(ElementNodes,CurrentElement)
    
    Stat = PointInElement( CurrentElement, ElementNodes, &
        GlobalCoord, LocalCoord ) 
    IF( .NOT. Stat ) THEN
      CALL Warn('GlobalElementInfo','Should have found the node!')
      PRINT *,'GlobalCoord:',GlobalCoord
      RETURN
    END IF
    
    u = LocalCoord(1)
    v = LocalCoord(2)
    w = LocalCoord(3)
    
    stat = ElementInfo( CurrentElement, ElementNodes, U, V, W, SqrtElementMetric, &
        Basis, dBasisdx )
    
  END FUNCTION ParticleElementInfo
  


  !-------------------------------------------------------------------------
  ! The routine returns velocity and optionally a gradient of velocity.
  ! These kind of functions are needed repeated and therefore to reduced the 
  ! size of individual solvers it has been hard coded here. 
  !--------------------------------------------------------------------------
  
  SUBROUTINE GetVectorFieldInMesh(Var, CurrentElement, Basis, Velo, dBasisdx, GradVelo )
    
    TYPE(Variable_t), POINTER :: Var
    TYPE(Element_t) :: CurrentElement
    REAL(KIND=dp) :: Basis(:), Velo(:) 
    REAL(KIND=dp), OPTIONAL :: dBasisdx(:,:), GradVelo(:,:)
    
    INTEGER, POINTER :: LocalPerm(:)
    REAL(KIND=dp), POINTER :: LocalVelo(:,:)
    INTEGER, POINTER :: NodeIndexes(:)
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER :: VeloFieldDofs
    REAL(KIND=dp) :: SumBasis
    INTEGER :: i,j,k,n,npos,ind,dim
    LOGICAL :: GotIt
    LOGICAL :: Visited
    
    
    SAVE :: Visited, Dim, LocalVelo, LocalPerm
    
    IF(.NOT. Visited ) THEN
      Mesh => GetMesh()
      n = Mesh % MaxElementNodes
      ALLOCATE( LocalPerm(n), LocalVelo(n,3) )
      LocalPerm = 0
      LocalVelo = 0.0_dp
      Dim = Mesh % MeshDim
      Visited = .TRUE.
    END IF
    
    Velo = 0.0_dp
    IF( PRESENT( GradVelo ) ) GradVelo = 0.0_dp
    
    n = CurrentElement % TYPE % NumberOfNodes
    LocalPerm(1:n) = Var % Perm( CurrentElement % NodeIndexes )
    npos = COUNT ( LocalPerm(1:n) > 0 )
    
    
    IF( npos == 0 ) RETURN
    
    !-----------------------------------------------------------------
    ! compute the velocity also for case when the particle
    ! has just crossed the boundary. For example, its floating on the 
    ! fluid boundary. This is a little bit fishy and could perhaps 
    ! only be done conditionally....
    ! Can't really determine the gradient here
    !-----------------------------------------------------------------
    VeloFieldDofs = Var % Dofs
    IF( npos == n ) THEN
      DO i=1,n
        j = LocalPerm(i)
        LocalVelo(i,1:dim) = Var % Values( VeloFieldDofs*(j-1)+1:dim)
      END DO
    ELSE    
      SumBasis = 0.0_dp
      DO i=1,n
        j = LocalPerm(i)
        IF( j > 0 ) THEN
          SumBasis = SumBasis + Basis(i)
          LocalVelo(i,1:dim) = Var % Values( VeloFieldDofs*(j-1)+1:dim)
        ELSE
          LocalVelo(i,1:dim) = 0.0_dp
        END IF
      END DO
    END IF
    
    DO i=1,dim
      Velo(i) = SUM( Basis(1:n) * LocalVelo(1:n,i) )
      IF( PRESENT( GradVelo ) ) THEN
        DO j=1,dim
          GradVelo(i,j) = SUM( dBasisdx(1:n,j) * LocalVelo(1:n,i) )
        END DO
      END IF
    END DO
    
    IF( npos < n ) THEN
      Velo = Velo / SumBasis
      GradVelo = GradVelo / SumBasis
    END IF
    
  END SUBROUTINE GetVectorFieldInMesh


  !-------------------------------------------------------------------------
  ! The routine returns a potential and its gradient.
  !--------------------------------------------------------------------------
  
  SUBROUTINE GetScalarFieldInMesh(Var, CurrentElement, Basis, Pot, dBasisdx, GradPot )
    
    TYPE(Variable_t), POINTER :: Var
    TYPE(Element_t) :: CurrentElement
    REAL(KIND=dp) :: Basis(:), Pot 
    REAL(KIND=dp), OPTIONAL :: dBasisdx(:,:), GradPot(:)
    
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER, POINTER :: LocalPerm(:)
    REAL(KIND=dp), POINTER :: LocalField(:)
    INTEGER :: i,j,n,dim
    LOGICAL :: Visited
    
    
    SAVE :: Visited, Mesh, Dim, LocalPerm, LocalField
    
    IF(.NOT. Visited ) THEN
      Mesh => GetMesh()
      n = Mesh % MaxElementNodes
      ALLOCATE( LocalPerm(n), LocalField(n) )
      LocalPerm = 0
      LocalField = 0.0_dp
      Dim = Mesh % MeshDim
      Visited = .TRUE.
    END IF
     
    Pot = 0.0_dp
    IF( PRESENT( GradPot ) ) GradPot = 0.0_dp
    
    IF(.NOT. ASSOCIATED( Var ) ) RETURN
    
    n = CurrentElement % TYPE % NumberOfNodes
    LocalPerm(1:n) = Var % Perm( CurrentElement % NodeIndexes )
    
    IF( .NOT. ALL ( LocalPerm(1:n) > 0 )) RETURN
    
    LocalField(1:n) = Var % Values( LocalPerm(1:n) )
    Pot = SUM( Basis(1:n) * LocalField(1:n) )
    
    IF( PRESENT( GradPot ) ) THEN
      DO i=1,dim
        GradPot(i) = SUM( dBasisdx(1:n,i) * LocalField(1:n) )
      END DO
    END IF
    
  END SUBROUTINE GetScalarFieldInMesh


  
  !-------------------------------------------------------------------------
  ! The routine returns the possible intersection of a secondary element 
  ! with a different material property and the circle / sphere.
  ! For example, the buoyancy at the interface will depend on the weighted
  ! sum of the densities of the two materials. 
  !--------------------------------------------------------------------------
  
  FUNCTION GetParticleElementIntersection(Particles,BulkElement, Basis, Coord, &
      Radius, BulkElement2, VolumeFraction, AreaFraction ) RESULT ( Intersect )
    
    TYPE(Particle_t) :: Particles
    TYPE(Element_t), POINTER :: BulkElement, BulkElement2
    REAL(KIND=dp) :: Basis(:)
    REAL(KIND=dp) :: Coord(3), Radius, VolumeFraction
    REAL(KIND=dp), OPTIONAL :: AreaFraction
    LOGICAL :: Intersect
    
    INTEGER, POINTER :: NodeIndexes(:)
    TYPE(Mesh_t), POINTER :: Mesh
    REAL(KIND=dp) :: Dist, Normal(3), SumBasis
    TYPE(ValueList_t), POINTER :: Material, Material2, BC
    TYPE(Element_t), POINTER :: BoundaryElement, Left, Right
    TYPE(Nodes_t) :: BoundaryNodes
    INTEGER :: i,j,k,n,imax,body_id,body_id2,mat_id,mat_id2,dim,ind
    LOGICAL :: Visited
    
    
    SAVE :: Visited, Mesh, Dim
    
    IF(.NOT. Visited ) THEN
      Mesh => GetMesh()
      Dim = Mesh % MeshDim
      Visited = .TRUE.    
    END IF
    
    Intersect = .FALSE.
    VolumeFraction = 0.0_dp
    
    ! This element has no boundary / material interface
    IF( Particles % InternalElements( BulkElement % ElementIndex ) ) RETURN
    
    ! If the radius of the particle is zero then it sees only the properties of one point
    IF( Radius < TINY( Radius ) ) RETURN
    
    n = BulkElement % TYPE % NumberOfNodes
    body_id = BulkElement % BodyId
    mat_id = ListGetInteger( CurrentModel % Bodies(body_id) % Values,'Material' )
    
    IF( dim == 3 ) THEN
      imax = BulkElement % TYPE % NumberOfFaces 
    ELSE
      imax = BulkElement % TYPE % NumberOfEdges  
    END IF
    
    DO i=1, imax
      
      IF( dim == 3 ) THEN
        j = BulkElement % FaceIndexes(i)
        BoundaryElement => Mesh % Faces( j )
      ELSE
        j = BulkElement % EdgeIndexes(i)
        BoundaryElement => Mesh % Edges(j)
      END IF
      
      IF( .NOT. ASSOCIATED( BoundaryElement % BoundaryInfo ) ) CYCLE
      
      Left => BoundaryElement % BoundaryInfo % Left
      Right => BoundaryElement % BoundaryInfo % Right
      
      IF(.NOT. (ASSOCIATED( Left ) .AND. ASSOCIATED( Right ) ) ) CYCLE
      
      IF( ASSOCIATED( BulkElement, Right ) ) THEN
        BulkElement2 => Left
      ELSE 
        BulkElement2 => Right 
      END IF
      
      IF( .NOT. ASSOCIATED( BulkElement2 ) ) CYCLE
      
      body_id2 = BulkElement2 % BodyId
      
      IF( body_id2 > CurrentModel % NumberOfBodies ) THEN
        PRINT *,'BodyIds:',body_id,body_id2,CurrentModel % NumberOfBodies
        PRINT *,'ElemIds:',BulkElement % ElementIndex, BulkElement2 % ElementIndex
        PRINT *,'Types:',BulkElement % TYPE % NumberOfNodes, &
            BulkElement2 % TYPE % NumberOfNodes
        body_id2 = 0
      END IF
      
      IF( body_id2 == 0 ) CYCLE
      
      mat_id2 = ListGetInteger( CurrentModel % Bodies(body_id2) % Values,'Material' )
      
      ! If the materials are the same the density is ok
      IF( mat_id2 == mat_id ) CYCLE          

      ! If there is an material interface, check for distance
      CALL GetElementNodes(BoundaryNodes,BoundaryElement)
      Dist = PointFaceDistance(BoundaryElement,BoundaryNodes,Coord,Normal)
      Dist = ABS( Dist )       
      
      ! Is is assumed that each element may only have one density interface
      IF( Dist > Radius ) RETURN
      
      IF( dim == 3 ) THEN
        ! based on the formula of sphere-sphere intersection as in Wolfram MathWorld
        VolumeFraction = (Radius + Dist / 2 ) * (Radius - Dist)**2 / Radius**3
        IF( PRESENT( AreaFraction ) ) THEN
          AreaFraction = ( 1.0_dp - Dist/Radius )/2.0_dp
        END IF
      ELSE
        ! based on the formula of circle-circle intersection as in Wolfram MathWorld
        VolumeFraction = ( ( Radius ** 2) * ACOS( Dist / Radius ) &
            - Dist * SQRT( Radius ** 2 - Dist ** 2 ) ) / (PI * Radius**2) 
        IF( PRESENT( AreaFraction ) ) THEN
          AreaFraction = ACOS( Dist / Radius ) / PI
        END IF
      END IF
      
      !     PRINT *,'VolumeFraction:',VolumeFraction, Density
      RETURN
    END DO
    
  END FUNCTION GetParticleElementIntersection


  !-------------------------------------------------------------
  ! This subroutine may be used to enquire position dependent material data.
  ! Also if the particle is splitted between two elements then this 
  ! routine can assess the data on the secondary mesh.
  !-------------------------------------------------------------
  FUNCTION GetMaterialPropertyInMesh(PropertyName, BulkElement, Basis, &
      BulkElement2, VolumeFraction ) RESULT ( Property )
    
    CHARACTER(LEN=MAX_NAME_LEN) :: PropertyName
    TYPE(Element_t), POINTER :: BulkElement
    REAL(KIND=dp) :: Basis(:)
    TYPE(Element_t), POINTER, OPTIONAL :: BulkElement2
    REAL(KIND=dp), OPTIONAL :: VolumeFraction
    REAL(KIND=dp) :: Property
    
    INTEGER, POINTER :: NodeIndexes(:)
    TYPE(Mesh_t), POINTER :: Mesh
    REAL(KIND=dp), POINTER :: ElemProperty(:)
    REAL(KIND=dp) :: Property2
    TYPE(ValueList_t), POINTER :: Material, Material2
    INTEGER :: i,j,k,n,mat_id,mat_id2
    LOGICAL :: Visited
    
    
    SAVE :: Visited, Mesh, ElemProperty
    
    IF(.NOT. Visited ) THEN
      Mesh => GetMesh()
      n = Mesh % MaxElementNodes
      ALLOCATE( ElemProperty( n ) )
      ElemProperty = 0.0_dp
      Visited = .TRUE.    
    END IF
    
    NodeIndexes => BulkElement % NodeIndexes
    n = BulkElement % TYPE % NumberOfNodes
    mat_id = ListGetInteger( CurrentModel % Bodies(BulkElement % BodyId) % Values,'Material' )
    Material => CurrentModel % Materials(mat_id) % Values
    
    ElemProperty(1:n) = ListGetReal( Material,PropertyName,n,NodeIndexes) 
    Property = SUM( Basis(1:n) * ElemProperty(1:n) )
    
    IF( .NOT. PRESENT ( VolumeFraction ) ) RETURN
    IF( .NOT. PRESENT ( BulkElement2 ) ) RETURN
    IF( VolumeFraction < TINY( VolumeFraction) ) RETURN
    
    IF( ASSOCIATED( BulkElement2 ) ) THEN
      mat_id2 = ListGetInteger( CurrentModel % Bodies(BulkElement2 % BodyId) % Values,'Material' )
    ELSE
      mat_id2 = 0
    END IF
    
    ! If the materials are the same the density is ok
    IF( mat_id2 == mat_id ) RETURN
    
    ! If there is an material interface, check for distance
    IF( mat_id2 == 0 ) THEN
      Property2 = 0.0_dp
    ELSE
      NodeIndexes => BulkElement2 % NodeIndexes
      n = BulkElement2 % TYPE % NumberOfNodes
      Material2 => CurrentModel % Materials(mat_id2) % Values
      
      ElemProperty(1:n) = ListGetReal( Material,PropertyName,n,NodeIndexes) 
      
      ! One cannot use the basis functions of the primary element. 
      ! and this is valid for cases with constant material parameters.
      !------------------------------------------------------------------
      Property2 = SUM( ElemProperty(1:n) ) / n
    END IF
    
    Property = VolumeFraction * Property2 + (1-VolumeFraction) * Property
    !     PRINT *,'VolumeFraction:',VolumeFraction, Property
    RETURN
    
  END FUNCTION GetMaterialPropertyInMesh


  !-------------------------------------------------------------
  ! This routine cretates the nearest neighbours for all nodes
  ! The particle-particle connections may then be found by going
  ! through all the nodes of elements
  !-------------------------------------------------------------
  SUBROUTINE CreateNeighbourList( Particles ) 
    
    TYPE(Particle_t) :: Particles
    
    INTEGER :: ElementIndex, dim
    REAL(KIND=dp) :: Coord(3), dist, mindist
    TYPE(ValueList_t), POINTER :: Params
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER :: i,j,k,n,node
    TYPE(Nodes_t), SAVE :: ElementNodes
    INTEGER, POINTER :: NodeIndexes(:)
    TYPE(Element_t), POINTER :: Element
    INTEGER :: NoNodes, NoParticles, MaxClosest  
    
    Mesh => GetMesh()
    NoNodes = Mesh % NumberOfNodes
    NoParticles = Particles % NumberOfParticles
    dim = Particles % dim 
    
    IF( .NOT. Particles % NeighbourTable ) THEN
      PRINT *,'allocate'
      ALLOCATE( Particles % NoClosestParticle( NoNodes ) ) 
      ALLOCATE( Particles % CumClosestParticle( NoNodes+1 ) ) 
      ALLOCATE( Particles % ClosestNode(NoParticles) )
      Particles % NeighbourTable = .TRUE.
    END IF
    
    IF( SIZE( Particles % ClosestNode ) < NoParticles ) THEN
      PRINT *,'sizes:',NoParticles,SIZE(Particles % ClosestNode ) 
      CALL Fatal('CreateNeighbourList','ClosestNode vector of wrong size')
    END IF
    
    ! First find the closest node to each particle
    !-----------------------------------------------
    Particles % ClosestNode = 0
    Particles % NoClosestParticle = 0
    DO i=1,NoParticles 
      IF( Particles % Status(i) >= PARTICLE_LOST ) CYCLE
      IF( Particles % Status(i) < PARTICLE_INITIATED ) CYCLE
      
      ElementIndex = Particles % ElementIndex(i)
      Element => Mesh % Elements( ElementIndex )
      n = GetElementNOFNodes(Element)
      CALL GetElementNodes(ElementNodes,Element)    
      Coord(1:dim) = Particles % Coordinate(i,1:dim)
      
      ! Find the minimum distance node (using squares is faster)
      mindist = HUGE( mindist ) 
      DO j=1,n
        dist = ( ElementNodes % x(j) - Coord(1) )**2
        dist = dist +  ( ElementNodes % y(j) - Coord(2) )**2
        IF( dim == 3 ) THEN
          dist = dist +  ( ElementNodes % z(j) - Coord(3) )**2
        END IF
        IF( dist < mindist ) THEN
          mindist = dist 
          k = j
        END IF
      END DO
      node = Element % NodeIndexes(k)
      Particles % ClosestNode(i) = node
      Particles % NoClosestParticle(node) = Particles % NoClosestParticle(node) + 1
    END DO
    
    CALL ExchangeNeighbourParticles(Particles)
    NoParticles = Particles % NumberOfParticles
    
    ! Count the cumulative number of closest particles for given node
    !-----------------------------------------------------------------
    Particles % CumClosestParticle(1) = 1
    MaxClosest = 0
    DO i=1,NoNodes
      j = Particles % NoClosestParticle(i)
      MaxClosest = MAX( MaxClosest, j )
      Particles % CumClosestParticle(i+1) = Particles % CumClosestParticle(i)+j
    END DO
    Particles % MaxClosestParticles = MaxClosest
    
    ! And finally, add the closest neigbours to the table 
    !----------------------------------------------------------------
    IF ( ASSOCIATED(Particles % ClosestParticle) ) &
        DEALLOCATE(Particles % ClosestParticle )
    ALLOCATE( Particles % ClosestParticle(Particles % CumClosestParticle(NoNodes+1)) )
    
    Particles % NoClosestParticle = 0
    Particles % ClosestParticle = 0
    DO i=1,NoParticles     
      IF ( Particles % Status(i) == PARTICLE_LOST ) CYCLE
      IF ( Particles % Status(i) < PARTICLE_INITIATED ) CYCLE
      node = Particles % ClosestNode(i) 
      j = Particles % NoClosestParticle(node) 
      k = Particles % CumClosestParticle(node)
      Particles % ClosestParticle(k+j) = i
      Particles % NoClosestParticle(node) = j + 1
    END DO
    
  END SUBROUTINE CreateNeighbourList
  

  SUBROUTINE ExchangeNeighbourParticles(Particles)
    TYPE(Particle_t) :: Particles
    !---------------------------------------------------------
    INTEGER i,j,k,l,m,n,dim,NoPartitions, node, &
        Proc, ierr, status(MPI_STATUS_SIZE), n_part, nReceived
    
    INTEGER, ALLOCATABLE :: Perm(:), Indexes(:), Neigh(:), &
        Recv_parts(:), Requests(:)
    TYPE(Mesh_t), POINTER :: Mesh
    
    TYPE(ParallelInfo_t), POINTER :: PI
    
    LOGICAL, ALLOCATABLE :: IsNeighbour(:)
    INTEGER, POINTER :: Neighbours(:), Closest(:)
    
    TYPE ExchgInfo_t
      INTEGER :: n=0
      INTEGER, POINTER :: Gindex(:), Particles(:)
    END TYPE ExchgInfo_t
    
    REAL(KIND=dp), ALLOCATABLE :: Buf(:)
    TYPE(ExchgInfo_t), POINTER :: Info(:)
    !--------------------------------------------------------
    
    nReceived = 0
    IF( ParEnv% PEs == 1 ) RETURN
    
    Mesh => GetMesh()
    dim = Particles % dim
    
    ! Count & Identify neighbouring partitions:
    ! -----------------------------------------
    ALLOCATE(IsNeighbour(ParEnv % PEs))
    NoPartitions = MeshNeighbours(Mesh,IsNeighbour)
    ALLOCATE(Perm(ParEnv % PEs), Neigh(NoPartitions) )
    Perm = 0
    
    NoPartitions=0
    DO i=1,ParEnv % PEs
      IF ( i-1==ParEnv % Mype ) CYCLE
      IF ( IsNeighbour(i) ) THEN
        NoPartitions=NoPartitions+1
        Perm(i) = NoPartitions
        Neigh(NoPartitions) = i-1
      END IF
    END DO
    DEALLOCATE(IsNeighbour)
    
    ! Receive interface sizes:
    !--------------------------
    ALLOCATE( Recv_Parts(NoPartitions), Requests(NoPartitions) )
    DO i=1,NoPartitions
      CALL MPI_iRECV( Recv_Parts(i),1, MPI_INTEGER, Neigh(i), &
          2000, MPI_COMM_WORLD, requests(i), ierr )
    END DO
    
    PI => Mesh % ParallelInfo
    
    ! Exchange interface particles
    ! ----------------------------
    ALLOCATE(Info(NoPartitions))
    DO i=1,NoPartitions
      Info(i) % n = 0
    END DO
    
    DO i=1,Particles % NumberOfParticles
      IF ( Particles % Status(i) == PARTICLE_LOST ) CYCLE
      
      node = Particles % ClosestNode(i)
      IF ( .NOT. PI % INTERFACE(node) ) CYCLE
      Neighbours => PI % NeighbourList(node) % Neighbours
      DO j=1,SIZE(Neighbours)
        proc = Neighbours(j)
        IF ( Proc==Parenv % mype ) CYCLE
        proc = Perm(proc+1)
        IF ( Proc<=0 ) CYCLE
        Info(proc) % n = Info(proc) % n+1
      END DO
    END DO
    
    DO i=1,NoPartitions
      CALL MPI_BSEND( Info(i) % n, 1, MPI_INTEGER, Neigh(i), &
          2000, MPI_COMM_WORLD, ierr )
    END DO
    
    !
    ! Collect particles to be sent to neighbours:
    ! -------------------------------------------
    DO i=1,NoPartitions
      IF ( Info(i) % n==0 ) CYCLE
      ALLOCATE( Info(i) % Gindex(Info(i) % n), Info(i) % Particles(Info(i) % n) )
      Info(i) % n = 0
    END DO
    
    DO i=1,Particles % NumberOfParticles
      IF ( Particles % Status(i) == PARTICLE_LOST ) CYCLE
      
      node = Particles % ClosestNode(i)
      IF ( .NOT. PI % INTERFACE(node) ) CYCLE
      Neighbours => PI % NeighbourList(node) % Neighbours
      DO j=1,SIZE(Neighbours)
        proc = Neighbours(j)
        IF ( Proc==Parenv % mype ) CYCLE
        proc = Perm(proc+1)
        IF ( Proc<=0 ) CYCLE
        Info(proc) % n = Info(proc) % n+1
        Info(proc) % Particles(Info(proc) % n) = i
        Info(proc) % Gindex(Info(proc) % n) = PI % GlobalDOFs(node)
      END DO
    END DO
    
    n = 0
    DO i=1,NoPartitions
      n = n + Info(i) % n
    END DO
    n = 2*(n+2*(2*n*dim+n) + MPI_BSEND_OVERHEAD*2*NoPartitions)
    CALL CheckBuffer(n)
    
    ! Send particles:
    ! ---------------
    DO j=1,NoPartitions
      n = Info(j) % n
      IF ( n<=0 ) CYCLE
      
      CALL MPI_BSEND( Info(j) % Gindex, n, MPI_INTEGER, &
          Neigh(j), 2001, MPI_COMM_WORLD, ierr )
      
      ALLOCATE(Buf(2*n*dim+n))
      m = 0
      DO k=1,dim
        DO l=1,n
          m = m + 1
          Buf(m) = Particles % Coordinate(Info(j) % Particles(l),k)
        END DO
      END DO
      DO l=1,n
        m = m + 1
        Buf(m) = Particles % Dt(Info(j) % Particles(l))
      END DO
      IF ( ASSOCIATED(Particles % Velocity) ) THEN
        DO k=1,dim
          DO l=1,n
            m = m + 1
            Buf(m) = Particles % Velocity(Info(j) % Particles(l),k)
          END DO
        END DO
      END IF
      CALL MPI_BSEND( Buf, m, MPI_DOUBLE_PRECISION, &
          Neigh(j), 2002, MPI_COMM_WORLD, ierr )
      DEALLOCATE(Buf)
    END DO
    
    CALL MPI_WaitAll( NoPartitions, Requests, MPI_STATUSES_IGNORE, ierr )
    n = SUM(Recv_Parts)
    IF ( Particles % NumberOfParticles+n > Particles % MaxNumberOfParticles ) THEN
      CALL IncreaseParticles( Particles, Particles % NumberOfParticles+2*n - &
          Particles % MaxNumberOfParticles )
    END IF
    
    
    ! Recv particles:
    ! ---------------
    DO i=1,NoPartitions
      n = Recv_Parts(i)
      IF ( n<=0 ) CYCLE
      
      proc = Neigh(i)
      
      ALLOCATE(Indexes(n))
      CALL MPI_RECV( Indexes, n, MPI_DOUBLE_PRECISION, proc, &
          2001, MPI_COMM_WORLD, status, ierr )
      
      n_part=Particles % NumberOfParticles
      DO j=1,n
        n_part = n_part+1
        Particles % Status(n_part) = PARTICLE_GHOST
        node = SearchNode(PI,Indexes(j))
        IF ( node<=0 ) STOP 'a'
        Particles % ClosestNode(n_part) = node
        Particles % NoClosestParticle(node) = &
            Particles % NoClosestParticle(node) + 1
      END DO
      DEALLOCATE(Indexes)
      
      m = n+n*dim
      IF ( ASSOCIATED(Particles % Velocity) ) m=m+n*dim
      
      ALLOCATE(Buf(m))
      CALL MPI_RECV( Buf, m, MPI_DOUBLE_PRECISION, proc, &
          2002, MPI_COMM_WORLD, status, ierr )
      
      n_part=Particles % NumberOfParticles
      m = 0
      DO k=1,dim
        DO l=1,n
          m = m + 1
          Particles % Coordinate(n_part+l,k)=Buf(m)
        END DO
      END DO
      
      DO l=1,n
        m = m + 1
        Particles % Dt(n_part+l) = Buf(m)
      END DO
      
      IF ( ASSOCIATED(Particles % Velocity) ) THEN
        DO k=1,dim
          DO l=1,n
            m = m + 1
            Particles % Velocity(n_part+l,k)=Buf(m)
          END DO
        END DO
      END IF
      DEALLOCATE(Buf)
      Particles % NumberOfParticles = Particles % NumberOfParticles+n
    END DO
    
    DEALLOCATE(Perm)
    DO i=1,NoPartitions
      IF ( Info(i) % n==0 ) CYCLE
      DEALLOCATE( Info(i) % Gindex, Info(i) % Particles )
    END DO
    DEALLOCATE(Info, Recv_Parts, Neigh, Requests)
    
  END SUBROUTINE ExchangeNeighbourParticles
  !------------------------------------------------------------





  !------------------------------------------------------------
  ! For the first call of given node do the list, thereafter 
  ! Return the index until the list is finished
  !------------------------------------------------------------
  FUNCTION GetNextNeighbour( Particles, No ) RESULT ( No2 )
    IMPLICIT NONE
    
    TYPE(Particle_t) :: Particles
    INTEGER :: No, No2
    
    INTEGER :: PrevNo = 0
    INTEGER, POINTER :: NodeIndexes(:), NeighbourList(:) => NULL(), TmpList(:) => NULL()
    INTEGER :: i,j,k,n,ListSize,NoNeighbours,ElementIndex,Cnt
    LOGICAL :: Visited = .FALSE.
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Element_t), POINTER :: Element
    
    SAVE Visited,PrevNo,NeighbourList,ListSize,NoNeighbours,Cnt
    
    IF( PrevNo /= No ) THEN
      PrevNo = No
      IF( .NOT. Visited ) THEN
        Visited = .TRUE.
        Mesh => GetMesh()
        n = Mesh % MaxElementNodes 
        ListSize = n * Particles % MaxClosestParticles + 10
        ALLOCATE( NeighbourList( ListSize ) )
        NeighbourList = 0 
        Mesh => GetMesh()
      END IF
      
      Mesh => GetMesh()
      ElementIndex = Particles % ElementIndex(No)
      Element => Mesh % Elements( ElementIndex )
      n = GetElementNOFNodes(Element)
      NodeIndexes => Element % NodeIndexes
      
      NoNeighbours = 0
      DO i=1,n
        j = NodeIndexes(i)
        
        DO k=Particles % CumClosestParticle(j),Particles % CumClosestParticle(j+1)-1 
          No2 = Particles % ClosestParticle(k)
          
          ! No self coupling in this list	
          IF( No2 == No ) CYCLE
          
          ! Set symmetric forces Fij=-Fij so no need to go through twice
          IF ( No2 < No ) CYCLE
          
          NoNeighbours = NoNeighbours + 1
          
          IF( NoNeighbours > ListSize ) THEN
            ALLOCATE( TmpList( ListSize + 20 ) )
            TmpList(1:ListSize) = NeighbourList
            DEALLOCATE( NeighbourList ) 
            NeighbourList => TmpList
            ListSize = ListSize + 20
            NULLIFY( TmpList ) 
            WRITE(Message,'(A,I6)') 'Allocating more space:',ListSize
            CALL Info('GetNextNeighbour',Message)
          END IF
          
          NeighbourList(NoNeighbours) = No2
        END DO
      END DO
      Cnt = 0
    END IF
    
    Cnt = Cnt + 1
    IF( Cnt > NoNeighbours ) THEN
      No2 = 0
    ELSE
      No2 = NeighbourList( Cnt ) 
    END IF
    
  END FUNCTION GetNextNeighbour
  
  

  !---------------------------------------------------------
  ! Initialize the time for next time integration step
  !---------------------------------------------------------
  SUBROUTINE ParticleInitializeTime( Particles, No )
    TYPE(Particle_t) :: Particles
    INTEGER, OPTIONAL :: No
    
    IF( PRESENT( No ) ) THEN
      Particles % Force( No, : ) = 0.0_dp
    ELSE
      Particles % Force = 0.0_dp
    END IF
    
  END SUBROUTINE ParticleInitializeTime
  

  !---------------------------------------------------------
  ! Take a time step
  !---------------------------------------------------------
  SUBROUTINE ParticleAdvanceTime( Particles, dtime, ind )
    TYPE(Particle_t) :: Particles
    REAL(KIND=dp) :: dtime
    INTEGER, OPTIONAL :: ind
    
    REAL(KIND=dp) :: Drag, Mass, ds, dCoord(3)
    INTEGER :: dim
    INTEGER :: Status, TimeOrder, No
    TYPE(ValueList_t), POINTER :: Params
    INTEGER :: NoStart, NoFin
    LOGICAL :: Found, Visited = .FALSE.
    
    SAVE TimeOrder, dim, Mass, Drag, Visited
    
    
    IF(.NOT. Visited ) THEN
      Params => GetSolverParams()
      TimeOrder = Particles % TimeOrder
      dim = Particles % dim
      
      IF( TimeOrder == 2 ) THEN
        Mass = ListGetConstReal( Params,'Particle Mass',Found)
        IF(.NOT. Found) CALL Fatal('ParticleAdvanceTime',&
            '> Particle Mass < should be given!')
      ELSE 
        Drag = ListGetConstReal( Params,'Particle Drag Coefficient',Found)
        IF(.NOT. Found) CALL Fatal('ParticleAdvanceTime',&
            '> Particle Drag Coefficient < should be given!')
      END IF
      
      dCoord = 0.0_dp
      Visited = .TRUE.
    END IF
    


    IF( PRESENT( ind ) ) THEN
      NoStart = ind
      NoFin = ind
    ELSE
      NoStart = 1
      NoFin = Particles % NumberOfParticles

      IF(.TRUE.) THEN
        CALL DeleteLostParticles(Particles)
      END IF
    END IF


    
    DO No=NoStart,NoFin
      Status = Particles % Status(No)
      
      IF ( Status >= PARTICLE_LOST ) CYCLE
      IF ( Status <= PARTICLE_INITIATED ) CYCLE
 
! This is just for debugging so commented away for the moment 
!      IF( ANY( ISNAN( Particles % Force(No,:) ) ) ) THEN
!        PRINT *,'dCoord',dCoord(1:dim),dtime
!        PRINT *,'velo',Particles % Velocity(No,:)
!        PRINT *,'coord',Particles % Coordinate(No,:)
!        PRINT *,'force',Particles % Force(No,:)
!      END IF
      
      IF ( Status == PARTICLE_FIXEDCOORD ) THEN
        Particles % Velocity(No,:) = 0.0_dp
      ELSE IF( Status == PARTICLE_FIXEDVELO ) THEN
        CONTINUE
      ELSE IF( TimeOrder == 2 ) THEN
        Particles % Velocity(No,:) = Particles % Velocity(No,:) + &
            dtime * Particles % Force(No,:) / Mass
      ELSE
        Particles % Velocity(No,:) = Particles % Force(No,:) / Drag      
      END IF
      
      dCoord(1:dim) = dtime * Particles % Velocity(No,:)
      Particles % Coordinate(No,:) = Particles % Coordinate(No,:) + &
          dCoord(1:dim)
      
      ds = SQRT( SUM( (dCoord(1:dim))**2 ) )
      Particles % Distance(No) = Particles % Distance(No) + ds    
      
      Particles % Force(No,:)= 0.0_dp
      Particles % Status(No) = PARTICLE_READY
    END DO

  END SUBROUTINE ParticleAdvanceTime


  !---------------------------------------------------------------    
  ! Checks the boundaries for rectangular and hexahedral shapes and 
  ! enforces periodic BCs. Currently the only supported way
  ! for setting periodic BCs.
  !---------------------------------------------------------------    
  SUBROUTINE ParticleBoxPeriodic( Particles, ind )
    
    TYPE(Particle_t) :: Particles
    INTEGER, OPTIONAL :: ind
    
    TYPE(Solver_t), POINTER :: Solver
    REAL(KIND=dp) :: Coord, Rad
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(ValueList_t), POINTER :: Params
    REAL(KIND=dP) :: MinCoord(3), MaxCoord(3)
    INTEGER :: i,j,k,dim, ierr, PeriodicDir(3),NoPeriodic
    LOGICAL :: Mapped,Reflect,Found,Visited = .FALSE.
    INTEGER :: Operations, No, NoStart, NoFin, Status
    INTEGER, POINTER :: TmpInteger(:)
    
    SAVE Visited, Reflect, PeriodicDir, NoPeriodic, MinCoord, MaxCoord, dim
    
    IF( .NOT. Visited ) THEN
      Visited = .TRUE.
      Mesh => GetMesh()
      Params => GetSolverParams()
      dim = Mesh % Meshdim
      
      NoPeriodic = 0
      PeriodicDir = 0
      
      TmpInteger => ListGetIntegerArray( &
          Params,'Box Periodic Directions',Found )     
      IF( Found ) THEN
        NoPeriodic = SIZE( TmpInteger )
        DO i=1,NoPeriodic
          PeriodicDir(i) = TmpInteger(i)
        END DO
      ELSE IF( ListGetLogical( Params,'Box Particle Periodic',Found)) THEN
        NoPeriodic = dim
        DO i=1,dim
          PeriodicDir(i) = i
        END DO
      END IF
      
      MinCoord = Particles % GlobalMinCoord
      MaxCoord = Particles % GlobalMaxCoord
    END IF
    
    IF( NoPeriodic == 0 ) RETURN
    
    IF( PRESENT( ind ) ) THEN
      NoStart = ind
      Nofin = ind
    ELSE
      NoStart = 1
      NoFin = Particles % NumberOfParticles
    END IF
    
    
    DO No = NoStart, NoFin
      Status = Particles % Status(No) 
      IF( Status >= PARTICLE_LOST ) CYCLE
      IF( Status < PARTICLE_INITIATED ) CYCLE
      
      ! Boundary conditions for periodic BCs
      !------------------------------------------
      DO i=1,NoPeriodic
        Mapped = .FALSE.
        DO j=1,NoPeriodic
          k = PeriodicDir(j)
          coord = Particles % Coordinate(No,k)
          IF( coord < MinCoord(k) ) THEN
            coord = MaxCoord(k) - MinCoord(k) + coord
            Particles % Coordinate(No,k) = coord
            Mapped = .TRUE.
          ELSE IF ( coord > MaxCoord(k) ) THEN
            Coord = MinCoord(k) - MaxCoord(k) + Coord
            Particles % Coordinate(No,k) = coord           
            Mapped = .TRUE.
          END IF
        END DO
        IF(.NOT. Mapped ) EXIT
      END DO
    END DO
    
  END SUBROUTINE ParticleBoxPeriodic
  
  
  !---------------------------------------------------------------    
  ! Checks the boundaries for rectangular and hexahedral shapes and 
  ! enforces elastic reflection. This is alternative and 
  ! computationally more economic way and is ideal for testing
  ! purposes, at least.
  !---------------------------------------------------------------    
  SUBROUTINE ParticleBoxContact(Particles, ind)
    
    TYPE(Particle_t) :: Particles
    INTEGER, OPTIONAL :: ind
    
    TYPE(Solver_t), POINTER :: Solver
    REAL(KIND=dp) :: Coord, Velo, Rad, Spring
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(ValueList_t), POINTER :: Params
    REAL(KIND=dP) :: MinCoord(3), MaxCoord(3), eta
    INTEGER :: i,j,k,dim, ierr,ContactDir(3)
    LOGICAL :: Mapped,Found,CollisionBC,ContactBC,Visited = .FALSE.
    INTEGER :: No, NoStart, NoFin, Status, NoContact
    INTEGER, POINTER :: TmpInteger(:)
    
    SAVE Visited, NoContact, ContactDir, MinCoord, MaxCoord, dim, &
        CollisionBC, ContactBC, Spring
    
    IF( .NOT. Visited ) THEN
      Visited = .TRUE.
      Mesh => GetMesh()
      Params => GetSolverParams()
      dim = Mesh % Meshdim
      
      NoContact = 0
      ContactDir = 0
      
      ContactBC = ListGetLogical(Params,'Box Particle Contact',Found)
      CollisionBC = ListGetLogical( Params,'Box Particle Collision',Found)
      
      IF( ContactBC .OR. CollisionBC ) THEN
        TmpInteger => ListGetIntegerArray( &
            Params,'Box Contact Directions',Found )     
        IF( Found ) THEN
          NoContact = SIZE( TmpInteger )
          DO i=1,NoContact
            ContactDir(i) = TmpInteger(i)
          END DO
        ELSE
          DO i=1,dim
            ContactDir(i) = i
          END DO
          NoContact = dim
        END IF
      ELSE
        NoContact = 0
      END IF
      IF( NoContact == 0 ) RETURN
      
      MinCoord = Particles % GlobalMinCoord
      MaxCoord = Particles % GlobalMaxCoord
      
      ! Particles of finite size collide before their center 
      ! hits the wall.
      Rad = GetCReal( Params,'Wall Particle Radius',Found)    
      IF( Found ) THEN
        MaxCoord = MaxCoord - Rad
        MinCoord = MinCoord + Rad
      END IF
      
      IF( ContactBC ) THEN
        Spring = GetCReal(Params,'Wall Particle Spring',Found)
        IF(.NOT. Found) CALL Fatal('ParticleBoxContact',&
            '> Wall Particle Spring < needed!')
      END IF
      
    END IF
    
    IF( NoContact == 0) RETURN
    
    IF( PRESENT( ind ) ) THEN
      NoStart = ind
      Nofin = ind
    ELSE
      NoStart = 1
      NoFin = Particles % NumberOfParticles
    END IF
    
    DO No = NoStart, NoFin
      Status = Particles % Status(No) 
      IF( Status >= PARTICLE_LOST ) CYCLE
      IF( Status < PARTICLE_INITIATED ) CYCLE
      
      ! Boundary conditions for reflection. 
      ! Multiple reflections may be carried out.
      !------------------------------------------
      DO i=1,NoContact
        
        IF( CollisionBC ) THEN        
          Mapped = .FALSE.
          DO j=1,NoContact
            k = ContactDir(j)
            Coord = Particles % Coordinate(No,k)
            
            IF( Coord < MinCoord(k) ) THEN
              Coord = 2 * MinCoord(k) - Coord
              Particles % Coordinate(No,k) = Coord
              Particles % Velocity(No,k) = -Particles % Velocity(No,k)
              Mapped = .TRUE.
            ELSE IF ( Coord > MaxCoord(k) ) THEN
              Coord = 2 * MaxCoord(k) - Coord
              Particles % Coordinate(No,k) = Coord          
              Particles % Velocity(No,k) = -Particles % Velocity(No,k)
              Mapped = .TRUE.
            END IF
          END DO
          IF(.NOT. Mapped ) EXIT
        ELSE        
          k = ContactDir(i)
          Coord = Particles % Coordinate(No,k)
          
          IF( MinCoord(k) - Coord > 0.0_dp ) THEN
            eta = MinCoord(k) - Coord          
            Particles % Force(No,k) = Particles % Force(No,k) + eta * Spring
          ELSE IF( Coord - MaxCoord(k) > 0.0_dp ) THEN
            eta = Coord - MaxCoord(k) 
            Particles % Force(No,k) = Particles % Force(No,k) - eta * Spring
          END IF
        END IF
      END DO
      
    END DO
    
  END SUBROUTINE ParticleBoxContact



  !---------------------------------------------------------------    
  ! Subroutine for getting particle-particle interaction 
  ! The subroutine may return the new positions and new 
  ! coordinates, or alternatively the initial coordinates are tampered 
  ! so that with standard time-integration the final position will
  ! be the same.
  !---------------------------------------------------------------    
  FUNCTION ParticleParticleCollision(dt,Coord,Coord2,Velo,Velo2,&
      Force,Force2) RESULT ( Collision ) 
    
    REAL(KIND=dp):: dt,Coord(3),Coord2(3),Velo(3),Velo2(3),Force(3),Force2(3)
    LOGICAL :: Collision 
    
    REAL(KIND=dp)::  v1na,v2na,v1nb,v2nb
    REAL(KIND=dp) :: dist,maxdist=0.0_dp
    REAL(KIND=dp) :: Rad1, Rad2, Mass1, Mass2, Coeff 
    REAL(KIND=dp) :: a,b,c,d,dr(3),dv(3),dra(3),rn(3),dta,dtb
    TYPE(ValueList_t), POINTER :: Params
    LOGICAL :: Found, TrueCollision,SimilarParticles,Debug 
    LOGICAL :: Visited=.FALSE.
    
    SAVE Visited, maxdist, SimilarParticles, Rad1, Rad2, Mass1, Mass2, Coeff, &
        TrueCollision
    
    IF(.NOT. Visited ) THEN
      Params => GetSolverParams()
      Rad1 = GetCReal(Params,'Particle Radius',Found)
      IF(.NOT. Found) THEN
        CALL Fatal('ParticleParticleCollision','> Particle Radius < needed!')
      END IF
      Coeff = GetCReal(Params,'Particle Bounciness',Found)
      IF(.NOT. Found ) Coeff = 1.0_dp
      Mass1 = GetCReal(Params,'Particle Mass',Found)  
      Mass2 = Mass1 
      IF(.NOT. Found) THEN
        CALL Fatal('ParticleParticleCollision','> Particle Mass < needed!')
      END IF
      TrueCollision = GetLogical( Params,'True Collision Mode')
      SimilarParticles = .TRUE.
      Visited = .TRUE.
    END IF
    
    Collision = .FALSE.
    Debug = .FALSE.
    
    ! relative displacement and velocity    
    dr = Coord - Coord2
    dv = Velo - Velo2
    
    ! the collision time is found from the conditins |r1(t)-r2(t)|=R1+R2
    ! which results to 2nd order equation for the timestep, here a,b,c
    ! are the coefficicient in the equation. 
    b = SUM( dr * dv )
    
    ! The distance is only growing, there was a collision in history only
    IF( b >= 0.0_dp ) RETURN
    
    a = SUM( dv * dv ) 
    IF( SimilarParticles ) THEN
      c = SUM( dr * dr ) - 4*Rad1**2       
    ELSE
      c = SUM( dr * dr ) - ( Rad1 + Rad2 )**2
    END IF
    d = b*b - a*c
    
    ! negative discriminant means no solution
    IF( d < 0.0_dp ) RETURN
    
    ! time for first collision
    dta = (-b-SQRT(d))/a
    
    ! if time larger than given timestep
    IF( dta >= dt ) RETURN
    
    ! time remaining after the collision
    dtb = dt - dta
    
    ! vector at collision 
    dra = dr + dta * dv
    
    ! normal components at collision 
    rn = dra / SQRT( SUM( dra*dra ) )
    v1na = SUM( Velo * rn )
    v2na = SUM( Velo2 * rn ) 
    
    IF( SimilarParticles ) THEN
      v1nb = ( Coeff * (v2na - v1na) + v1na + v2na ) / 2
      v2nb = ( Coeff * (v1na - v2na) + v2na + v1na ) / 2
    ELSE
      v1nb = ( Coeff * Mass2 * (v2na - v1na) + Mass1 * v1na + Mass2 * v2na ) / ( Mass1 + Mass2 )
      v2nb = ( Coeff * Mass1 * (v1na - v2na) + Mass2 * v2na + Mass1 * v1na ) / ( Mass1 + Mass2 )
    END IF
    
    ! Set either force or velocity directly 
    ! only the normal component of velocity/force is affected by collisions    
    !----------------------------------------------------------------------
    IF( TrueCollision ) THEN
      ! compute the path until the collision
      Coord = Coord + dta * rn * Velo
      Coord2 = Coord2 + dta * rn * Velo2
      
      Velo = Velo + (v1nb-v1na) * rn
      Velo2 = Velo2 + (v2nb-v2na) * rn
      
      ! compute the path after the collision
      Coord = Coord + dtb * Velo
      Coord2 = Coord2 + dtb * Velo2
    ELSE
      Coord = Coord + (v1na-v1nb) * rn * dta
      Coord2 = Coord2 + (v2na-v2nb) * rn * dta
      
      Force = Mass1 * (v1nb-v1na) * rn / dt
      Force2 = Mass2 * (v2nb-v2na) * rn / dt
    END IF
    
    Collision = .TRUE.
    
  END FUNCTION ParticleParticleCollision
  



  !------------------------------------------------------------------------
  ! Write particles in an ascii format 
  !-------------------------------------------------------------------------
  SUBROUTINE ParticleOutput( Particles ) 
    
    TYPE(Particle_t) :: Particles
    LOGICAL :: Visited = .FALSE.
    TYPE(ValueList_t), POINTER :: Params     
    CHARACTER(LEN=MAX_NAME_LEN) :: FileFormat
    LOGICAL :: VtuFormat, TableFormat, Found
    
    SAVE :: TableFormat, VtuFormat, Visited
    
    IF( .NOT. Visited ) THEN
      Params => GetSolverParams()
      TableFormat = GetLogical( Params,'Table Format',Found)
      VtuFormat = GetLogical( Params,'Vtu Format',Found)
      FileFormat = GetString( Params,'Output Format',Found) 
      IF( Found ) THEN
        IF( FileFormat == 'vtu') VtuFormat = .TRUE.
        IF( FileFormat == 'table') TableFormat = .TRUE.
      END IF
      
      IF(.NOT. ListCheckPresent( Params,'Filename Prefix') ) THEN
        CALL ListAddString( Params,'Filename Prefix','particles')
      END IF
      Visited = .TRUE.
    END IF
    
    
    IF( TableFormat ) CALL ParticleOutputTable( Particles )
    IF( VtuFormat ) CALL ParticleOutputVtu( Particles ) 
    
  END SUBROUTINE ParticleOutput
  

  !------------------------------------------------------------------------
  ! Write particles in an ascii format 
  !-------------------------------------------------------------------------
  SUBROUTINE ParticleOutputTable( Particles ) 
    
    TYPE(Particle_t) :: Particles
    
    TYPE(Variable_t), POINTER :: TimeVar
    TYPE(ValueList_t), POINTER :: Params 
    CHARACTER(LEN=MAX_NAME_LEN) :: FilePrefix, FileName
    LOGICAL :: Found, NumberFilesByParticles, NumberFilesBySteps
    REAL(KIND=dp), POINTER :: Coord(:,:), Velo(:,:), Dist(:)
    REAL(KIND=dp) :: time
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER, POINTER :: Status(:)
    INTEGER :: i,j,dim, NoParticles, MinSaveStatus, MaxSaveStatus
    INTEGER :: VisitedTimes = 0
    
    SAVE :: VisitedTimes, Params, FilePrefix, NumberFilesByParticles, NumberFilesBySteps, &
        MinSaveStatus, MaxSaveStatus, TimeVar
    
    VisitedTimes = VisitedTimes + 1
    
    Mesh => GetMesh()
    dim = Particles % dim
    
    Coord => Particles % Coordinate
    Velo => Particles % Velocity 
    Dist => Particles % Distance
    Status => Particles % Status
    
    IF( VisitedTimes == 1 ) THEN
      Params => GetSolverParams()
      FilePrefix = ListGetString(Params,'Filename Prefix')
      CALL WriteParticleFileNames(FilePrefix, dim)
      
      NumberFilesByParticles = ListGetLogical( Params,'Filename Particle Numbering',Found) 
      NumberFilesBySteps = ListGetLogical( Params,'Filename Timestep Numbering',Found) 
      IF( NumberFilesByParticles .AND. NumberFilesBySteps ) THEN
        CALL Fatal('ParticleTracker','Files may be numbered either by steps or particles')
      END IF
      
      MinSaveStatus = ListGetInteger( Params,'Min Status for Saving',Found)
      IF(.NOT. Found ) MinSaveStatus = PARTICLE_INITIATED
      
      MaxSaveStatus = ListGetInteger( Params,'Max Status for Saving',Found)
      IF(.NOT. Found ) MaxSaveStatus = PARTICLE_LOST-1
      
      TimeVar => VariableGet( Mesh % Variables,'time')
    END IF
    
    time = TimeVar % Values(1)
    NoParticles = Particles % NumberOfParticles
    
    IF(.NOT. NumberFilesByParticles ) THEN
      IF( NumberFilesBySteps ) THEN
        CALL OpenParticleFile(FilePrefix, VisitedTimes )
      ELSE
        CALL OpenParticleFile(FilePrefix, 0 )        
      END IF
      DO i = 1, NoParticles
        IF ( Particles % Status(i) > MaxSaveStatus .OR. &
             Particles % Status(i) < MinSaveStatus )  CYCLE
        CALL WriteParticleLine( dim, i )        
      END DO
      CALL CloseParticleFile()
    ELSE
      DO i = 1, NoParticles
        CALL OpenParticleFile(FilePrefix, i)
        IF ( Particles % Status(i) > MaxSaveStatus .OR. &
             Particles % Status(i) < MinSaveStatus )  CYCLE
        CALL WriteParticleLine( dim, i ) 
        CALL CloseParticleFile()
      END DO
    END IF


  CONTAINS

    !------------------------------------------------------------------------
    ! Write the names file for user information. Remember to update this if 
    ! SaveParticleStep is modified.
    !-------------------------------------------------------------------------
    SUBROUTINE WriteParticleFileNames( Prefix, Dim ) 
      
      CHARACTER(LEN=MAX_NAME_LEN) :: Prefix
      INTEGER :: dim

      CHARACTER(LEN=MAX_NAME_LEN) :: FileName
      INTEGER :: i,j
      
      WRITE( FileName,'(A,A)') TRIM(FilePrefix),'.dat.names'
      
      OPEN (10, FILE=FileName )
      
      WRITE( 10, '(A)' ) 'Variables in file: '//TRIM(FilePrefix)//'*.dat'
      WRITE( 10, '(A,I2)' ) 'Dimension of particle set is',dim
      i = 1
      WRITE( 10, '(I2,A)' )  i,': time'
      WRITE( 10, '(I2,A)' )  i+1,': Coordinate_1'
      WRITE( 10, '(I2,A)' )  i+2,': Coordinate_2'
      IF(dim == 3) WRITE( 10, '(I2,A)' )  i+3,': Coordinate_3'
      i = i + DIM
      WRITE( 10, '(I2,A)' )  i+1,': Velocity_1'
      WRITE( 10, '(I2,A)' )  i+2,': Velocity_2'
      IF(dim == 3) WRITE( 10, '(I2,A)' )  i+3,': Velocity_3'
      i = i + DIM
      WRITE( 10, '(I2,A)' )  i+1,': Distance'
      i = i + 1
      
      CLOSE( 10 )
      
    END SUBROUTINE WriteParticleFileNames



    !------------------------------------------------------------------------
    ! Open a numbered file for each particle. These must be separate since the 
    ! number of steps for each particle may vary greatly
    !-------------------------------------------------------------------------
    SUBROUTINE OpenParticleFile( Prefix, FileNo ) 
      
      CHARACTER(LEN=MAX_NAME_LEN) :: Prefix
      INTEGER :: FileNo
      LOGICAL, SAVE :: Visited = .FALSE.


      CHARACTER(LEN=MAX_NAME_LEN) :: FileName
      
      IF( FileNo == 0 ) THEN
        WRITE( FileName,'(A,A)') TRIM(FilePrefix),'.dat'
        IF( .NOT. Visited ) THEN
          CALL Info( 'ParticleTracker', 'Saving particle paths to file: '//TRIM(FileName), Level=4 )
        END IF
      ELSE
        IF ( FileNo==1 .AND.  .NOT. Visited ) THEN
          WRITE( Message, * ) 'Saving particle paths to files: ', TRIM(FilePrefix)//'_*.dat'
          CALL Info( 'ParticleTracker', Message, Level=4 )
        END IF
        FileName=TRIM(FilePrefix)//'_'//TRIM(i2s(fileno))//'.dat'
      END IF
      IF ( ParEnv % Pes>1 ) FileName=TRIM(FileName)//TRIM(i2s(ParEnv % myPE))

      
      IF( VisitedTimes == 1 .OR. NumberFilesBySteps ) THEN
        OPEN (10, FILE=FileName )
        WRITE( 10, '()', ADVANCE='no' ) ! delete old contents
      ELSE
        OPEN (10, FILE=FileName,POSITION='APPEND' )
      END IF

      Visited = .TRUE.

    END SUBROUTINE OpenParticleFile
    
    
    !------------------------------------------------------------------------
    ! Save one line in the particle file
    !-------------------------------------------------------------------------
    SUBROUTINE WriteParticleLine( Dim, No )
      INTEGER :: Dim, No
      
      IF( NumberFilesBySteps ) THEN
        WRITE( 10, * ) time, No, Coord(No,1:dim), Velo(No,1:dim), Dist(No) 
      ELSE IF( NumberFilesByParticles ) THEN
        WRITE( 10, * ) time, VisitedTimes, Coord(No,1:Dim), Velo(No,1:dim), Dist(No) 
      ELSE       
        WRITE( 10, * ) time, VisitedTimes, No, Coord(No,1:dim), Velo(No,1:dim), Dist(No) 
      END IF

    END SUBROUTINE WriteParticleLine
    
    
    !------------------------------------------------------------------------
    ! Close the particle file
    !-------------------------------------------------------------------------
    SUBROUTINE CloseParticleFile( )
      
      CLOSE( 10 )
      
    END SUBROUTINE CloseParticleFile
           
  END SUBROUTINE ParticleOutputTable




  SUBROUTINE ParticleToFieldSolver( Solver,WeightVector,ForceVector)
    
    TYPE(Solver_t), POINTER :: Solver
    REAL(KIND=dp), POINTER :: WeightVector(:),ForceVector(:)
    
    REAL(KIND=dp) :: Norm


    CALL DefaultInitialize()  
    CALL BulkAssembly()
    CALL DefaultFinishAssembly()
    CALL DefaultDirichletBCs()
    Norm = DefaultSolve()
    
    
  CONTAINS 
    
    !------------------------------------------------------------------------
    ! Assemblies by Galerkin method the problem where a continuous field is 
    ! fitted to the data by discrete particles. The particles have a contribution
    ! on the r.h.s. There are two different methods
    ! 1) without normalization it is assumed that the r.h.s is already physically
    !    relevant sum of the data.
    ! 2) with normalization it is assumed that the r.h.s. scales with the weight
    !    and division by weight is needed to obtain a statistical average.
    ! In both cases regularization by a diffusion coefficient may be used but 
    ! it is essenitial only in the latter.
    !-------------------------------------------------------------------------
    SUBROUTINE BulkAssembly()
      
      INTEGER, POINTER :: BoundaryPerm(:), Indexes(:)
      INTEGER :: i,j,k,t,n,istat,active,BoundaryNodes
      TYPE(Element_t), POINTER :: Element
      TYPE(GaussIntegrationPoints_t) :: IP
      CHARACTER(LEN=MAX_NAME_LEN) :: BoundaryName
      TYPE(Nodes_t) :: Nodes
      REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), FORCE(:)
      REAL(KIND=dp), POINTER :: Basis(:), dBasisdx(:,:)
      REAL(KIND=dp) :: Coeff, detJ, RealWeightSum, IdealWeightSum, WeightCorr, val
      TYPE(Matrix_t), POINTER :: StiffMatrix 
      LOGICAL :: stat, Normalize, Visited = .FALSE.
      
      
      SAVE Visited, BoundaryPerm, Nodes, STIFF, FORCE, Basis, dBasisdx
      
      IF(.NOT. Visited ) THEN
        Visited = .TRUE.
        N = Solver % Mesh % MaxElementNodes 
        ALLOCATE( Basis(n), dBasisdx(n, 3), FORCE(N), STIFF(N,N), STAT=istat )
        
        N = Solver % Mesh % NumberOfNodes
        ALLOCATE( BoundaryPerm(n) )
        BoundaryPerm = 0
        BoundaryNodes = 0
        BoundaryName = 'Free Point Boundary'
        CALL MakePermUsingMask( CurrentModel,Solver,Solver % Mesh,BoundaryName, &
            .FALSE., BoundaryPerm, BoundaryNodes )
        PRINT *,'Number of nodes on free boundary:',BoundaryNodes
      END IF
      
      ! Assembly the diffusion part used for regularization
      !----------------------------------------------------------
      Coeff = GetCReal( Solver % Values,'Particle Property Diffusion Coefficient')
      active = GetNOFActive()
      StiffMatrix => Solver % Matrix

      Normalize = GetLogical( Solver % Values,'Particle Property Normalize')
      IdealWeightSum = 0.0_dp
      
      DO t=1,active
        Element => GetActiveElement(t)
        n = GetElementNOFNodes(Element)
        Indexes => Element % NodeIndexes
        
        CALL GetElementNodes( Nodes, Element )
        STIFF = 0.0d0
        FORCE = 0.0d0
        
        ! Numerical integration:
        !----------------------
        IP = GaussPoints( Element )
        DO k=1,IP % n
          ! Basis function values & derivatives at the integration point:
          !--------------------------------------------------------------
          stat = ElementInfo( Element, Nodes, IP % U(k), IP % V(k), &
              IP % W(k),  detJ, Basis, dBasisdx )
          
          ! Finally, the elemental matrix & vector:
          !----------------------------------------
          DO i=1,n
            val = IP % s(k) * DetJ * Basis(i) 
            IdealWeightSum = IdealWeightSum + val
            IF(.NOT. Normalize ) THEN
              STIFF(i,i) = STIFF(i,i) + val
            END IF
            
            ! This condition removes the natural boundary condition that would 
            ! try to fix the normal gradient of the field to zero.
            !--------------------------------------------------------------------
            IF( BoundaryPerm( Indexes(i) ) > 0 ) CYCLE
            DO j=1,n
              STIFF(i,j) = STIFF(i,j) + IP % s(k) * Coeff * DetJ * &
                  SUM( dBasisdx(i,:) * dBasisdx(j,:) ) 
            END DO
          END DO
        END DO
        
        CALL DefaultUpdateEquations( STIFF, FORCE )
      END DO

      IF( Normalize ) THEN
        ! Set the weight to the diagonal i.e. make the mass matrix contribution  
        ! The data is normalized so that if it would be constant it would yield the 
        ! same equation as the normal one and the weights would also be constant.
        ! This way diffusion will not depend on the amount of data, whether
        ! that is desirable, or not, I don't know. 
        !-----------------------------------------------------------------------
        RealWeightSum = SUM( WeightVector ) 
        WeightCorr = IdealWeightSum / RealWeightSum 
        StiffMatrix => Solver % Matrix
        DO i=1,SIZE( WeightVector ) 
          val = WeightCorr * WeightVector(i)  
          CALL AddToMatrixElement( StiffMatrix,i,i,val )
        END DO
        StiffMatrix % rhs = WeightCorr * ForceVector        
      ELSE
        StiffMatrix % rhs = ForceVector
      END IF

    END SUBROUTINE BulkAssembly

  END SUBROUTINE ParticleToFieldSolver




!------------------------------------------------------------------------------
  SUBROUTINE CreateParticleVariable( Particles, Name, DOFs, Category, Output ) 
!------------------------------------------------------------------------------
    TYPE(Particle_t) :: Particles
    CHARACTER(LEN=*) :: Name
    INTEGER, OPTIONAL :: DOFs
    INTEGER, OPTIONAL :: Category
    LOGICAL, OPTIONAL :: Output
!------------------------------------------------------------------------------
    TYPE(ParticleVariable_t), POINTER :: Variables
    REAL(KIND=dp), POINTER :: Values(:)
    LOGICAL :: stat
    TYPE(ParticleVariable_t), POINTER :: ptr,ptr1,ptr2
    INTEGER :: NoParticles
!------------------------------------------------------------------------------

    Variables => Particles % Variables
    IF ( .NOT.ASSOCIATED(Variables) ) THEN
      ALLOCATE(Variables)
      ptr => Variables
    ELSE
      ALLOCATE( ptr )
    END IF
    
    ! note: sets confusinly also ptr % name 
    ptr % NameLen = StringToLowerCase( ptr % Name,Name )
    
    ! get the next free handle?
    IF ( .NOT. ASSOCIATED(ptr, Variables) ) THEN
      ptr1 => Variables
      ptr2 => Variables
      DO WHILE( ASSOCIATED( ptr1 ) )
        IF ( ptr % Name == ptr1 % Name ) THEN
          DEALLOCATE( ptr )
          RETURN
        END IF
        ptr2 => ptr1
        ptr1 => ptr1 % Next
      END DO
      ptr2 % Next => ptr
    END IF
    ptr % Next => Null()
    
    ptr % Norm = 0.0d0
    ptr % PrevNorm = 0.0d0
    ptr % DOFs = 1
    ptr % Valid  = .TRUE.
    ptr % Output = .TRUE.
    ptr % ValuesChanged = .TRUE.
    
    IF( PRESENT( DOFs ) ) ptr % DOFs = DOFs
    IF ( PRESENT( Category ) ) ptr % Category = Category
    IF ( PRESENT( Output ) ) ptr % Output = Output
    
    NoParticles = Particles % MaxNumberOfParticles
    ALLOCATE( Values( NoParticles * ptr % Dofs ) )
    Values = 0.0_dp
    ptr % Values => Values

!------------------------------------------------------------------------------
  END SUBROUTINE CreateParticleVariable
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!  Given a variable name, get handle to it
!------------------------------------------------------------------------------
  FUNCTION GetParticleVariable( Particles, Name ) RESULT ( Var )
    
    TYPE(Particle_t) :: Particles
    CHARACTER(LEN=*) :: Name
    TYPE(ParticleVariable_t), POINTER :: Var
!------------------------------------------------------------------------------
    TYPE(ParticleVariable_t), POINTER :: Tmp
    CHARACTER(LEN=LEN_TRIM(Name)) :: str
    INTEGER :: k
      
!------------------------------------------------------------------------------
    k = StringToLowerCase( str,Name,.TRUE. )
    
    Tmp => Particles % Variables
    DO WHILE( ASSOCIATED(tmp) )
      IF ( Tmp % NameLen == k ) THEN
        IF ( Tmp % Name(1:k) == str(1:k) ) THEN
          
          IF ( Tmp % Valid ) THEN
            Var => Tmp
            RETURN
          END IF
          EXIT
          
        END IF
      END IF
      Tmp => Tmp % Next
    END DO
    Var => Tmp

  END FUNCTION GetParticleVariable



  SUBROUTINE ParticleOutputVtu( Particles )
!------------------------------------------------------------------------------

    USE DefUtils 
    USE MeshUtils
    USE ElementDescription
    
    IMPLICIT NONE
    TYPE(Particle_t) :: Particles  
    
    TYPE(ValueList_t),POINTER :: Params
    INTEGER, SAVE :: nTime = 0
    LOGICAL :: GotIt, Parallel, FixedMeshend
    
    CHARACTER(MAX_NAME_LEN), SAVE :: FilePrefix
    CHARACTER(MAX_NAME_LEN) :: VtuFile, PvtuFile 
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Variable_t), POINTER :: Var
    INTEGER :: i, j, k, Partitions, Part, ExtCount, FileindexOffSet, &
        Status, MinSaveStatus, MaxSaveStatus
    CHARACTER(MAX_NAME_LEN) :: Dir
    REAL(KIND=dp) :: SaveNodeFraction
    LOGICAL :: Found,Visited = .FALSE.
    
    CHARACTER(MAX_NAME_LEN) :: Str
    INTEGER :: NumberOfNodes, ParallelNodes, Dim
    
    SAVE :: MinSaveStatus, MaxSaveStatus
    
    Params => GetSolverParams()
    Mesh => GetMesh()
    
    ExtCount = ListGetInteger( Params,'Output Count',GotIt)
    IF( GotIt ) THEN
      nTime = ExtCount
    ELSE
      nTime = nTime + 1
    END IF
    FileIndexOffset = ListGetInteger( Params,'Fileindex offset',GotIt)
    
    IF ( nTime == 1 ) THEN
      FilePrefix = GetString( Params,'Filename Prefix')
      CALL Info('ParticleOutputVtu','Saving results in VTK XML format to file:'//TRIM(FilePrefix))
      
      MinSaveStatus = ListGetInteger( Params,'Min Status for Saving',Found)
      IF(.NOT. Found ) MinSaveStatus = PARTICLE_INITIATED
      
      MaxSaveStatus = ListGetInteger( Params,'Max Status for Saving',Found)
      IF(.NOT. Found ) MaxSaveStatus = PARTICLE_LOST-1
      
    END IF
    
    Partitions = ParEnv % PEs
    Part = ParEnv % MyPE
    Parallel = (Partitions > 1) .OR. ListGetLogical(Params,'Enforce Parallel format',GotIt)
    
    Dim = Particles % dim
        
    NumberOfNodes = 0
    DO i=1,Particles % NumberOfParticles
      IF ( Particles % Status(i) > MaxSaveStatus .OR. &
          Particles % Status(i) < MinSaveStatus )  CYCLE
      NumberOfNodes = NumberOfNodes + 1
    END DO
    
    SaveNodeFraction = ListGetCReal( Params,'Particle Save Fraction',GotIt)
    IF(GotIt) NumberOfNodes = NINT( SaveNodeFraction * NumberOfNodes )
    
    IF (LEN_TRIM(Mesh % Name) > 0 ) THEN
      Dir = TRIM(Mesh % Name) // "/"
    ELSE
      Dir = "./"
    END IF
    
    IF(Parallel .AND. Part == 0) THEN
      WRITE( PvtuFile,'(A,A,I4.4,".pvtu")' ) TRIM(Dir),TRIM(FilePrefix),nTime+FileIndexOffset
      CALL WritePvtuFile( PvtuFile )
    END IF
    
    IF ( Parallel ) THEN
      WRITE( VtuFile,'(A,A,I4.4,A,I4.4,".vtu")' ) TRIM(Dir),TRIM(FilePrefix),Part+1,"par",nTime
    ELSE
      WRITE( VtuFile,'(A,A,I4.4,".vtu")' ) TRIM(Dir),TRIM(FilePrefix),nTime+FileIndexOffset
    END IF
    CALL WriteVtuFile( VtuFile )
    

  CONTAINS

  
    SUBROUTINE WriteVtuFile( VtuFile )
      CHARACTER(LEN=*), INTENT(IN) :: VtuFile
      INTEGER, PARAMETER :: VtuUnit = 58
      TYPE(Variable_t), POINTER :: Var
      CHARACTER(LEN=512) :: str
      INTEGER :: i,j,k,dofs,Rank,cumn,n,vari,sdofs
      CHARACTER(LEN=1024) :: Txt, ScalarFieldName, VectorFieldName, FieldName
      LOGICAL :: ScalarsExist, VectorsExist, Found
      INTEGER, POINTER :: Perm(:)
      REAL(KIND=dp), POINTER :: ScalarValues(:), VectorValues(:,:)
      REAL(KIND=dp) :: x,y,z
      
      
      OPEN( UNIT=VtuUnit, FILE=VtuFile, STATUS='UNKNOWN' )
      
      WRITE( VtuUnit,'(A)') '<VTKFile type="UnstructuredGrid" version="0.1" byte_order="LittleEndian">'
      WRITE( VtuUnit,'(A)') '  <UnstructuredGrid>'
      WRITE( VtuUnit,'(A,I0,A)') '    <Piece NumberOfPoints="',NumberOfNodes,&
          '" NumberOfCells="0">'
    
      ! nodewise information
      !-------------------------------------
      ScalarFieldName = GetString( Params,'Scalar Field 1',ScalarsExist)
      VectorFieldName = GetString( Params,'Vector Field 1',VectorsExist)
      IF( ScalarsExist .AND. VectorsExist) THEN
        WRITE( VtuUnit,'(A)') '      <PointData Scalars="'//TRIM(ScalarFieldName)&
            //'" Vectors="'//TRIM(VectorFieldName)//'">'
      ELSE IF( ScalarsExist ) THEN
        WRITE( VtuUnit,'(A)') '      <PointData Scalars="'//TRIM(ScalarFieldName)//'">'
      ELSE IF( VectorsExist ) THEN
        WRITE( VtuUnit,'(A)') '      <PointData Vectors="'//TRIM(VectorFieldName)//'">'
      END IF
      
      DO Rank = 0,1
        DO Vari = 1, 99
          IF( Vari < 10 ) THEN
            IF(Rank==0) WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
            IF(Rank==1) WRITE(Txt,'(A,I2)') 'Vector Field',Vari
          ELSE
            IF(Rank==0) WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
            IF(Rank==1) WRITE(Txt,'(A,I3)') 'Vector Field',Vari
          END IF
          
          FieldName = GetString( Params, TRIM(Txt), Found )
          IF(.NOT. Found) EXIT
        
          !---------------------------------------------------------------------
          ! Find the variable with the given name in the normal manner 
          !---------------------------------------------------------------------
          IF( FieldName == 'velocity' ) THEN
            VectorValues => Particles % Velocity
          ELSE IF( FieldName == 'force') THEN
            VectorValues => Particles % Force 
          ELSE IF( FieldName == 'distance') THEN
            ScalarValues => Particles % Distance
          ELSE IF( FieldName == 'dt') THEN
            ScalarValues => Particles % dt
          ELSE
            WRITE(Txt, '(A,A)') 'Nonexistent variable: ',TRIM(FieldName)
            CALL Warn('WriteVtuXMLFile', Txt)
            CYCLE
          END IF
          
          !---------------------------------------------------------------------
          ! Finally save the field values 
          !---------------------------------------------------------------------
          j = 0
          IF( Rank == 0) THEN
            WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" Name="'//TRIM(FieldName)&
                //'" NumberOfComponents="1" format="ascii">'    
            DO i = 1, Particles % NumberOfParticles
              
              IF ( Particles % Status(i) > MaxSaveStatus .OR. &
                  Particles % Status(i) < MinSaveStatus )  CYCLE
              j = j + 1
              IF(.TRUE.) THEN
                WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') ScalarValues(i)              
              ELSE
                WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0'  
              END IF
              IF( j == NumberOfNodes ) EXIT            
            END DO
            WRITE( VtuUnit,'(A)') ' '
            WRITE( VtuUnit,'(A)') '        </DataArray>'
          ELSE
            sdofs = 3
            WRITE( VtuUnit,'(A,I1,A)') '        <DataArray type="Float64" Name="'//TRIM(FieldName)&
                //'" NumberOfComponents="',sdofs,'" format="ascii">'    
            
            DO i = 1, Particles % NumberOfParticles
              IF ( Particles % Status(i) > MaxSaveStatus .OR. &
                  Particles % Status(i) < MinSaveStatus )  CYCLE
              j = j + 1
              IF( dim == 2 ) THEN
                IF( .TRUE. ) THEN
                  WRITE( VtuUnit,'(2ES16.7E3,A)', ADVANCE='no') VectorValues(i,1:dim),' 0.0'
                ELSE
                  WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0 0.0 0.0'  
                END IF
              ELSE
                IF( .TRUE. ) THEN
                  WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') VectorValues(i,1:dim)
                ELSE
                  WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0 0.0 0.0'  
                END IF
              END IF
              IF( j == NumberOfNodes ) EXIT            
            END DO
            WRITE( VtuUnit,'(A)') ' '
            WRITE( VtuUnit,'(A)') '        </DataArray>'
          END IF
        END DO
      END DO
      
      IF( ScalarsExist .OR. VectorsExist) THEN
        WRITE( VtuUnit,'(A)') '      </PointData>'
      END IF
      
    
      ! Coordinates of each point
      !-------------------------------------
      WRITE( VtuUnit,'(A)') '      <Points>'
      WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" NumberOfComponents="3" format="ascii">'    
      
      
      j = 0
      DO i = 1, Particles % NumberOfParticles
        IF ( Particles % Status(i) > MaxSaveStatus .OR. &
            Particles % Status(i) < MinSaveStatus )  CYCLE
        j = j + 1
        DO k=1,dim
          WRITE(VtuUnit,'(ES16.7E3)', ADVANCE='no') Particles % Coordinate(i,k)
        END DO
        IF( dim == 3 ) THEN
          WRITE(VtuUnit,'(A)') ' '
        ELSE
          WRITE(VtuUnit,'(A)') ' 0.0'
        END IF
        IF( j == NumberOfNodes ) EXIT
      END DO
      
      WRITE( VtuUnit,'(A)') '        </DataArray>'
      WRITE( VtuUnit,'(A)') '      </Points>'
      

      WRITE( VtuUnit,'(A)') '      <Cells>'
      WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="connectivity" format="ascii">'
      WRITE( VtuUnit,'(A)') '        </DataArray>'
      WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="offsets" format="ascii">'
      WRITE( VtuUnit,'(A)') '        </DataArray>'
      WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="types" format="ascii">'
      WRITE( VtuUnit,'(A)') '        </DataArray>'
      WRITE( VtuUnit,'(A)') '      </Cells>'
      
      WRITE( VtuUnit,'(A)') '    </Piece>'
      WRITE( VtuUnit,'(A)') '  </UnstructuredGrid>'
      WRITE( VtuUnit,'(A)') '</VTKFile>'
      
      CLOSE( VtuUnit )
      
    END SUBROUTINE WriteVtuFile
    


    SUBROUTINE WritePvtuFile( VtuFile )
      CHARACTER(LEN=*), INTENT(IN) :: VtuFile
      INTEGER, PARAMETER :: VtuUnit = 58
      TYPE(Variable_t), POINTER :: Var
      CHARACTER(LEN=512) :: str
      INTEGER :: i,j,k,dofs,Rank,cumn,n,vari,sdofs
      CHARACTER(LEN=1024) :: Txt, ScalarFieldName, VectorFieldName, FieldName
      LOGICAL :: ScalarsExist, VectorsExist, Found
      REAL(KIND=dp), POINTER :: ScalarValues(:), VectorValues(:,:)
      
      
      OPEN( UNIT=VtuUnit, FILE=VtuFile, STATUS='UNKNOWN' )
      
      WRITE( VtuUnit,'(A)') '<VTKFile type="PUnstructuredGrid" version="0.1" byte_order="LittleEndian">'
      WRITE( VtuUnit,'(A)') '  <PUnstructuredGrid>'
      
      ! nodewise information
      !-------------------------------------
      ScalarFieldName = GetString( Params,'Scalar Field 1',ScalarsExist)
      VectorFieldName = GetString( Params,'Vector Field 1',VectorsExist)
      IF( ScalarsExist .AND. VectorsExist) THEN
        WRITE( VtuUnit,'(A)') '    <PPointData Scalars="'//TRIM(ScalarFieldName)&
            //'" Vectors="'//TRIM(VectorFieldName)//'">'
      ELSE IF( ScalarsExist ) THEN
        WRITE( VtuUnit,'(A)') '    <PPointData Scalars="'//TRIM(ScalarFieldName)//'">'
      ELSE IF( VectorsExist ) THEN
        WRITE( VtuUnit,'(A)') '    <PPointData Vectors="'//TRIM(VectorFieldName)//'">'
      END IF
      
    
      DO Rank = 0,1
        DO Vari = 1, 99
          IF( Vari < 10 ) THEN
            IF(Rank==0) WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
            IF(Rank==1) WRITE(Txt,'(A,I2)') 'Vector Field',Vari
          ELSE
            IF(Rank==0) WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
            IF(Rank==1) WRITE(Txt,'(A,I3)') 'Vector Field',Vari
          END IF
          
          FieldName = GetString( Params, TRIM(Txt), Found )
          IF(.NOT. Found) EXIT
          
          IF( FieldName /= 'velocity' .AND. FieldName /= 'force' .AND. &
              FieldName /= 'distance' .AND. FieldName /= 'dt' ) THEN
            WRITE(Txt, '(A,A)') 'Nonexistent variable: ',TRIM(FieldName)
            CALL Warn('WriteVtuXMLFile', Txt)
            CYCLE
          END IF
          
          IF( Rank == 0) THEN
            WRITE( VtuUnit,'(A)') '      <PDataArray type="Float64" Name="'//TRIM(FieldName)&
                //'" NumberOfComponents="1" format="ascii"/>'    
          ELSE
            sdofs = 3
            WRITE( VtuUnit,'(A,I1,A)') '      <PDataArray type="Float64" Name="'//TRIM(FieldName)&
                //'" NumberOfComponents="',sdofs,'" format="ascii"/>'    
          END IF
        END DO
      END DO
      WRITE( VtuUnit,'(A)') '    </PPointData>'
      
      ! Coordinates of each point
      !-------------------------------------
      WRITE( VtuUnit,'(A)') '      <PPoints>'
      WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" NumberOfComponents="3" format="ascii"/>'    
      WRITE( VtuUnit,'(A)') '      </PPoints>' 
      
      DO i=1,Partitions
        WRITE( VtuUnit,'(A,I4.4,A,I4.4,A)' ) '    <Piece Source="'//&
            TRIM(FilePrefix),i,"par",nTime,'.vtu"/>'
      END DO
      
      WRITE( VtuUnit,'(A)') '  </PUnstructuredGrid>'
      WRITE( VtuUnit,'(A)') '</VTKFile>'
      
      CLOSE( VtuUnit )
      
    END SUBROUTINE WritePvtuFile
   

!------------------------------------------------------------------------------
  END SUBROUTINE ParticleOutputVtu
!------------------------------------------------------------------------------



!--------------------------------------------------------------------------
! Set a the timestep for the particles in two possible modes
! 1) "No" is given => define step for each particle separately
! 2) "No" is not given => define the same step size for all particles
!-------------------------------------------------------------------------
  FUNCTION GetParticleTimeStep(Particles, InitInterval, No, tinit ) RESULT ( dt )
    
    TYPE(Particle_t) :: Particles
    LOGICAL :: InitInterval
    INTEGER, OPTIONAL :: No
    REAL(KIND=dp), OPTIONAL :: tinit
    REAL(KIND=dp) :: dt
    
    REAL(KIND=dp) :: dt0,tfin,tprev,dsgoal,hgoal,dtmax,dtmin,dtup,dtlow, &
        CharSpeed, CharTime
    LOGICAL :: GotIt,TfinIs,NStepIs,DsGoalIs,HgoalIs,DtIs
    INTEGER :: nstep, TimeStep, PrevTimeStep = -1
    TYPE(ValueList_t), POINTER :: Params
    
    SAVE dt0,dsgoal,hgoal,dtmax,dtmin,DtIs,&
        tprev,Tfin,TfinIs,DsGoalIs,HgoalIs,PrevTimeStep
    
    IF( InitInterval ) THEN
      Params => GetSolverParams()
      
      ! directly defined timestep
      dt0 = GetCReal(Params,'Timestep Size',DtIs)
      
      ! Constraint by absolute step size taken (in length units)
      dsgoal = GetCReal( Params,'Timestep Distance',DsGoalIs)
      
      ! Constraint by relative step size taken (1 means size of the element)
      hgoal = GetCReal( Params,'Timestep Courant Number',HGoalIs)
      
      Nstep = GetInteger( Params,'Max Timestep Intervals',NstepIs)
      
      ! Constraint timestep directly
      dtmax = GetCReal( Params,'Max Timestep Size',GotIt)
      IF(.NOT. GotIt ) dtmax = HUGE( dtmax ) 
      dtmin = GetCReal( Params,'Min Timestep Size',GotIt)
      IF(.NOT. GotIt ) dtmin = 0.0 
      
      TfinIs = .FALSE.
      IF( GetLogical(Params,'Simulation Timestep Sizes',GotIt) ) THEN
        tfin = GetTimeStepsize()
        TfinIs = .TRUE.
      ELSE
        tfin = GetCReal(Params,'Max Cumulative Time',TfinIs)
      END IF
      
      tprev = 0.0_dp
    END IF
    
    IF( TfinIs .AND. ABS( tprev - tfin ) < TINY ( tfin ) ) THEN
      dt = 0.0_dp
      RETURN
    END IF
    
    
    ! Get upper and lower constraints for timestep size
    ! These generally depend on the velocity field and mesh
    !--------------------------------------------------------------------
    IF( DtIs ) THEN
      dt = dt0
    ELSE IF( DsGoalIs ) THEN
      CharSpeed = CharacteristicSpeed( Particles, No )     
      dt = dsgoal / CharSpeed
    ELSE IF( HgoalIs ) THEN
      CharTime = CharacteristicElementTime( Particles, No )     
      dt = Hgoal * CharTime ! ElementH / Speed
    ELSE IF( tfinIs .AND. NstepIs ) THEN
      dt = tfin / Nstep
    ELSE
      CALL Fatal('GetParticlesTimeStep','Cannot determine timestep size!')
    END IF
    
    ! Constrain the timestep
    !------------------------------------------------------------------
    dt = MAX( MIN( dt, dtmax ), dtmin )
    
    ! Do not exceed the total integration time
    !-------------------------------------------
    IF( PRESENT( tinit ) ) tprev = tinit
    IF( TfinIs .AND. dt + tprev > tfin ) THEN
      dt = tfin - tprev
    END IF
    tprev = tprev + dt
    
  
  END FUNCTION GetParticleTimeStep

!------------------------------------------------------------------------------
END MODULE ParticleUtils
!------------------------------------------------------------------------------
