!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Module for mapping the mesh using analytical commands of scaling, 
! *  rotation, translation and smoothing.
! *
! ******************************************************************************
! *
! *  Authors: Peter Råback
! *  Email:   Peter.Raback@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 24.2.2009
! *
! *****************************************************************************/

!------------------------------------------------------------------------------
SUBROUTINE RigidMeshMapper( Model,Solver,dt,Transient )
!------------------------------------------------------------------------------

  USE CoordinateSystems
  USE ElementUtils
  USE ElementDescription
  USE ParallelUtils
  USE Types
  USE Lists
  USE DefUtils

  
  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Model_t)  :: Model
  TYPE(Solver_t), TARGET :: Solver
  LOGICAL ::  Transient
  REAL(KIND=dp) :: dt
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------
  TYPE(ValueList_t),POINTER :: SolverParams
  INTEGER :: i,j,k,n,dim,elem,bf_id,prev_bf_id
  INTEGER, POINTER :: NodeIndexes(:)
  REAL(KIND=dp), POINTER :: PArray(:,:) => NULL()
  REAL(KIND=dp) :: x0(4), x1(4), RotMatrix(4,4),TrsMatrix(4,4),SclMatrix(4,4), &
      TrfMatrix(4,4),Identity(4,4), Origin(4),alpha
  REAL(KIND=dp) :: at0,at1,at2,CPUTime,RealTime
  REAL(KIND=dp), POINTER :: Xorig(:),Yorig(:),Zorig(:),Xnew(:),Ynew(:),Znew(:),&
      Relax(:)
  LOGICAL :: Found,GotMatrix,GotRotate,GotTranslate,GotScale,AllocationsDone=.FALSE.,&
      UseOriginalMesh
  LOGICAL, POINTER :: NodeDone(:)
  TYPE(Element_t), POINTER :: Element
  TYPE(Nodes_t), SAVE :: Nodes
  TYPE(ValueList_t),POINTER :: BodyForce

  
  SAVE Xorig,Yorig,Zorig,Parray,AllocationsDone
 
  CALL Info( 'RigidMeshMapper','---------------------------------------',Level=4 )
  CALL Info( 'RigidMeshMapper','Performing analytic mesh mapping ',Level=4 )
  CALL Info( 'RigidMeshMapper','---------------------------------------',Level=4 )

  SolverParams => GetSolverParams()
  UseOriginalMesh = GetLogical( SolverParams,'Use Original Coordinates',Found)

  dim = CoordinateSystemDimension()
  
  Xnew => Solver % Mesh % Nodes % x
  Ynew => Solver % Mesh % Nodes % y
  Znew => Solver % Mesh % Nodes % z
  n = SIZE( Xnew )

  ALLOCATE( NodeDone(n), Relax(Solver % Mesh % MaxElementNodes))
  NodeDone = .FALSE.

  ! If using original mesh as a reference mesh it must be saved,
  ! otherwise the analytic mapping does not require two meshes
  !------------------------------------------------------------
  IF( UseOriginalMesh ) THEN
    IF( .NOT. AllocationsDone ) THEN
      WRITE(Message,* ) 'Allocating new nodes of size: ',n
      CALL Info('RigidMeshMapper',Message)
      ALLOCATE(Xorig(n),Yorig(n),Zorig(n))      
      Xorig = Xnew
      Yorig = Ynew
      Zorig = Znew
      AllocationsDone = .TRUE.
    END IF
  ELSE
    Xorig => Xnew
    Yorig => Ynew
    Zorig => Znew
  END IF

  ! Initialize the mapping matrices
  Identity = 0.0d0
  DO i=1,4
    Identity(i,i) = 1.0d0
  END DO

  prev_bf_id = -1
  GotRotate = .FALSE.
  GotTranslate = .FALSE.
  GotScale = .FALSE.
  GotMatrix = .FALSE.

  at0 = CPUTime()
  CALL Info('RigidMeshMapper','Starting mesh mapping' ) 

  DO elem = 1,Solver % Mesh % NumberOfBulkElements      
    Element => Solver % Mesh % Elements(elem)
    NodeIndexes => Element % NodeIndexes
    Model % CurrentElement => Element
    CALL GetElementNodes( Nodes )
    n  = GetElementNOFNodes()
    
    bf_id = ListGetInteger( Model % Bodies(Element % BodyId) % Values,'Body Force',Found )
    IF(.NOT. Found) CYCLE

    IF( ALL ( NodeDone(NodeIndexes(1:n)) ) ) CYCLE
    BodyForce => Model % BodyForces(bf_id) % Values
  
    Relax(1:n) = GetReal( BodyForce,'Mesh Relax',Found)
    IF(.NOT. Found ) Relax = 1.0_dp
    DO i=1,n
      Relax(i) = MIN( MAX( Relax(i), 0.0_dp ), 1.0_dp )
    END DO


    GotMatrix = ( bf_id == prev_bf_id ) 
    NULLIFY(Parray)

    ! Generic transformation matrix
    !--------------------------------
    IF(.NOT. GotMatrix ) THEN
      Parray => ListGetConstRealArray( BodyForce,'Mesh Matrix', GotMatrix )
      IF ( GotMatrix ) THEN
        DO i=1,SIZE(Parray,1)
          DO j=1,SIZE(Parray,2)
            TrfMatrix(i,j) = Parray(j,i)
          END DO
        END DO
      END IF
    END IF

    IF(.NOT. GotMatrix ) THEN
      TrsMatrix = Identity
      RotMatrix = Identity
      SclMatrix = Identity

      ! Rotations around main axis:
      !---------------------------
      Parray => ListGetConstRealArray( BodyForce,'Mesh Rotate', GotRotate )      

      IF ( GotRotate ) THEN
        DO i=1,SIZE(Parray,1)
          Alpha = Parray(i,1) * PI / 180.0_dp
          IF( ABS(Alpha) < TINY(Alpha) ) CYCLE
          TrfMatrix = Identity

          SELECT CASE(i)
          CASE(1)
            TrfMatrix(2,2) =  COS(Alpha)
            TrfMatrix(2,3) = -SIN(Alpha)
            TrfMatrix(3,2) =  SIN(Alpha)
            TrfMatrix(3,3) =  COS(Alpha)
          CASE(2)
            TrfMatrix(1,1) =  COS(Alpha)
            TrfMatrix(1,3) = -SIN(Alpha)
            TrfMatrix(3,1) =  SIN(Alpha)
            TrfMatrix(3,3) =  COS(Alpha)
          CASE(3)
            TrfMatrix(1,1) =  COS(Alpha)
            TrfMatrix(1,2) = -SIN(Alpha)
            TrfMatrix(2,1) =  SIN(Alpha)
            TrfMatrix(2,2) =  COS(Alpha)
          END SELECT

          RotMatrix = MATMUL( RotMatrix, TrfMatrix )
        END DO
      END IF

      ! Translations:
      !---------------
      Parray => ListGetConstRealArray( BodyForce,'Mesh Translate', GotTranslate )
      IF ( GotTranslate ) THEN
        DO i=1,SIZE(Parray,1)
          TrsMatrix(i,4) = Parray(i,1)
        END DO
      END IF
    
      ! Scaling:
      !---------
      Parray => ListGetConstRealArray( BodyForce,'Mesh Scale', GotScale )
      IF ( GotScale ) THEN
        DO i=1,SIZE(Parray,1)
          SclMatrix(i,i) = Parray(i,1)
        END DO
      END IF

      IF(.NOT. (GotRotate .OR. GotTranslate .OR. GotScale)) CYCLE

      ! Origin:
      !---------
      Parray => ListGetConstRealArray( BodyForce,'Mesh Origin', Found )
      IF ( Found ) THEN
        DO i=1,SIZE(Parray,1)
          Origin(i) = Parray(i,1)
        END DO
      ELSE 
        Origin = 0.0_dp
      END IF

      TrfMatrix = MATMUL( TrsMatrix, RotMatrix )
      IF( GotScale ) THEN
        TrsMatrix = TrfMatrix
        TrfMatrix = MATMUL( SClMatrix, TrsMatrix )
      END IF
    END IF

    prev_bf_id = bf_id

    DO i=1,n
      j = NodeIndexes(i)
      IF(NodeDone(j)) CYCLE

      x0(1) = Xorig(j)
      x0(2) = Yorig(j)
      x0(3) = Zorig(j)
      x0(4) = 1.0_dp

      x1 = MATMUL( TrfMatrix, x0 - Origin ) + Origin
      x1(1:3) = x1(1:3) / x1(4)

      x1 = Relax(i) * x1 + (1-Relax(i)) * x0

      Xnew(j) = x1(1)
      Ynew(j) = x1(2)
      Znew(j) = x1(3)

      NodeDone(j) = .TRUE.
    END DO

  END DO

  WRITE(Message,* ) 'Number of nodes mapped: ',COUNT( NodeDone )
  CALL Info('RigidMeshMapper',Message)

  at1 = CPUTime()
  WRITE(Message,* ) 'Coordinate mapping time: ',at1-at0
  CALL Info('RigidMeshMapper',Message)

  DEALLOCATE( Relax, NodeDone )

  CALL Info('RigidMeshMapper','All done' ) 

!------------------------------------------------------------------------------
END SUBROUTINE RigidMeshMapper
!------------------------------------------------------------------------------
