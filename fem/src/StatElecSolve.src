!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Electrostatics solver
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen, Leila Puska, Antti Pursula, Peter Råback
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 20 Jun 2002
! *
! *****************************************************************************/


!------------------------------------------------------------------------------
SUBROUTINE StatElecSolver_Init( Model,Solver,dt,TransientSimulation)
!------------------------------------------------------------------------------
    USE DefUtils
    IMPLICIT NONE
!------------------------------------------------------------------------------
    TYPE(Model_t)  :: Model
    TYPE(Solver_t), TARGET :: Solver
    LOGICAL ::  TransientSimulation
    REAL(KIND=dp) :: dt
!------------------------------------------------------------------------------
    LOGICAL :: Found, Calculate
    TYPE(ValueList_t), POINTER :: Params
    CHARACTER(LEN=MAX_NAME_LEN) :: VariableName
    INTEGER :: dim

    Params => GetSolverParams()
    dim = CoordinateSystemDimension()

    IF (ListGetLogical(Params,'Calculate Electric Energy',Found)) &
        CALL ListAddString( Params,NextFreeKeyword('Exported Variable ',Params), &
        'Electric Energy Density' )
    
    IF (ListGetLogical(Params,'Calculate Surface Charge',Found)) &
        CALL ListAddString( Params,NextFreeKeyword('Exported Variable ',Params), &
        'Surface Charge Density' )
    
    Calculate = ListGetLogical(Params,'Calculate Electric Field',Found)
!    IF(.NOT. Found) Calculate = .TRUE.
    IF( Calculate ) THEN
      IF( Dim == 2 ) THEN
        CALL ListAddString( Params,NextFreeKeyword('Exported Variable ',Params), &
            '-dofs 2 Electric Field' )
      ELSE
        CALL ListAddString( Params,NextFreeKeyword('Exported Variable ',Params), &
            '-dofs 3 Electric Field' )
      END IF
    END IF
    
    Calculate = ListGetLogical(Params,'Calculate Electric Flux',Found)
!    IF(.NOT. Found) Calculate = .TRUE.
    IF( Calculate ) THEN
      IF( Dim == 2 ) THEN
        CALL ListAddString( Params,NextFreeKeyword('Exported Variable ',Params), &
            '-dofs 2 Electric Flux' )
      ELSE
        CALL ListAddString( Params,NextFreeKeyword('Exported Variable ',Params), &
            '-dofs 3 Electric Flux' )
      END IF
    END IF

!------------------------------------------------------------------------------
END SUBROUTINE StatElecSolver_Init
!------------------------------------------------------------------------------





SUBROUTINE StatElecSolver( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
!******************************************************************************
!
!  Solve the Poisson equation for the electric potential and compute the 
!  electric field, flux, energy and capacitance
!
!  NOTE: The permittivity of vacuum is divided into the right hand side of the 
!        equation. This has to be accounted for in setting the body forces and
!        assigning flux boundary conditions
!
!
!  ARGUMENTS:
!
!  TYPE(Model_t) :: Model,  
!     INPUT: All model information (mesh, materials, BCs, etc...)
!
!  TYPE(Solver_t) :: Solver
!     INPUT: Linear equation solver options
!
!  DOUBLE PRECISION :: dt,
!     INPUT: Timestep size for time dependent simulations
!
!  LOGICAL :: TransientSimulation
!     INPUT: Steady state or transient simulation
!
!******************************************************************************

  USE Types
  USE Lists 
  USE Integration
  USE ElementDescription
  USE Differentials
  USE SolverUtils
  USE ElementUtils
  USE Adaptive
  USE DefUtils
  
  IMPLICIT NONE
!------------------------------------------------------------------------------
 
  TYPE(Model_t) :: Model
  TYPE(Solver_t), TARGET:: Solver
  REAL (KIND=DP) :: dt
  LOGICAL :: TransientSimulation
      
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------
  TYPE(Matrix_t), POINTER  :: StiffMatrix
  TYPE(Element_t), POINTER :: CurrentElement
  TYPE(Variable_t), POINTER :: TimeVar, Var
  TYPE(Nodes_t) :: ElementNodes
  
  REAL (KIND=DP), POINTER :: ForceVector(:), Potential(:), Displacement(:,:)
  REAL (KIND=DP), POINTER :: Field(:),Flux(:),Energy(:)
  REAL (KIND=dp), POINTER :: SurfaceCharge(:), PValues(:),Charges(:)
  REAL (KIND=DP), POINTER :: Pwrk(:,:,:), Pz_w(:,:,:)
  REAL (KIND=DP), ALLOCATABLE :: CapMatrix(:,:)
  REAL (KIND=DP), ALLOCATABLE ::  Permittivity(:,:,:), PiezoCoeff(:,:,:), &
      LocalStiffMatrix(:,:), Load(:), LocalForce(:), PotDiff(:)
  
  REAL(KIND=dp) :: Alpha, Beta, LayerH, Voltage, RelPerm1, RelPerm2
  REAL(KIND=dp) :: PermittivityOfVacuum, Norm, RelativeChange
  
  REAL (KIND=DP) :: Wetot, at0, RealTime, ss
  REAL (KIND=DP) :: at, st, CPUTime, PotentialDifference, Capacitance
  REAL (KIND=DP) :: MinPotential, MaxPotential
  
  INTEGER, POINTER :: NodeIndexes(:), CapBodyIndex(:), Ivals(:)
  INTEGER, POINTER :: PotentialPerm(:), EnergyPerm(:), SurfPerm(:)
  INTEGER, POINTER :: FieldPerm(:), FluxPerm(:)
  INTEGER :: CapBodies, CapBody, Permi, Permj, iter, MaxIterations
  INTEGER :: i, j, k, l, m, n, t, istat, bf_id, LocalNodes, DIM, NonlinearIter
  
  LOGICAL :: AllocationsDone = .FALSE., gotIt, FluxBC
  LOGICAL :: CalculateField, CalculateFlux, CalculateEnergy
  LOGICAL :: CalculateCapMatrix, ConstantWeights
  LOGICAL :: PiezoMaterial, CalculateSurfCharge, SaveBulk, ConstantBulk

  TYPE(Matrix_t), POINTER :: CM
  LOGICAL, ALLOCATABLE :: Done(:)
  
  CHARACTER(LEN=MAX_NAME_LEN) :: EquationName, CapMatrixFile, Name
  TYPE(ValueList_t), POINTER :: Params 
  
  SAVE LocalStiffMatrix, Load, LocalForce, Pwrk, PotDiff, &
      ElementNodes, CalculateFlux, CalculateEnergy, &
      AllocationsDone, Permittivity, &
      CapBodies, CalculateCapMatrix, CapBodyIndex, &
      CapMatrix, CalculateField, CapMatrixFile, ConstantWeights, &
      PiezoCoeff, PiezoMaterial, Displacement, Pz_w, CalculateSurfCharge, &
      ConstantBulk
  
  
  INTERFACE
    FUNCTION ElectricBoundaryResidual( Model,Edge,Mesh,Quant,Perm,Gnorm ) RESULT(Indicator)
      USE Types
      TYPE(Element_t), POINTER :: Edge
      TYPE(Model_t) :: Model
      TYPE(Mesh_t), POINTER :: Mesh
      REAL(KIND=dp) :: Quant(:), Indicator(2), Gnorm
      INTEGER :: Perm(:)
    END FUNCTION ElectricBoundaryResidual
    
    FUNCTION ElectricEdgeResidual( Model,Edge,Mesh,Quant,Perm ) RESULT(Indicator)
      USE Types
      TYPE(Element_t), POINTER :: Edge
      TYPE(Model_t) :: Model
      TYPE(Mesh_t), POINTER :: Mesh
      REAL(KIND=dp) :: Quant(:), Indicator(2)
      INTEGER :: Perm(:)
    END FUNCTION ElectricEdgeResidual
    
    FUNCTION ElectricInsideResidual( Model,Element,Mesh,Quant,Perm, Fnorm ) RESULT(Indicator)
      USE Types
      TYPE(Element_t), POINTER :: Element
      TYPE(Model_t) :: Model
      TYPE(Mesh_t), POINTER :: Mesh
      REAL(KIND=dp) :: Quant(:), Indicator(2), Fnorm
      INTEGER :: Perm(:)
    END FUNCTION ElectricInsideResidual
  END INTERFACE
  
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
!    Get variables needed for solution
!------------------------------------------------------------------------------

  Params => GetSolverParams()

  Potential     => Solver % Variable % Values
  PotentialPerm => Solver % Variable % Perm
  
  StiffMatrix => Solver % Matrix
  ForceVector => StiffMatrix % RHS
  
  Norm = Solver % Variable % Norm
  DIM = CoordinateSystemDimension()

!------------------------------------------------------------------------------
!    Allocate some permanent storage, this is done first time only
!------------------------------------------------------------------------------
  IF ( .NOT. AllocationsDone ) THEN
    N = Model % MaxElementNodes
    
    ALLOCATE( ElementNodes % x(N),   &
        ElementNodes % y(N),   &
        ElementNodes % z(N),   &
        Permittivity(3,3,N),       &
        LocalForce(N),         &
        LocalStiffMatrix(N,N), &
        Load(N),               &
        PotDiff(N),            &
        Displacement(N,Dim),            &
        STAT=istat )
    
    IF ( istat /= 0 ) THEN
      CALL Fatal( 'StatElecSolve', 'Memory allocation error 1' )
    END IF
    
    ALLOCATE( PiezoCoeff(DIM,2*DIM,N), STAT=istat )
    IF ( istat /= 0 ) THEN
      CALL Fatal( 'StatElecSolve', 'Memory allocation error 2' )
    END IF
    
    CalculateField = ListGetLogical( Params, &
        'Calculate Electric Field', GotIt )
!    IF ( .NOT. GotIt )  CalculateField = .TRUE.
    
    CalculateFlux = ListGetLogical( Params, &
        'Calculate Electric Flux', GotIt )
!    IF ( .NOT. GotIt )  CalculateFlux = .TRUE.
    
    CalculateEnergy = ListGetLogical( Params, &
        'Calculate Electric Energy', GotIt )
     
    CalculateSurfCharge = GetLogical( Params, &
        'Calculate Surface Charge', GotIt )

    ConstantBulk = ListGetLogical( Params,'Save Bulk System',GotIt)
    SaveBulk = ConstantBulk .OR. ListGetLogical( Params,'Save Bulk System',GotIt)

    ConstantWeights = ListGetLogical( Params,'Constant Weights', GotIt )

    DO i = 1, Model % NumberOfEquations 
      CalculateCapMatrix = ListGetLogical( Model % Equations(i) % Values, &
          'Calculate Capacitance Matrix', GotIt )
      IF ( GotIt ) EXIT
    END DO
    IF ( .NOT. GotIt )  CalculateCapMatrix = ListGetLogical( Params, &
        'Calculate Capacitance Matrix', GotIt )
        
    IF(CalculateCapMatrix) THEN
      SaveBulk = .TRUE.
      ConstantBulk = .TRUE.
      CapBodies = ListGetInteger( Params, 'Capacitance Bodies',GotIt)
      IF(.NOT. GotIt) THEN
        DO i = 1, Model % NumberOfBCs
          j = ListGetInteger( Model % BCs(i) % Values, &
            'Capacitance Body', GotIt )
          IF( j > CapBodies ) CapBodies = j
        END DO
      END IF	

      CapMatrixFile = ListGetString(Params,'Capacitance Matrix Filename',GotIt )
      IF(.NOT. GotIt) CapMatrixFile = 'cmatrix.dat'
      
      ALLOCATE(CapBodyIndex(Model % NumberOfNodes), &
          Charges(Model % NumberOfNodes), &
          CapMatrix(CapBodies,CapBodies), &
          STAT = istat)
      IF ( istat /= 0 ) THEN
        CALL Fatal( 'StatElecSolve', 'Memory allocation error 3' )
      END IF
      
      CapMatrix = 0.0d0
      CapBodyIndex = 0
    END IF

    IF ( .NOT.ASSOCIATED( StiffMatrix % MassValues ) ) THEN
      ALLOCATE( StiffMatrix % Massvalues( Model % NumberOfNodes ) )
      StiffMatrix % MassValues = 0.0d0
    END IF

    NULLIFY( Pwrk )
    NULLIFY( Pz_w )
    
    AllocationsDone = .TRUE.
  END IF

!------------------------------------------------------------------------------
!  Get the result fields
!  These should have been automatically created by the 
!  'Exported Variables' defined in the _init section
!------------------------------------------------------------------------------

  IF ( CalculateField ) THEN
    Var => VariableGet( Solver % Mesh % Variables,'Electric Field')
    IF( ASSOCIATED( Var) ) THEN
      Field => Var % Values
    ELSE
      CALL Fatal('StatElecSolver','Electric Field does not exist')
    END IF
  END IF
  
  IF ( CalculateFlux ) THEN
    Var => VariableGet( Solver % Mesh % Variables,'Electric Flux')
    IF( ASSOCIATED( Var ) ) THEN
      Flux => Var % Values
    ELSE
      CALL Fatal('StatElecSolver','Electric Flux does not exist')
    END IF
  END IF

  IF ( CalculateEnergy ) THEN
    Var => VariableGet( Solver % Mesh % Variables,'Electric Energy Density')
    IF( ASSOCIATED( Var ) ) THEN    
      Energy => Var % Values
    ELSE
      CALL Fatal('StatElecSolver','Electric Energy Density does not exist')
    END IF
  END IF

  IF ( CalculateSurfCharge ) THEN
    Var => VariableGet( Solver % Mesh % Variables,'Surface Charge Density')
    IF( ASSOCIATED( Var ) ) THEN    
      SurfaceCharge => Var % Values
    ELSE
      CALL Fatal('StatElecSolver','Surface Charge Density does not exist')
    END IF
  END IF
   

!------------------------------------------------------------------------------
!    Do some additional initialization, and go for it
!------------------------------------------------------------------------------

  PermittivityOfVacuum = ListGetConstReal( Model % Constants, &
      'Permittivity Of Vacuum',gotIt )
  IF ( .NOT.gotIt ) PermittivityOfVacuum = 1.0d0
  
  NonlinearIter = ListGetInteger( Params, &
      'Nonlinear System Max Iterations', GotIt )
  IF ( .NOT. GotIt ) NonlinearIter = 1
 
  IF(CalculateCapMatrix) NonlinearIter = CapBodies

  EquationName = ListGetString( Params, 'Equation' )
  Norm = Solver % Variable % Norm
  
  at  = CPUTime()
  at0 = RealTime()
  CALL InitializeToZero( StiffMatrix, ForceVector )
!------------------------------------------------------------------------------
  CALL Info( 'StatElecSolve', '-------------------------------------',Level=4 )
  CALL Info( 'StatElecSolve', 'STATELEC SOLVER:  ', Level=4 )
  CALL Info( 'StatElecSolve', '-------------------------------------',Level=4 )

  DO iter = 1, NonlinearIter

     IF ( NonlinearIter > 1 ) THEN
        WRITE( Message, '(a,I4)' ) 'Electrostatic iteration', iter
        CALL Info( 'StatElecSolve', ' ', LEVEL=4 )
        CALL Info( 'StatElecSolve', Message, LEVEL=4 )
     END IF
     CALL Info( 'StatElecSolve', 'Starting Assembly...', Level=4 )

!------------------------------------------------------------------------------
!    Do the assembly
!------------------------------------------------------------------------------

    IF ( ConstantBulk .AND. ASSOCIATED(Solver % Matrix % BulkValues) ) THEN
      Solver % Matrix % RHS = Solver % Matrix % BulkRHS
      Solver % Matrix % Values = Solver % Matrix % BulkValues
      GOTO 1000
    END IF
    
    DO t = 1, Solver % NumberOfActiveElements
      
      IF ( RealTime() - at0 > 1.0 ) THEN
        WRITE(Message,'(a,i3,a)' ) '   Assembly: ', INT(100.0 - 100.0 * &
            (Solver % Mesh % NumberOfBulkElements-t) / &
            (1.0*Solver % Mesh % NumberOfBulkElements)), ' % done'          
        CALL Info( 'StatElecSolve', Message, Level=5 )          
        at0 = RealTime()
      END IF
      
!------------------------------------------------------------------------------
!        Check if this element belongs to a body where potential
!        should be calculated
!------------------------------------------------------------------------------

      CurrentElement => GetActiveElement(t)
      NodeIndexes => CurrentElement % NodeIndexes
      n = CurrentElement % TYPE % NumberOfNodes
      
      ElementNodes % x(1:n) = Solver % Mesh % Nodes % x(NodeIndexes)
      ElementNodes % y(1:n) = Solver % Mesh % Nodes % y(NodeIndexes)
      ElementNodes % z(1:n) = Solver % Mesh % Nodes % z(NodeIndexes)
!------------------------------------------------------------------------------

      bf_id = ListGetInteger( Model % Bodies(CurrentElement % BodyId) % &
          Values, 'Body Force',gotIt, minv=1, maxv=Model % NumberOfBodyForces )
      
      Load  = 0.0d0
      PiezoMaterial = .FALSE.
      IF ( gotIt ) THEN
        Load(1:n) = ListGetReal( Model % BodyForces(bf_id) % Values, &
            'Source',n,NodeIndexes, gotIt )
        IF ( .NOT. gotIt )  Load(1:n) = &
            ListGetReal( Model % BodyForces(bf_id) % Values, &
            'Charge Density', n, NodeIndexes, GotIt )
        
        Load(1:n) = Load(1:n) / PermittivityOfVacuum
        
        IF ( GetLogical( Model % BodyForces(bf_id) % Values, 'Piezo Material', &
            GotIt ) )  PiezoMaterial = .TRUE.
      END IF
      
      k = ListGetInteger( Model % Bodies(CurrentElement % BodyId) % &
          Values, 'Material', minv=1, maxv=Model % NumberOfMaterials )
      
!------------------------------------------------------------------------------
!      Read permittivity values (might be a tensor)
!------------------------------------------------------------------------------
      
      CALL ListGetRealArray( Model % Materials(k) % Values, &
          'Relative Permittivity', Pwrk,n,NodeIndexes, gotIt )
      IF ( .NOT. gotIt ) &
          CALL ListGetRealArray( Model % Materials(k) % Values, &
          'Permittivity', Pwrk, n, NodeIndexes, gotIt )
      
      IF ( .NOT. gotIt ) CALL Fatal( 'StatElecSolve', &
          'No relative permittivity found' )
      
      Permittivity = 0.0d0
      IF ( SIZE(Pwrk,1) == 1 ) THEN
        DO i=1,3
          Permittivity( i,i,1:n ) = Pwrk( 1,1,1:n )
        END DO
      ELSE IF ( SIZE(Pwrk,2) == 1 ) THEN
        DO i=1,MIN(3,SIZE(Pwrk,1))
          Permittivity(i,i,1:n) = Pwrk(i,1,1:n)
        END DO
      ELSE
        DO i=1,MIN(3,SIZE(Pwrk,1))
          DO j=1,MIN(3,SIZE(Pwrk,2))
            Permittivity( i,j,1:n ) = Pwrk(i,j,1:n)
          END DO
        END DO
      END IF
      
!------------------------------------------------------------------------------
!      Read piezo material coefficients if applicable
!------------------------------------------------------------------------------
      IF ( PiezoMaterial ) THEN
        PiezoCoeff = 0.0d0
        CALL GetRealArray( Model % Materials(k) % Values, Pz_w, &
            'Piezo Material Coefficients', gotIt, CurrentElement )
        IF ( .NOT. GotIt )  CALL Fatal( 'StatElecSolve', &
            'No Piezo Material Coefficients defined' )
        
        DO i=1, Dim
          DO j=1, 2*Dim
            PiezoCoeff( i,j,1:n ) = Pz_w(i,j,1:n)
          END DO
        END DO
!------------------------------------------------------------------------------
!      Read also the local displacement
!------------------------------------------------------------------------------         
        Displacement = 0.0d0
        NULLIFY (Var)
        Var => VariableGet( Model % Variables, 'Displacement' )
        IF ( .NOT. ASSOCIATED( Var ) )  CALL Fatal('StatElecSolve', &
            'No displacements' )
        
        DO i = 1, Var % DOFs
          Displacement(1:n,i) = &
              Var % Values( Var % DOFs * ( Var % Perm( NodeIndexes ) - 1 ) + i )
        END DO
      END IF
       
!------------------------------------------------------------------------------
!      Get element local matrix, and rhs vector
!------------------------------------------------------------------------------
      CALL StatElecCompose( LocalStiffMatrix,LocalForce, PiezoMaterial, &
          PiezoCoeff, Permittivity,Load,CurrentElement,n,ElementNodes, &
          Displacement )

!------------------------------------------------------------------------------
!      Update global matrix and rhs vector from local matrix & vector
!------------------------------------------------------------------------------
      CALL DefaultUpdateEquations( LocalStiffMatrix,LocalForce, BulkUpdate = SaveBulk )

!------------------------------------------------------------------------------
    END DO
    
!------------------------------------------------------------------------------
!     Neumann boundary conditions
!------------------------------------------------------------------------------


1000 CONTINUE

    CM => Solver % Matrix % ConstraintMatrix
    IF (ASSOCIATED(CM) ) THEN
      CM % Values = 0._dp
      IF ( .NOT. CM % Ordered ) CALL CRS_SortMatrix(CM)

      ALLOCATE( Done(Solver % Mesh % NumberOfNodes) )
      Done = .FALSE.

      Ivals => ListGetIntegerArray( Params, &
             'Constraint DOF 1 Body', Gotit )
      IF ( .NOT. ASSOCIATED(Ivals) ) CYCLE

      Solver % Matrix % ConstraintMatrix % RHS(1) = &
        GetCReal( Params, 'Constraint DOF 1 Value', GotIt )

      DO i=1,GetNOFBoundaryElements()
        CurrentElement => GetBoundaryElement(i)
        IF ( .NOT.ActiveBoundaryElement() ) CYCLE
    
        j = -1
        IF ( ASSOCIATED(CurrentElement % BoundaryInfo % Left) ) &
          j = CurrentElement % BoundaryInfo % Left % BodyId

        k = -1
        IF ( ASSOCIATED(CurrentElement % BoundaryInfo % Right) ) &
          k = CurrentElement % BoundaryInfo % Right % BodyId

        IF ( ANY(Ivals==j.OR.Ivals==k) ) THEN
          NodeIndexes => CurrentElement % NodeIndexes
          DO j=1,GetElementNOFNodes()
            l = PotentialPerm(NodeIndexes(j))
            IF ( Done(l) ) CYCLE
            Done(l) = .TRUE.
            CM % RHS(1) = CM % RHS(1)+Solver % Matrix % RHS(l)
            m = CM % Rows(1)
            DO k=Solver % Matrix % Rows(l),Solver % Matrix % Rows(l+1)-1
              DO WHILE(m<CM % Rows(2))
                IF ( CM % Cols(m)>=Solver % Matrix % Cols(k) ) EXIT
                m = m+1  
              END DO
              IF ( m>=CM % Rows(2) ) EXIT
              IF ( CM % Cols(m) == Solver % Matrix % Cols(k) ) &
                CM % Values(m) = CM % Values(m)+Solver % Matrix % Values(k)
            END DO
          END DO
        END IF
      END DO
      DEALLOCATE(Done)
    END IF
    
    MinPotential = HUGE(MinPotential)
    MaxPotential = -HUGE(MaxPotential)


    DO t=Solver % Mesh % NumberOfBulkElements + 1, &
        Solver % Mesh % NumberOfBulkElements + &
        Solver % Mesh % NumberOfBoundaryElements
      
      CurrentElement => Solver % Mesh % Elements(t)
!------------------------------------------------------------------------------
      DO i=1,Model % NumberOfBCs
        IF ( CurrentElement % BoundaryInfo % Constraint == &
            Model % BCs(i) % Tag ) THEN
          
!------------------------------------------------------------------------------
!             Set the current element pointer in the model structure to
!             reflect the element being processed
!------------------------------------------------------------------------------
          Model % CurrentElement => Solver % Mesh % Elements(t)
          n = CurrentElement % TYPE % NumberOfNodes
          NodeIndexes => CurrentElement % NodeIndexes
          IF ( ANY( PotentialPerm(NodeIndexes) <= 0 ) ) CYCLE
         
!------------------------------------------------------------------------------
!         Memorize the min and max potential as given by Dirichtlet BCs
!------------------------------------------------------------------------------          
          Load(1:n) = ListGetReal(Model % BCs(i) % Values, &
             ComponentName(Solver % Variable), n, NodeIndexes, gotIt)
          IF(GotIt) THEN
            MinPotential = MIN(MinPotential, MINVAL(Load(1:n)))
            MaxPotential = MAX(MaxPotential, MAXVAL(Load(1:n)))             
          END IF
          
!------------------------------------------------------------------------------
!       the element type 101 (point element) can only be used
!       to set Dirichlet BCs, so skip em.
!------------------------------------------------------------------------------
          IF ( CurrentElement % TYPE % ElementCode == 101 ) CYCLE

          FluxBC = ListGetLogical(Model % BCs(i) % Values, &
              'Electric Flux BC',gotIt)
          IF( gotIt .AND. .NOT. FluxBC) CYCLE
          
          ElementNodes % x(1:n) = Solver % Mesh % Nodes % x(NodeIndexes)
          ElementNodes % y(1:n) = Solver % Mesh % Nodes % y(NodeIndexes)
          ElementNodes % z(1:n) = Solver % Mesh % Nodes % z(NodeIndexes)
          
!------------------------------------------------------------------------------
!             BC: epsilon@Phi/@n = g
!------------------------------------------------------------------------------
          Load = 0.0d0
          Load(1:n) = ListGetReal( Model % BCs(i) % Values,'Electric Flux', &
              n,NodeIndexes,GotIt )
          IF ( .NOT. GotIt )  Load(1:n) = ListGetReal( Model % BCs(i) % Values, &
              'Surface Charge Density', n,NodeIndexes,gotIt )
          IF(GotIt) THEN
            FluxBC = .TRUE.
            Load(1:n) = Load(1:n) / PermittivityOfVacuum
          END IF

!------------------------------------------------------------------------------
!             BC: -epsilon@Phi/@n = -alpha Phi + beta
!------------------------------------------------------------------------------
          Alpha = 0.0d0
          Beta = 0.0d0
          
          Alpha = GetConstReal( Model % BCs(i) % Values, & 
              'Layer Relative Permittivity', gotit )
          IF(GotIt .OR. FluxBC) THEN
            IF ( Gotit ) THEN
              LayerH = GetConstReal( Model % BCs(i) % Values, &
                  'Layer Thickness', gotit )
              IF ( (.NOT. gotit) .OR. LayerH < 1e-12 ) THEN
                CALL Warn( 'StatElecSolve', &
                    'Charge layer thickness not given or too small. Using 1e-8 m')
                LayerH = 1e-8
              END IF
              Alpha = Alpha / LayerH
            
              Voltage = GetConstReal( Model % BCs(i) % Values, &
                  'Electrode Potential', gotit )
              Beta = GetConstReal( Model % BCs(i) % Values, &
                  'Layer Charge Density', gotit )
              Beta = Alpha*Voltage + 0.5d0*Beta*LayerH / PermittivityOfVacuum            
            END IF
          
!------------------------------------------------------------------------------
!             Get element matrix and rhs due to boundary conditions ...
!------------------------------------------------------------------------------
            CALL StatElecBoundary( LocalStiffMatrix, LocalForce,  &
                Load, Alpha, Beta, CurrentElement, n, ElementNodes )
!------------------------------------------------------------------------------
!             Update global matrices from local matrices
!------------------------------------------------------------------------------
            CALL UpdateGlobalEquations( StiffMatrix, LocalStiffMatrix, &
                ForceVector, LocalForce, n, 1, PotentialPerm(NodeIndexes) )
          END IF
!------------------------------------------------------------------------------

        END IF ! of currentelement bc == bcs(i)
      END DO ! of i=1,model bcs
    END DO   ! Neumann BCs
!------------------------------------------------------------------------------

    CALL SetNodalLoads( Model,StiffMatrix,ForceVector, &
        Componentname(Solver % Variable),1,1,PotentialPerm )       

!------------------------------------------------------------------------------
!    FinishAssembly must be called after all other assembly steps, but before
!    Dirichlet boundary settings. Actually no need to call it except for
!    transient simulations.
!------------------------------------------------------------------------------
    CALL FinishAssembly( Solver,ForceVector )
!------------------------------------------------------------------------------
!    Dirichlet boundary conditions
!------------------------------------------------------------------------------
    CALL SetDirichletBoundaries( Model,StiffMatrix,ForceVector, &
        ComponentName(Solver % Variable),1,1,PotentialPerm )       
   
    IF(CalculateCapMatrix) THEN 
      CALL SetPermutationBoundaries( Model, StiffMatrix, ForceVector, &
          'Capacitance Body',PotentialPerm, iter)
    END IF

    at = CPUTime() - at
    WRITE( Message, * ) 'Assembly (s)          :',at
    CALL Info( 'StatElecSolve', Message, Level=4 )
!------------------------------------------------------------------------------
!    Solve the system and we are done.
!------------------------------------------------------------------------------
    st = CPUTime()
!    CALL SolveSystem( StiffMatrix, ParMatrix, ForceVector, &
!        Potential, Norm, 1, Solver )

    Norm = DefaultSolve()
    RelativeChange = Solver % Variable % NonlinChange
    st = CPUTime() - st
    WRITE( Message, * ) 'Solve (s)             :',st
    CALL Info( 'StatElecSolve', Message, Level=4 )

!------------------------------------------------------------------------------
!    Compute the electric field from the potential: E = -grad Phi
!    Compute the electric flux: D = epsilon (-grad Phi)
!    Compute the total electric energy: W_e,tot = Integral (E . D)dV
!------------------------------------------------------------------------------

    IF ( CalculateField .OR. CalculateFlux .OR. CalculateEnergy &
        .OR. CalculateSurfCharge ) THEN 
      CALL GeneralElectricFlux( Model, Potential, PotentialPerm )
    END IF

    IF ( CalculateEnergy ) THEN
      WRITE( Message, * ) 'Tot. Electric Energy  :', Wetot
      CALL Info( 'StatElecSolve', Message, Level=4 )
      CALL ListAddConstReal( Model % Simulation, &
          'RES: Electric Energy', Wetot )
    END IF

!------------------------------------------------------------------------------
!    Try to find a potential difference for scalar capacitance calculation
!------------------------------------------------------------------------------

    IF ( .NOT. CalculateCapMatrix ) THEN      
      PotentialDifference = ListGetConstReal( Params, &
           'Potential Difference',gotIt )
      IF ( .NOT.gotIt )  PotentialDifference = ListGetConstReal( &
          Model % Simulation, 'Potential Difference',gotIt )
      IF ( .NOT. gotIt ) THEN
        DO i = 1, Model % NumberOfMaterials
          PotentialDifference = &
              ListGetConstReal( Model % Materials(i) % Values, &
              'Potential Difference', GotIt )
          IF ( GotIt )  EXIT
        END DO
      END IF
      
      IF(.NOT. GotIt) THEN
        PotentialDifference = MaxPotential - MinPotential
      END IF
      
      IF(PotentialDifference > TINY(PotentialDifference)) THEN
        CALL ListAddConstReal( Model % Simulation, &
            'RES: Potential Difference', PotentialDifference )
        
        IF(CalculateEnergy) THEN
          Capacitance = 2*Wetot / (PotentialDifference*PotentialDifference)
          WRITE( Message,* ) 'Potential difference: ',PotentialDifference
          CALL Info( 'StatElecSolve', Message, Level=8 )
          
          WRITE( Message, * ) 'Capacitance           :', Capacitance
          CALL Info( 'StatElecSolve', Message, Level=4 )
          
          CALL ListAddConstReal( Model % Simulation, &
              'res: Capacitance', Capacitance )
        END IF
      END IF
    END IF
    
!------------------------------------------------------------------------------

    IF(CalculateCapMatrix) THEN
      PValues => Solver % Matrix % Values
      Solver % Matrix % Values => Solver % Matrix % BulkValues
      CALL MatrixVectorMultiply( Solver % Matrix, Potential, Charges)
      Solver % Matrix % Values => PValues
      Charges = Charges * PermittivityOfVacuum
      
      Permi = iter
      DO i=1,Model % NumberOfNodes
        Permj = CapBodyIndex(i)
        IF(Permj > 0) THEN
          j = PotentialPerm(i)
          CapMatrix(Permi, Permj) = CapMatrix(Permi, Permj) + Charges(j)
        END IF
      END DO
      DO Permj = 1, CapBodies
        IF(Permi == Permj) CYCLE
        CapMatrix(Permi, Permi) = CapMatrix(Permi, Permi) + CapMatrix(Permi, Permj)
        CapMatrix(Permi, Permj) = -CapMatrix(Permi, Permj)
      END DO
    END IF
   

     
     IF (.NOT. CalculateCapMatrix) THEN
       WRITE( Message, * ) 'Result Norm   : ',Norm
       CALL Info( 'StatElecSolve', Message, Level=4 )
       WRITE( Message, * ) 'Relative Change : ',RelativeChange
       CALL Info( 'StatElecSolve', Message, Level=4 )       
       CALL Info( 'StatElecSolve', ' ', Level=4 )       
	
       IF( Solver % Variable % NonlinConverged == 1 ) EXIT
     END IF

   END DO
   
   IF(CalculateCapMatrix) THEN
     ! Symmetrisize
     CapMatrix = 0.5d0 * (CapMatrix + TRANSPOSE(CapMatrix))
     
     CALL Info('StatElecSolve','Capacitance matrix computation performed (i,j,C_ij)',Level=4)
     DO i=1, CapBodies 
       DO j = i, CapBodies
         WRITE( Message, '(I3,I3,ES15.5)' ) i,j,CapMatrix(i,j)
         CALL Info( 'StatElecSolve', Message, Level=4 )
       END DO
     END DO
    
     OPEN (10, FILE=CapMatrixFile)
     DO i=1,CapBodies
       DO j=1,CapBodies
         WRITE (10,'(ES17.9)',advance='no') CapMatrix(i,j)
       END DO
       WRITE(10,'(A)') ' '
     END DO
     CLOSE(10)
     
     WRITE(Message,'(A,A)') 'Capacitance matrix was saved to file ',CapMatrixFile
     CALL Info('StatElecSolve',Message)
   END IF
   

   IF ( ListGetLogical( Params, 'Adaptive Mesh Refinement', GotIt ) ) &
       CALL RefineMesh( Model, Solver, Potential, PotentialPerm, &
       ElectricInsideResidual, ElectricEdgeResidual, ElectricBoundaryResidual )
   
   CALL InvalidateVariable( Model % Meshes, Solver % Mesh, 'Potential')
   IF ( CalculateField ) THEN
     CALL InvalidateVariable( Model % Meshes, Solver % Mesh, 'Electric Field')
   END IF
   
   IF ( CalculateFlux ) THEN
     CALL InvalidateVariable( Model % Meshes, Solver % Mesh, 'Electric Flux')
   END IF
   
   IF ( CalculateEnergy ) THEN
     CALL InvalidateVariable( Model % Meshes, Solver % Mesh, 'Electric Energy Density')
   END IF
   
   IF ( CalculateSurfCharge ) THEN
     CALL InvalidateVariable( Model % Meshes, Solver % Mesh, 'Surface Charge Density' )
   END IF


!------------------------------------------------------------------------------
 
   CONTAINS

!------------------------------------------------------------------------------
   SUBROUTINE TotalChargeBC(F,Element,n,Nodes)
!------------------------------------------------------------------------------
     TYPE(Nodes_t) :: Nodes
     INTEGER :: n
     REAL(KIND=dp) :: F(:)
     TYPE(Element_t), POINTER :: Element
!------------------------------------------------------------------------------
     TYPE(GaussIntegrationPoints_t) :: IntegStuff
     INTEGER :: i, j, pn
     LOGICAL :: stat
     TYPE(Nodes_t), SAVE :: Pnodes
     TYPE(Element_t), POINTER ::  Parent
     REAL(KIND=dp) :: s,u,v,w,detJ,pdetJ,pBasis(10),Basis(10),dBasisdx(10,3),Normal(3)

     Parent => Element % BoundaryInfo % Left
     CALL GetElementNodes( PNodes, Parent )
     pn = Parent % TYPE % NumberOfNodes

     IntegStuff = GaussPoints(Element)

     F = 0._dp
     DO i=1,IntegStuff % N
       u = IntegStuff % u(i)
       v = IntegStuff % v(i)
       w = IntegStuff % w(i)
       Normal = NormalVector(Element,Nodes,u,v,.TRUE.)
       stat = ElementInfo(Element,Nodes,u,v,w,detJ,Basis )
       CALL GetParentUVW( Element,n,Parent,pn,u,v,w,Basis )
       stat = ElementInfo(Parent,PNodes,u,v,w,pdetJ,Basis,dBasisdx )
       DO j=1,3
         F(1:pn) = F(1:pn) - IntegStuff % s(i) * detJ * &
               dBasisdx(1:pn,j)  * Normal(j)
       END DO
     END DO
     
!------------------------------------------------------------------------------
   END SUBROUTINE TotalChargeBC
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
! Compute the Electric Flux, Electric Field and Electric Energy at model nodes
!------------------------------------------------------------------------------
  SUBROUTINE GeneralElectricFlux( Model, Potential, Reorder )
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    REAL(KIND=dp) :: Potential(:)
    INTEGER :: Reorder(:)
!------------------------------------------------------------------------------
    TYPE(Element_t), POINTER :: Element, Parent
    TYPE(Nodes_t) :: Nodes, BoundaryNodes
    TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

    REAL(KIND=dp), POINTER :: U_Integ(:), V_Integ(:), W_Integ(:), S_Integ(:)
    REAL(KIND=dp), ALLOCATABLE :: SumOfWeights(:), SurfWeights(:), x(:), y(:), z(:)
    REAL(KIND=dp) :: PermittivityOfVacuum
    REAL(KIND=dp) :: Permittivity(3,3,Model % MaxElementNodes)
    REAL(KIND=dp) :: Basis(Model % MaxElementNodes)
    REAL(KIND=dp) :: dBasisdx(Model % MaxElementNodes,3)
    REAL(KIND=dp) :: ParentBasis(Model % MaxElementNodes)
    REAL(KIND=dp) :: ParentdBasisdx(Model % MaxElementNodes,3)
    REAL(KIND=DP) :: SqrtElementMetric, detJ
    REAL(KIND=dp) :: ElementPot(Model % MaxElementNodes)
    REAL(KIND=dp) :: Dirichlet(Model % MaxElementNodes)
    REAL(KIND=dp) :: EnergyDensity, Sigma, Normal(3)
    REAL(KIND=dp) :: NodalFlux(3), NodalField(3), ElemVol
    REAL(KIND=dp) :: s, ug, vg, wg, Grad(3), EpsGrad(3)
    REAL(KIND=dp) :: SqrtMetric, Metric(3,3), Symb(3,3,3), dSymb(3,3,3,3)
    REAL(KIND=dp) :: xpos, ypos, zpos
    INTEGER, POINTER :: NodeIndexes(:)
    INTEGER :: PotIndexes(Model % MaxElementNodes)
    INTEGER :: n, N_Integ, t, tg, i, j, k, DIM, p, nPar, matId
    LOGICAL :: Stat


!------------------------------------------------------------------------------

    ALLOCATE( Nodes % x( Model % MaxElementNodes ) )
    ALLOCATE( Nodes % y( Model % MaxElementNodes ) )
    ALLOCATE( Nodes % z( Model % MaxElementNodes ) )
    ALLOCATE( SumOfWeights( Model % NumberOfNodes ) )

    SumOfWeights = 0.0d0

    Wetot = 0.0d0

    PermittivityOfVacuum = ListGetConstReal( Model % Constants, &
        'Permittivity Of Vacuum',gotIt )
    IF ( .NOT.gotIt ) PermittivityOfVacuum = 1

     DIM = CoordinateSystemDimension()

!------------------------------------------------------------------------------
!   Go through model elements, we will compute on average of elementwise
!   fluxes to nodes of the model
!------------------------------------------------------------------------------
    DO t=1,Model % NumberOfBulkElements
!------------------------------------------------------------------------------
!        Check if this element belongs to a body where electrostatics
!        should be calculated
!------------------------------------------------------------------------------
      Element => Model % Elements(t)
      NodeIndexes => Element % NodeIndexes
      IF ( .NOT. CheckElementEquation( Model, Element, EquationName ) ) CYCLE

      n = Element % TYPE % NumberOfNodes
      PotIndexes(1:n) = Reorder(NodeIndexes(1:n))

      IF ( ANY(PotIndexes(1:n) == 0) ) CYCLE

      ElementPot(1:n) = Potential( PotIndexes(1:n) )

      Nodes % x(1:n) = Model % Nodes % x( NodeIndexes )
      Nodes % y(1:n) = Model % Nodes % y( NodeIndexes )
      Nodes % z(1:n) = Model % Nodes % z( NodeIndexes )

!------------------------------------------------------------------------------
!    Gauss integration stuff
!------------------------------------------------------------------------------
      IntegStuff = GaussPoints( Element )
      U_Integ => IntegStuff % u
      V_Integ => IntegStuff % v
      W_Integ => IntegStuff % w
      S_Integ => IntegStuff % s
      N_Integ =  IntegStuff % n

!------------------------------------------------------------------------------

      k = ListGetInteger( Model % Bodies( Element % BodyId ) % &
               Values, 'Material', minv=1, maxv=Model % NumberOfMaterials )

      CALL ListGetRealArray( Model % Materials(k) % Values, &
          'Relative Permittivity', Pwrk, n, NodeIndexes, gotIt )
      IF ( .NOT. gotIt ) &
          CALL ListGetRealArray( Model % Materials(k) % Values, &
          'Permittivity', Pwrk, n, NodeIndexes, gotIt )
      
      Permittivity = 0.0d0
      IF ( SIZE(Pwrk,1) == 1 ) THEN
        DO i=1,3
          Permittivity( i,i,1:n ) = Pwrk( 1,1,1:n )
        END DO
      ELSE IF ( SIZE(Pwrk,2) == 1 ) THEN
        DO i=1,MIN(3,SIZE(Pwrk,1))
          Permittivity(i,i,1:n) = Pwrk(i,1,1:n)
        END DO
      ELSE
        DO i=1,MIN(3,SIZE(Pwrk,1))
          DO j=1,MIN(3,SIZE(Pwrk,2))
            Permittivity( i,j,1:n ) = Pwrk(i,j,1:n)
          END DO
        END DO
      END IF
      
      EnergyDensity = 0.0d0
      NodalFlux = 0.0d0
      NodalField = 0.0d0
      ElemVol = 0.0d0

!------------------------------------------------------------------------------
! Loop over Gauss integration points
!------------------------------------------------------------------------------
      DO tg=1,N_Integ
        
        ug = U_Integ(tg)
        vg = V_Integ(tg)
        wg = W_Integ(tg)
        
!------------------------------------------------------------------------------
! Need SqrtElementMetric and Basis at the integration point
!------------------------------------------------------------------------------
        stat = ElementInfo( Element, Nodes,ug,vg,wg, &
            SqrtElementMetric,Basis,dBasisdx )
        
!------------------------------------------------------------------------------
!      Coordinatesystem dependent info
!------------------------------------------------------------------------------
        s = 1
        IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
          xpos = SUM( Nodes % x(1:n)*Basis(1:n) )
          ypos = SUM( Nodes % y(1:n)*Basis(1:n) )
          zpos = SUM( Nodes % z(1:n)*Basis(1:n) )
          s = 2*PI
        END IF
        
        CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,xpos,ypos,zpos )
        
        s = s * SqrtMetric * SqrtElementMetric * S_Integ(tg)

!------------------------------------------------------------------------------

        EpsGrad = 0.0d0
        DO j = 1, DIM
          Grad(j) = SUM( dBasisdx(1:n,j) * ElementPot(1:n) )
          DO i = 1, DIM
            EpsGrad(j) = EpsGrad(j) + SUM( Permittivity(j,i,1:n) * &
                 Basis(1:n) ) * SUM( dBasisdx(1:n,i) * ElementPot(1:n) )
          END DO
        END DO
        
        Wetot = Wetot + s * SUM( Grad(1:DIM) * EpsGrad(1:DIM) )
        
        EnergyDensity = EnergyDensity + &
             s * SUM(Grad(1:DIM) * EpsGrad(1:DIM))
        DO j = 1,DIM
          NodalFlux(j) = NodalFlux(j) - EpsGrad(j) * s
          NodalField(j) = NodalField(j) - Grad(j) * s
        END DO

        ElemVol = ElemVol + s
      END DO

!------------------------------------------------------------------------------
!   Weight with element area if required
!------------------------------------------------------------------------------

       IF ( ConstantWeights ) THEN
         EnergyDensity = EnergyDensity / ElemVol
         NodalFlux(1:DIM) = NodalFlux(1:DIM) / ElemVol
         NodalField(1:DIM) = NodalField(1:DIM) / ElemVol
         SumOfWeights( PotIndexes(1:n) ) = &
             SumOfWeights( PotIndexes(1:n) ) + 1
       ELSE
         SumOfWeights( PotIndexes(1:n) )  = &
             SumOfWeights( PotIndexes(1:n) ) + ElemVol
       END IF

!------------------------------------------------------------------------------

       IF(CalculateEnergy) THEN
         Energy( PotIndexes(1:n) ) = Energy( PotIndexes(1:n) ) + EnergyDensity
       END IF
       
      IF(CalculateFlux) THEN
        NodalFlux = NodalFlux * PermittivityOfVacuum
        DO i=1,DIM
          Flux( DIM * ( PotIndexes(1:n)-1) + i ) = &
          Flux( DIM * ( PotIndexes(1:n)-1) + i ) + NodalFlux(i)
        END DO
      END IF

      IF(CalculateField) THEN
        DO i=1,DIM
          Field( DIM * ( PotIndexes(1:n)-1) + i ) = &
          Field( DIM * ( PotIndexes(1:n)-1) + i ) + NodalField(i)
        END DO
      END IF

    END DO
    ! of the bulk elements


    IF ( CalculateSurfCharge ) THEN

       ALLOCATE( BoundaryNodes % x( Model % MaxElementNodes ) )
       ALLOCATE( BoundaryNodes % y( Model % MaxElementNodes ) )
       ALLOCATE( BoundaryNodes % z( Model % MaxElementNodes ) )
       ALLOCATE( x( Model % MaxElementNodes ) )
       ALLOCATE( y( Model % MaxElementNodes ) )
       ALLOCATE( z( Model % MaxElementNodes ) )
       ALLOCATE( SurfWeights( Model % NumberOfNodes ) )

       SurfWeights = 0.0d0
!------------------------------------------------------------------------------
!   Go through boundary elements, we will compute on average of elementwise
!   surface charges on the Dirichlet boundaries
!------------------------------------------------------------------------------
       DO t = Model % NumberOfBulkElements + 1, &
            Model % NumberOfBulkElements + &
            Model % NumberOfBoundaryElements
!------------------------------------------------------------------------------
!        Check if this element belongs to boundary where Dirichlet condition
!          is given
!------------------------------------------------------------------------------
          Element => Model % Elements(t)
          NodeIndexes => Element % NodeIndexes

          IF ( Element % TYPE % ElementCode == 101 ) CYCLE
          IF ( ANY(Reorder(NodeIndexes) == 0) ) CYCLE

          DO k=1, Model % NumberOfBCs
             IF ( Model % BCs(k) % Tag /= Element % BoundaryInfo % Constraint ) CYCLE

             n = Element % TYPE % NumberOfNodes
             
             Dirichlet(1:n) = GetReal( Model % BCs(k) % Values, & 
                   ComponentName(Solver % Variable), GotIt,  Element )
             IF ( .NOT. GotIt )  CYCLE

             BoundaryNodes % x(1:n) = Model % Nodes % x( NodeIndexes )
             BoundaryNodes % y(1:n) = Model % Nodes % y( NodeIndexes )
             BoundaryNodes % z(1:n) = Model % Nodes % z( NodeIndexes )

             Parent => Element % BoundaryInfo % Left

             stat = .FALSE.
             IF ( ASSOCIATED( Parent ) ) THEN
                nPar = Parent % TYPE % NumberOfNodes
                stat = ALL( PotentialPerm( Parent % NodeIndexes(1:nPar) ) > 0 )
             ELSE
                Parent => CurrentElement % BoundaryInfo % Right
                IF ( ASSOCIATED( Parent ) ) THEN
                   nPar = Parent % TYPE % NumberOfNodes
                   stat = ALL( PotentialPerm( Parent % NodeIndexes(1:nPar) ) > 0 )
                END IF
             END IF

             IF ( .NOT. stat )  CALL Fatal( 'StatElecSolve', &
                  'No potential found for computing surface charges' )

             Nodes % x(1:nPar) = Model % Nodes % x(Parent % NodeIndexes)
             Nodes % y(1:nPar) = Model % Nodes % y(Parent % NodeIndexes)
             Nodes % z(1:nPar) = Model % Nodes % z(Parent % NodeIndexes)

             ElementPot(1:nPar) = Potential( Reorder( Parent % NodeIndexes(1:nPar) ) )

             matId = GetMaterialId( Parent )

             CALL GetRealArray( Model % Materials(matId) % Values, Pwrk, &
                  'Relative Permittivity', gotIt, Parent )
             IF ( .NOT. gotIt ) &
                  CALL GetRealArray( Model % Materials(matId) % Values, &
                  Pwrk, 'Permittivity', gotIt, Parent )
      
             Permittivity = 0.0d0
             IF ( SIZE(Pwrk,1) == 1 ) THEN
                DO i=1,3
                   Permittivity( i,i,1:nPar ) = Pwrk( 1,1,1:nPar )
                END DO
             ELSE IF ( SIZE(Pwrk,2) == 1 ) THEN
                DO i=1,MIN(3,SIZE(Pwrk,1))
                   Permittivity(i,i,1:nPar) = Pwrk(i,1,1:nPar)
                END DO
             ELSE
                DO i=1,MIN(3,SIZE(Pwrk,1))
                   DO j=1,MIN(3,SIZE(Pwrk,2))
                      Permittivity( i,j,1:nPar ) = Pwrk(i,j,1:nPar)
                   END DO
                END DO
             END IF

!------------------------------------------------------------------------------
!    Integration stuff
!------------------------------------------------------------------------------
             IntegStuff = GaussPoints( Element )

             U_Integ => IntegStuff % u
             V_Integ => IntegStuff % v
             W_Integ => IntegStuff % w
             S_Integ => IntegStuff % s
             N_Integ =  IntegStuff % n

             ElemVol = 0.0d0
             Sigma = 0.0d0

!------------------------------------------------------------------------------
             DO p = 1, N_Integ
!------------------------------------------------------------------------------

                ug = U_Integ(p)
                vg = V_Integ(p)
                wg = W_Integ(p)
!------------------------------------------------------------------------------
!      Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
                stat = ElementInfo( Element, BoundaryNodes, ug, vg, wg, &
                     detJ, Basis, dBasisdx )

!------------------------------------------------------------------------------
!      Coordinatesystem dependent info
!------------------------------------------------------------------------------
                s = 1.0d0
                IF ( Coordinates /= Cartesian ) THEN
                   xpos = SUM( BoundaryNodes % x(1:n) * Basis(1:n) )
                   ypos = SUM( BoundaryNodes % y(1:n) * Basis(1:n) )
                   zpos = SUM( BoundaryNodes % z(1:n) * Basis(1:n) )
                   s = 2*PI
                END IF
         
                CALL CoordinateSystemInfo( Metric, SqrtMetric, Symb, dSymb,&
                     xpos, ypos, zpos)
 
                s = s * SqrtMetric * detJ * S_Integ(p)

                Normal = Normalvector( Element, BoundaryNodes, ug, vg, .TRUE. )
!------------------------------------------------------------------------------
! Need parent element basis etc., for computing normal derivatives on boundary.
!------------------------------------------------------------------------------
                DO i = 1, n
                  DO j = 1, nPar
                    IF ( NodeIndexes(i) == Parent % NodeIndexes(j) ) THEN
                      x(i) = Parent % TYPE % NodeU(j)
                      y(i) = Parent % TYPE % NodeV(j)
                      z(i) = Parent % TYPE % NodeW(j)
                      EXIT
                    END IF
                  END DO
                END DO

                ug = SUM( Basis(1:n) * x(1:n) )
                vg = SUM( Basis(1:n) * y(1:n) )
                wg = SUM( Basis(1:n) * z(1:n) )

                stat = ElementInfo( Parent, Nodes, ug, vg, wg, detJ, ParentBasis, &
                     ParentdBasisdx )

!------------------------------------------------------------------------------

                EpsGrad = 0.0d0
                DO j = 1, Dim
                  DO i = 1, Dim
                    EpsGrad(j) = EpsGrad(j) + &
                        SUM( Permittivity(j,i,1:nPar) * ParentBasis(1:nPar) ) * &
                        SUM( ParentdBasisdx(1:nPar,i) * ElementPot(1:nPar) )
                  END DO
                END DO

                Sigma = Sigma + s * SUM( EpsGrad(1:Dim) * Normal(1:Dim) )
                ElemVol = ElemVol + s 

!------------------------------------------------------------------------------
             END DO

!------------------------------------------------------------------------------
!   Weight with element area if required
!------------------------------------------------------------------------------

             IF ( ConstantWeights ) THEN
                Sigma = Sigma / ElemVol
                SurfWeights( Reorder( NodeIndexes(1:n) ) ) = &
                     SurfWeights( Reorder( NodeIndexes(1:n) ) ) + 1
             ELSE
                SurfWeights( Reorder( NodeIndexes(1:n) ) ) = &
                     SurfWeights( Reorder( NodeIndexes(1:n) ) ) + ElemVol
             END IF

!------------------------------------------------------------------------------

             SurfaceCharge( PotentialPerm(NodeIndexes(1:n)) ) = &
                  SurfaceCharge( PotentialPerm(NodeIndexes(1:n)) ) + Sigma

          END DO
       END DO
    END IF
    ! Of CalculateSurfCharge


!------------------------------------------------------------------------------
!   Finally, compute average of the fluxes at nodes
!------------------------------------------------------------------------------

   DO i = 1, Model % NumberOfNodes
     j = Reorder(i)
     IF( j == 0 ) CYCLE
     IF ( ABS( SumOfWeights(j) ) > 0.0d0 ) THEN
       IF ( CalculateEnergy )  Energy(j) = Energy(j) / SumOfWeights( j )
       IF ( CalculateField ) THEN
         DO k=1,DIM
           Field( DIM*(j-1)+k ) = Field( DIM*(j-1)+k) / SumOfWeights( j )
         END DO
       END IF

       IF ( CalculateFlux ) THEN
         DO k=1,DIM
           Flux( DIM*(j-1)+k ) = Flux( DIM*(j-1)+k) / SumOfWeights( j )
         END DO
       END IF
     END IF

     IF ( CalculateSurfCharge ) THEN
       IF ( ABS( SurfWeights(Reorder(i)) ) > 0.0d0 ) THEN
         SurfaceCharge( j ) = SurfaceCharge( j ) / SurfWeights( j )
       END IF
     END IF
   END DO

   Wetot = PermittivityOfVacuum * Wetot / 2.0d0
   IF(CalculateEnergy) Energy = PermittivityOfVacuum * Energy / 2.0d0
   
   DEALLOCATE( Nodes % x, &
       Nodes % y, &
       Nodes % z, &
       SumOfWeights)

   IF ( CalculateSurfCharge )  THEN
     DEALLOCATE( BoundaryNodes % x, &
         BoundaryNodes % y, BoundaryNodes % z, &
         SurfWeights, x, y, z )
     SurfaceCharge = SurfaceCharge * PermittivityOfVacuum
   END IF


!------------------------------------------------------------------------------
  END SUBROUTINE GeneralElectricFlux
!------------------------------------------------------------------------------

 
!------------------------------------------------------------------------------
     SUBROUTINE StatElecCompose( StiffMatrix,Force,PiezoMaterial, PiezoCoeff, &
                            Permittivity, Load,Element,n,Nodes, Displacement )
!------------------------------------------------------------------------------
       REAL(KIND=dp) :: StiffMatrix(:,:),Force(:),Load(:), Permittivity(:,:,:)
       REAL(KIND=dp) :: PiezoCoeff(:,:,:), Displacement(:,:)
       INTEGER :: n
       TYPE(Nodes_t) :: Nodes
       TYPE(Element_t), POINTER :: Element
       LOGICAL :: PiezoMaterial
!------------------------------------------------------------------------------
 
       REAL(KIND=dp) :: SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3)
       REAL(KIND=dp) :: Basis(n),dBasisdx(n,3)
       REAL(KIND=dp) :: SqrtElementMetric,U,V,W,S,A,L,C(3,3),x,y,z
       REAL(KIND=dp) :: PiezoForce(n), LocalStrain(6), PiezoLoad(3)

       LOGICAL :: Stat

       INTEGER :: i,j,p,q,t,DIM
 
       TYPE(GaussIntegrationPoints_t) :: IntegStuff
 
!------------------------------------------------------------------------------

       DIM = CoordinateSystemDimension()

       PiezoForce = 0.0d0
       Force = 0.0d0
       StiffMatrix = 0.0d0
!------------------------------------------------------------------------------
 
!------------------------------------------------------------------------------
!      Numerical integration
!------------------------------------------------------------------------------
       IntegStuff = GaussPoints( Element )
 
       DO t=1,IntegStuff % n
         U = IntegStuff % u(t)
         V = IntegStuff % v(t)
         W = IntegStuff % w(t)
         S = IntegStuff % s(t)
!------------------------------------------------------------------------------
!        Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
         stat = ElementInfo( Element,Nodes,U,V,W,SqrtElementMetric, &
                    Basis,dBasisdx )
!------------------------------------------------------------------------------
!      Coordinatesystem dependent info
!------------------------------------------------------------------------------
         IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
           x = SUM( ElementNodes % x(1:n)*Basis(1:n) )
           y = SUM( ElementNodes % y(1:n)*Basis(1:n) )
           z = SUM( ElementNodes % z(1:n)*Basis(1:n) )
         END IF

         CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,x,y,z )
 
         S = S * SqrtElementMetric * SqrtMetric
!------------------------------------------------------------------------------
!        The piezo force term
!------------------------------------------------------------------------------

         IF ( PiezoMaterial ) THEN
           ! So far only plane strain in 2D  (LocalStrain(3) = 0)           
           LocalStrain = 0.0d0
           DO i = 1, Dim
             LocalStrain(i) = SUM( dBasisdx(1:n,i) * Displacement(1:n,i) )
           END DO
           LocalStrain(4) = 0.5d0 * ( SUM( dBasisdx(1:n,1) * Displacement(1:n,2) ) &
               + SUM( dBasisdx(1:n,2) * Displacement(1:n,1) ) )
           IF ( Dim == 3 ) THEN
             LocalStrain(5) = 0.5d0 * ( SUM( dBasisdx(1:n,2) * Displacement(1:n,3) ) &
                 + SUM( dBasisdx(1:n,3) * Displacement(1:n,2) ) )
             LocalStrain(6) = 0.5d0 * ( SUM( dBasisdx(1:n,1) * Displacement(1:n,3) ) &
                 + SUM( dBasisdx(1:n,3) * Displacement(1:n,1) ) )
           END IF
           
           PiezoLoad = 0.0d0
           DO i = 1, Dim
             DO j = 1, 2*Dim
               PiezoLoad(i) = PiezoLoad(i) + SUM( Basis(1:n) * PiezoCoeff(i,j,1:n) ) * &
                   LocalStrain(j)
             END DO
           END DO
           
         END IF
         
!------------------------------------------------------------------------------
         L = SUM( Load(1:n) * Basis )
         DO i=1,DIM
           DO j=1,DIM
             C(i,j) = SUM( Permittivity(i,j,1:n) * Basis(1:n) )
           END DO
         END DO
!------------------------------------------------------------------------------
!        The Poisson equation
!------------------------------------------------------------------------------
         DO p=1,N
           DO q=1,N
             A = 0.d0
             DO i=1,DIM
               DO J=1,DIM
                 A = A + C(i,j) * dBasisdx(p,i) * dBasisdx(q,j)
               END DO
             END DO
             StiffMatrix(p,q) = StiffMatrix(p,q) + S*A
           END DO
           Force(p) = Force(p) + S*L*Basis(p)

           IF ( PiezoMaterial ) THEN
             PiezoForce(p) = PiezoForce(p) + S * SUM( dBasisdx(p,1:3) * PiezoLoad(1:3) )
           END IF

        END DO
!------------------------------------------------------------------------------
       END DO
       IF ( PiezoMaterial )  Force = Force + PiezoForce
!       IF ( PiezoMaterial )  Force = Force + PiezoForce / PermittivityOfVacuum ?

!------------------------------------------------------------------------------
     END SUBROUTINE StatElecCompose
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE SetPermutationBoundaries( Model, StiffMatrix, ForceVector, &
      Name, Perm, Permutation)
!------------------------------------------------------------------------------
!  To compute the capacitance matrix for m bodies, m*(m+1)/2
! different permutations are required. This subroutine makes different
! permutation every time when its called.
!------------------------------------------------------------------------------

    TYPE(Model_t) :: Model
    TYPE(Matrix_t), POINTER :: StiffMatrix
    REAL(KIND=dp) :: ForceVector(:)
    CHARACTER(LEN=*) :: Name 
    INTEGER :: Perm(:), Permutation
!------------------------------------------------------------------------------

    TYPE(Element_t), POINTER :: CurrentElement
    INTEGER, POINTER :: NodeIndexes(:)
    INTEGER :: i,j,k,n,t,k1,k2, Body
    LOGICAL :: GotIt
    REAL(KIND=dp) :: Work(Model % MaxElementNodes),s

!------------------------------------------------------------------------------
    
    DO t = Model % NumberOfBulkElements + 1, &
        Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
      
      CurrentElement => Model % Elements(t)
!------------------------------------------------------------------------------
!      Set the current element pointer in the model structure to
!      reflect the element being processed
!------------------------------------------------------------------------------
      Model % CurrentElement => Model % Elements(t)
!------------------------------------------------------------------------------
      n = CurrentElement % TYPE % NumberOfNodes
      NodeIndexes => CurrentElement % NodeIndexes

      DO i=1,Model % NumberOfBCs
        IF ( CurrentElement % BoundaryInfo % Constraint == &
            Model % BCs(i) % Tag ) THEN
          
          Body = ListGetInteger( Model % BCs(i) % Values, Name, gotIt )
          CapBodyIndex(NodeIndexes) = Body
          
          IF ( gotIt ) THEN           
            IF(Body == Permutation) THEN
              Work = 1.0d0
            ELSE 
              Work(1:n) = 0.0d0
            END IF

            DO j=1,n
              k = Perm(NodeIndexes(j))
              IF ( k > 0 ) THEN

                IF ( StiffMatrix % FORMAT == MATRIX_SBAND ) THEN
                  
                  CALL SBand_SetDirichlet( StiffMatrix,ForceVector,k,Work(j) )
                  
                ELSE IF ( StiffMatrix % FORMAT == MATRIX_CRS .AND. &
                    StiffMatrix % Symmetric ) THEN
                  
                  CALL CRS_SetSymmDirichlet(StiffMatrix,ForceVector,k,Work(j))
                  
                ELSE
                  
                  s = StiffMatrix % Values(StiffMatrix % Diag(k))
                  ForceVector(k) = Work(j) * s
                  CALL ZeroRow( StiffMatrix,k )
                  CALL SetMatrixElement( StiffMatrix,k,k,1.0d0*s )
                  
                END IF
              END IF
            END DO

          END IF
         END IF
       END DO
     END DO
!------------------------------------------------------------------------------
   END SUBROUTINE SetPermutationBoundaries
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   SUBROUTINE StatElecBoundary( BoundaryMatrix, BoundaryVector, &
        LoadVector, Alpha, Beta, Element, n, Nodes )
!------------------------------------------------------------------------------
!******************************************************************************
!
!  Return element local matrices and RSH vector for boundary conditions
!  of diffusion equation: 
!
!  ARGUMENTS:
!
!  REAL(KIND=dp) :: BoundaryVector(:)
!     OUTPUT: RHS vector
!
!  REAL(KIND=dp) :: LoadVector(:)
!     INPUT: coefficient of the force term
!
!  REAL(KIND=dp) :: Alpha, Beta
!     INPUT: coefficients of the Robin BC: g = alpha * u + beta
!
!  TYPE(Element_t) :: Element
!       INPUT: Structure describing the element (dimension,nof nodes,
!               interpolation degree, etc...)
!
!   INTEGER :: n
!       INPUT: Number  of element nodes
!
!  TYPE(Nodes_t) :: Nodes
!       INPUT: Element node coordinates
!
!******************************************************************************

     REAL(KIND=dp) :: BoundaryMatrix(:,:), BoundaryVector(:), LoadVector(:)

     TYPE(Nodes_t)   :: Nodes
     TYPE(Element_t) :: Element

     INTEGER :: n

     REAL(KIND=dp) :: Basis(n)
     REAL(KIND=dp) :: dBasisdx(n,3),SqrtElementMetric
     REAL(KIND=dp) :: SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3)

     REAL(KIND=dp) :: u,v,w,s,x,y,z
     REAL(KIND=dp) :: Force, Alpha, Beta
     REAL(KIND=dp), POINTER :: U_Integ(:),V_Integ(:),W_Integ(:),S_Integ(:)

     INTEGER :: t,p,q,N_Integ

     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

     LOGICAL :: stat
!------------------------------------------------------------------------------

     BoundaryVector = 0.0d0
     BoundaryMatrix = 0.0d0
!------------------------------------------------------------------------------
!    Integration stuff
!------------------------------------------------------------------------------
     IntegStuff = GaussPoints( Element )
     U_Integ => IntegStuff % u
     V_Integ => IntegStuff % v
     W_Integ => IntegStuff % w
     S_Integ => IntegStuff % s
     N_Integ =  IntegStuff % n

!------------------------------------------------------------------------------
!   Now we start integrating
!------------------------------------------------------------------------------
     DO t=1,N_Integ
       u = U_Integ(t)
       v = V_Integ(t)
       w = W_Integ(t)
!------------------------------------------------------------------------------
!     Basis function values & derivates at the integration point
!------------------------------------------------------------------------------
      stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
                 Basis,dBasisdx )

!------------------------------------------------------------------------------
!      Coordinatesystem dependent info
!------------------------------------------------------------------------------
         IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
           x = SUM( ElementNodes % x(1:n)*Basis(1:n) )
           y = SUM( ElementNodes % y(1:n)*Basis(1:n) )
           z = SUM( ElementNodes % z(1:n)*Basis(1:n) )
         END IF

         CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,x,y,z )
 
         s = S_Integ(t) * SqrtElementMetric * SqrtMetric

!------------------------------------------------------------------------------
       Force = SUM( LoadVector(1:n)*Basis )
       Force = Force + Beta
       DO p=1,N
         DO q=1,N
           BoundaryMatrix(p,q) = BoundaryMatrix(p,q) + &
              s * Alpha * Basis(q) * Basis(p)
         END DO
       END DO

       DO q=1,N
         BoundaryVector(q) = BoundaryVector(q) + s * Basis(q) * Force
       END DO
     END DO
   END SUBROUTINE StatElecBoundary
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
 END SUBROUTINE StatElecSolver
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  FUNCTION ElectricBoundaryResidual( Model, Edge, Mesh, Quant, Perm, Gnorm ) &
       RESULT( Indicator )
!------------------------------------------------------------------------------
     USE DefUtils
     IMPLICIT NONE
!------------------------------------------------------------------------------
     TYPE(Model_t) :: Model
     INTEGER :: Perm(:)
     REAL(KIND=dp) :: Quant(:), Indicator(2), Gnorm
     TYPE( Mesh_t ), POINTER    :: Mesh
     TYPE( Element_t ), POINTER :: Edge
!------------------------------------------------------------------------------

     TYPE(Nodes_t) :: Nodes, EdgeNodes
     TYPE(Element_t), POINTER :: Element


     INTEGER :: i,j,k,n,l,t,DIM,Pn,En
     LOGICAL :: stat, Found

     REAL(KIND=dp), POINTER :: Hwrk(:,:,:)

     REAL(KIND=dp) :: SqrtMetric, Metric(3,3), Symb(3,3,3), dSymb(3,3,3,3)
     REAL(KIND=dp) :: Grad(3,3), Normal(3), EdgeLength
     REAL(KIND=dp) :: u, v, w, s, detJ
     REAL(KIND=dp) :: Residual, ResidualNorm, Permittivity

     REAL(KIND=dp), ALLOCATABLE :: EdgeBasis(:), Basis(:)
     REAL(KIND=dp), ALLOCATABLE :: Flux(:)
     REAL(KIND=dp), ALLOCATABLE :: x(:), y(:), z(:), dBasisdx(:,:)
     REAL(KIND=dp), ALLOCATABLE :: NodalPermittivity(:), Potential(:)

     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

     LOGICAL :: First = .TRUE., Dirichlet

     SAVE Hwrk, First
!------------------------------------------------------------------------------

!    Initialize:
!    -----------
     IF ( First ) THEN
        First = .FALSE.
        NULLIFY( Hwrk )
     END IF

     Gnorm     = 0.0d0

     Metric = 0.0d0
     DO i=1,3
        Metric(i,i) = 1.0d0
     END DO

     SELECT CASE( CurrentCoordinateSystem() )
        CASE( AxisSymmetric, CylindricSymmetric )
           DIM = 3
        CASE DEFAULT
           DIM = CoordinateSystemDimension()
     END SELECT
!    
!    ---------------------------------------------

     Element => Edge % BoundaryInfo % Left

     IF ( .NOT. ASSOCIATED( Element ) ) THEN

        Element => Edge % BoundaryInfo % Right

     ELSE IF ( ANY( Perm( Element % NodeIndexes ) <= 0 ) ) THEN

        Element => Edge % BoundaryInfo % Right

     END IF

     IF ( .NOT. ASSOCIATED( Element ) ) RETURN
     IF ( ANY( Perm( Element % NodeIndexes ) <= 0 ) ) RETURN

     En = Edge % TYPE % NumberOfNodes
     Pn = Element % TYPE % NumberOfNodes

     ALLOCATE( EdgeNodes % x(En), EdgeNodes % y(En), EdgeNodes % z(En) )

     EdgeNodes % x = Mesh % Nodes % x(Edge % NodeIndexes)
     EdgeNodes % y = Mesh % Nodes % y(Edge % NodeIndexes)
     EdgeNodes % z = Mesh % Nodes % z(Edge % NodeIndexes)

     ALLOCATE( Nodes % x(Pn), Nodes % y(Pn), Nodes % z(Pn) )

     Nodes % x = Mesh % Nodes % x(Element % NodeIndexes)
     Nodes % y = Mesh % Nodes % y(Element % NodeIndexes)
     Nodes % z = Mesh % Nodes % z(Element % NodeIndexes)

     ALLOCATE( EdgeBasis(En), Basis(Pn), dBasisdx(Pn,3), Flux(En), &
      x(En), y(En), z(En), NodalPermittivity(En), Potential(Pn) )

     DO l = 1,En
       DO k = 1,Pn
          IF ( Edge % NodeIndexes(l) == Element % NodeIndexes(k) ) THEN
             x(l) = Element % TYPE % NodeU(k)
             y(l) = Element % TYPE % NodeV(k)
             z(l) = Element % TYPE % NodeW(k)
             EXIT
          END IF
       END DO
     END DO
!
!    Integrate square of residual over boundary element:
!    ---------------------------------------------------

     Indicator    = 0.0d0
     EdgeLength   = 0.0d0
     ResidualNorm = 0.0d0

     DO j=1,Model % NumberOfBCs
        IF ( Edge % BoundaryInfo % Constraint /= Model % BCs(j) % Tag ) CYCLE

!       IF ( .NOT. ListGetLogical( Model % BCs(j) % Values, &
!                 'Heat Flux BC', Found ) ) CYCLE

!
!       Check if dirichlet BC given:
!       ----------------------------
        s = ListGetConstReal( Model % BCs(j) % Values, &
              ComponentName(Model % Solver % Variable), Dirichlet )

!       Get various flux bc options:
!       ----------------------------

!       ...given flux:
!       --------------
        Flux(1:En) = ListGetReal( Model % BCs(j) % Values, &
          'Electric Flux', En, Edge % NodeIndexes, Found )


!       get material parameters:
!       ------------------------
        k = ListGetInteger(Model % Bodies(Element % BodyId) % Values,'Material', &
                    minv=1, maxv=Model % NumberOFMaterials)

        CALL ListGetRealArray( Model % Materials(k) % Values, &
               'Relative Permittivity', Hwrk, En, Edge % NodeIndexes,stat )
        IF ( .NOT. stat )  &
             CALL ListGetRealArray( Model % Materials(k) % Values, &
             'Permittivity', Hwrk, En, Edge % NodeIndexes )

        NodalPermittivity( 1:En ) = Hwrk( 1,1,1:En )

!       elementwise nodal solution:
!       ---------------------------
        Potential(1:Pn) = Quant( Perm(Element % NodeIndexes) )

!       do the integration:
!       -------------------
        EdgeLength   = 0.0d0
        ResidualNorm = 0.0d0

        IntegStuff = GaussPoints( Edge )

        DO t=1,IntegStuff % n
           u = IntegStuff % u(t)
           v = IntegStuff % v(t)
           w = IntegStuff % w(t)

           stat = ElementInfo( Edge, EdgeNodes, u, v, w, detJ, &
               EdgeBasis, dBasisdx )

           Normal = NormalVector( Edge, EdgeNodes, u, v, .TRUE. )

           IF ( CurrentCoordinateSystem() == Cartesian ) THEN
              s = IntegStuff % s(t) * detJ
           ELSE
              u = SUM( EdgeBasis(1:En) * EdgeNodes % x(1:En) )
              v = SUM( EdgeBasis(1:En) * EdgeNodes % y(1:En) )
              w = SUM( EdgeBasis(1:En) * EdgeNodes % z(1:En) )
      
              CALL CoordinateSystemInfo( Metric, SqrtMetric, &
                         Symb, dSymb, u, v, w )

              s = IntegStuff % s(t) * detJ * SqrtMetric
           END IF

!
!          Integration point in parent element local
!          coordinates:
!          -----------------------------------------
           u = SUM( EdgeBasis(1:En) * x(1:En) )
           v = SUM( EdgeBasis(1:En) * y(1:En) )
           w = SUM( EdgeBasis(1:En) * z(1:En) )

           stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
                 Basis, dBasisdx )
!
!          Heat conductivity at the integration point:
!          --------------------------------------------
           Permittivity = SUM( NodalPermittivity(1:En) * EdgeBasis(1:En) )
!
!          given flux at integration point:
!          --------------------------------
           Residual = -SUM( Flux(1:En) * EdgeBasis(1:En) )


!          flux given by the computed solution, and 
!          force norm for scaling the residual:
!          -----------------------------------------
           IF ( CurrentCoordinateSystem() == Cartesian ) THEN
              DO k=1,DIM
                 Residual = Residual + Permittivity  * &
                    SUM( dBasisdx(1:Pn,k) * Potential(1:Pn) ) * Normal(k)

                 Gnorm = Gnorm + s * (Permittivity * &
                       SUM(dBasisdx(1:Pn,k) * Potential(1:Pn)) * Normal(k))**2
              END DO
           ELSE
              DO k=1,DIM
                 DO l=1,DIM
                    Residual = Residual + Metric(k,l) * Permittivity  * &
                       SUM( dBasisdx(1:Pn,k) * Potential(1:Pn) ) * Normal(l)

                    Gnorm = Gnorm + s * (Metric(k,l) * Permittivity * &
                      SUM(dBasisdx(1:Pn,k) * Potential(1:Pn) ) * Normal(l))**2
                 END DO
              END DO
           END IF

           EdgeLength   = EdgeLength + s
           IF ( .NOT. Dirichlet ) THEN
              ResidualNorm = ResidualNorm + s * Residual ** 2
           END IF
        END DO
        EXIT
     END DO

     IF ( CoordinateSystemDimension() == 3 ) THEN
        EdgeLength = SQRT(EdgeLength)
     END IF

!    Gnorm = EdgeLength * Gnorm
     Indicator = EdgeLength * ResidualNorm

     DEALLOCATE( Nodes % x, Nodes % y, Nodes % z)
     DEALLOCATE( EdgeNodes % x, EdgeNodes % y, EdgeNodes % z)

     DEALLOCATE( EdgeBasis, Basis, dBasisdx, Flux, x, y, z, &
             NodalPermittivity, Potential )
!------------------------------------------------------------------------------
  END FUNCTION ElectricBoundaryResidual
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
  FUNCTION ElectricEdgeResidual( Model, Edge, Mesh, Quant, Perm ) RESULT( Indicator )
!------------------------------------------------------------------------------
     USE DefUtils
     IMPLICIT NONE

     TYPE(Model_t) :: Model
     INTEGER :: Perm(:)
     REAL(KIND=dp) :: Quant(:), Indicator(2)
     TYPE( Mesh_t ), POINTER    :: Mesh
     TYPE( Element_t ), POINTER :: Edge
!------------------------------------------------------------------------------

     TYPE(Nodes_t) :: Nodes, EdgeNodes
     TYPE(Element_t), POINTER :: Element

     INTEGER :: i,j,k,l,n,t,DIM,En,Pn
     LOGICAL :: stat, Found

     REAL(KIND=dp), POINTER :: Hwrk(:,:,:)

     REAL(KIND=dp) :: SqrtMetric, Metric(3,3), Symb(3,3,3), dSymb(3,3,3,3)
     REAL(KIND=dp) :: Permittivity
     REAL(KIND=dp) :: u, v, w, s, detJ
     REAL(KIND=dp) :: Grad(3,3), Normal(3), EdgeLength, Jump

     REAL(KIND=dp), ALLOCATABLE :: NodalPermittivity(:)
     REAL(KIND=dp), ALLOCATABLE :: x(:),y(:),z(:)
     REAL(KIND=dp), ALLOCATABLE :: EdgeBasis(:)
     REAL(KIND=dp), ALLOCATABLE :: Basis(:), dBasisdx(:,:), Potential(:)

     REAL(KIND=dp) :: Residual, ResidualNorm

     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

     LOGICAL :: First = .TRUE.

     SAVE Hwrk, First

!------------------------------------------------------------------------------

!    Initialize:
!    -----------

     IF ( First ) THEN
        First = .FALSE.
        NULLIFY( Hwrk )
     END IF

     SELECT CASE( CurrentCoordinateSystem() )
        CASE( AxisSymmetric, CylindricSymmetric )
           DIM = 3
        CASE DEFAULT
           DIM = CoordinateSystemDimension()
     END SELECT

     Metric = 0.0d0
     DO i = 1,3
        Metric(i,i) = 1.0d0
     END DO

     Grad = 0.0d0
!
!    ---------------------------------------------

     Element => Edge % BoundaryInfo % Left
     n = Element % TYPE % NumberOfNodes

     Element => Edge % BoundaryInfo % Right
     n = MAX( n, Element % TYPE % NumberOfNodes )

     ALLOCATE( Nodes % x(n), Nodes % y(n), Nodes % z(n) )

     En = Edge % TYPE % NumberOfNodes
     ALLOCATE( EdgeNodes % x(En), EdgeNodes % y(En), EdgeNodes % z(En) )

     EdgeNodes % x = Mesh % Nodes % x(Edge % NodeIndexes)
     EdgeNodes % y = Mesh % Nodes % y(Edge % NodeIndexes)
     EdgeNodes % z = Mesh % Nodes % z(Edge % NodeIndexes)

     ALLOCATE( x(En), y(En), z(En), NodalPermittivity(En), EdgeBasis(En), &
             Basis(n), dBasisdx(n,3), Potential(n) )

!    Integrate square of jump over edge:
!    -----------------------------------
     ResidualNorm = 0.0d0
     EdgeLength   = 0.0d0
     Indicator    = 0.0d0

     IntegStuff = GaussPoints( Edge )

     DO t=1,IntegStuff % n

        u = IntegStuff % u(t)
        v = IntegStuff % v(t)
        w = IntegStuff % w(t)

        stat = ElementInfo( Edge, EdgeNodes, u, v, w, detJ, &
             EdgeBasis, dBasisdx )

        Normal = NormalVector( Edge, EdgeNodes, u, v, .FALSE. )

        IF ( CurrentCoordinateSystem() == Cartesian ) THEN
           s = IntegStuff % s(t) * detJ
        ELSE
           u = SUM( EdgeBasis(1:En) * EdgeNodes % x(1:En) )
           v = SUM( EdgeBasis(1:En) * EdgeNodes % y(1:En) )
           w = SUM( EdgeBasis(1:En) * EdgeNodes % z(1:En) )

           CALL CoordinateSystemInfo( Metric, SqrtMetric, &
                      Symb, dSymb, u, v, w )
           s = IntegStuff % s(t) * detJ * SqrtMetric
        END IF

        ! 
        ! Compute flux over the edge as seen by elements
        ! on both sides of the edge:
        ! ----------------------------------------------
        DO i = 1,2
           SELECT CASE(i)
              CASE(1)
                 Element => Edge % BoundaryInfo % Left
              CASE(2)
                 Element => Edge % BoundaryInfo % Right
           END SELECT
!
!          Can this really happen (maybe it can...)  ?      
!          -------------------------------------------
           IF ( ANY( Perm( Element % NodeIndexes ) <= 0 ) ) CYCLE
!
!          Next, get the integration point in parent
!          local coordinates:
!          -----------------------------------------
           Pn = Element % TYPE % NumberOfNodes

           DO j = 1,En
              DO k = 1,Pn
                 IF ( Edge % NodeIndexes(j) == Element % NodeIndexes(k) ) THEN
                    x(j) = Element % TYPE % NodeU(k)
                    y(j) = Element % TYPE % NodeV(k)
                    z(j) = Element % TYPE % NodeW(k)
                    EXIT
                 END IF
              END DO
           END DO

           u = SUM( EdgeBasis(1:En) * x(1:En) )
           v = SUM( EdgeBasis(1:En) * y(1:En) )
           w = SUM( EdgeBasis(1:En) * z(1:En) )
!
!          Get parent element basis & derivatives at the integration point:
!          -----------------------------------------------------------------
           Nodes % x(1:Pn) = Mesh % Nodes % x(Element % NodeIndexes)
           Nodes % y(1:Pn) = Mesh % Nodes % y(Element % NodeIndexes)
           Nodes % z(1:Pn) = Mesh % Nodes % z(Element % NodeIndexes)

           stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
             Basis, dBasisdx )
!
!          Material parameters:
!          --------------------
           k = ListGetInteger( Model % Bodies( &
                    Element % BodyId) % Values, 'Material', &
                     minv=1, maxv=Model % NumberOFMaterials )

           CALL ListGetRealArray( Model % Materials(k) % Values, &
                'Relative Permittivity', Hwrk, En, Edge % NodeIndexes,stat )
           IF ( .NOT. stat )  &
                CALL ListGetRealArray( Model % Materials(k) % Values, &
                'Permittivity', Hwrk, En, Edge % NodeIndexes )

           NodalPermittivity( 1:En ) = Hwrk( 1,1,1:En )
           Permittivity = SUM( NodalPermittivity(1:En) * EdgeBasis(1:En) )
!
!          Potential at element nodal points:
!          ------------------------------------
           Potential(1:Pn) = Quant( Perm(Element % NodeIndexes) )
!
!          Finally, the flux:
!          ------------------
           DO j=1,DIM
              Grad(j,i) = Permittivity * SUM( dBasisdx(1:Pn,j) * Potential(1:Pn) )
           END DO
        END DO

!       Compute square of the flux jump:
!       -------------------------------   
        EdgeLength  = EdgeLength + s
        Jump = 0.0d0
        DO k=1,DIM
           IF ( CurrentCoordinateSystem() == Cartesian ) THEN
              Jump = Jump + (Grad(k,1) - Grad(k,2)) * Normal(k)
           ELSE
              DO l=1,DIM
                 Jump = Jump + &
                       Metric(k,l) * (Grad(k,1) - Grad(k,2)) * Normal(l)
              END DO
           END IF
        END DO
        ResidualNorm = ResidualNorm + s * Jump ** 2
     END DO

     IF ( CoordinateSystemDimension() == 3 ) THEN
        EdgeLength = SQRT(EdgeLength)
     END IF
     Indicator = EdgeLength * ResidualNorm

     DEALLOCATE( Nodes % x, Nodes % y, Nodes % z)
     DEALLOCATE( EdgeNodes % x, EdgeNodes % y, EdgeNodes % z)

     DEALLOCATE( x, y, z, NodalPermittivity, EdgeBasis, Basis, &
                dBasisdx, Potential )
!------------------------------------------------------------------------------
  END FUNCTION ElectricEdgeResidual
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   FUNCTION ElectricInsideResidual( Model, Element, Mesh, &
        Quant, Perm, Fnorm ) RESULT( Indicator )
!------------------------------------------------------------------------------
     USE DefUtils
!------------------------------------------------------------------------------
     IMPLICIT NONE
!------------------------------------------------------------------------------
     TYPE(Model_t) :: Model
     INTEGER :: Perm(:)
     REAL(KIND=dp) :: Quant(:), Indicator(2), Fnorm
     TYPE( Mesh_t ), POINTER    :: Mesh
     TYPE( Element_t ), POINTER :: Element
!------------------------------------------------------------------------------

     TYPE(Nodes_t) :: Nodes

     LOGICAL :: stat, Found
     INTEGER :: i,j,k,l,n,t,DIM

     REAL(KIND=dp), POINTER :: Hwrk(:,:,:)

     REAL(KIND=dp) :: SqrtMetric, Metric(3,3), Symb(3,3,3), dSymb(3,3,3,3)
     REAL(KIND=dp) :: Permittivity
     REAL(KIND=dp) :: u, v, w, s, detJ
     REAL(KIND=dp) :: Source, Residual, ResidualNorm, Area

     REAL(KIND=dp), ALLOCATABLE :: NodalPermittivity(:)
     REAL(KIND=dp), ALLOCATABLE :: PrevPot(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalSource(:), Potential(:)
     REAL(KIND=dp), ALLOCATABLE :: Basis(:)
     REAL(KIND=dp), ALLOCATABLE :: dBasisdx(:,:), ddBasisddx(:,:,:)

     TYPE( ValueList_t ), POINTER :: Material

     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

     LOGICAL :: First = .TRUE.

     SAVE Hwrk, First

!------------------------------------------------------------------------------

!    Initialize:
!    -----------
     Indicator = 0.0d0
     Fnorm     = 0.0d0
!
!    Check if this eq. computed in this element:
!    -------------------------------------------
     IF ( ANY( Perm( Element % NodeIndexes ) <= 0 ) ) RETURN

     IF ( First ) THEN
        First = .FALSE.
        NULLIFY( Hwrk )
     END IF

     Metric = 0.0d0
     DO i=1,3
        Metric(i,i) = 1.0d0
     END DO

     SELECT CASE( CurrentCoordinateSystem() )
        CASE( AxisSymmetric, CylindricSymmetric )
           DIM = 3
        CASE DEFAULT
           DIM = CoordinateSystemDimension()
     END SELECT
!
!    Element nodal points:
!    ---------------------
     n = Element % TYPE % NumberOfNodes

     ALLOCATE( Nodes % x(n), Nodes % y(n), Nodes % z(n), &
       NodalPermittivity(n), Basis(n), dBasisdx(n,3),    &
       ddBasisddx(n,3,3), PrevPot(n), NodalSource(n), Potential(n) )

     Nodes % x = Mesh % Nodes % x(Element % NodeIndexes)
     Nodes % y = Mesh % Nodes % y(Element % NodeIndexes)
     Nodes % z = Mesh % Nodes % z(Element % NodeIndexes)
!
!    Elementwise nodal solution:
!    ---------------------------
     Potential(1:n) = Quant( Perm(Element % NodeIndexes) )
!
!    Material parameters: relative permittivity
!    ------------------------------------------
     k = ListGetInteger( Model % Bodies(Element % BodyId) % Values, 'Material', &
                     minv=1, maxv=Model % NumberOfMaterials )

     Material => Model % Materials(k) % Values

     CALL ListGetRealArray( Model % Materials(k) % Values, &
          'Relative Permittivity', Hwrk, n, Element % NodeIndexes,stat )
     IF ( .NOT. stat )  &
          CALL ListGetRealArray( Model % Materials(k) % Values, &
          'Permittivity', Hwrk, n, Element % NodeIndexes )

     NodalPermittivity( 1:n ) = Hwrk( 1,1,1:n )

!
!    Charge density (source):
!    ------------------------
!
     k = ListGetInteger( &
         Model % Bodies(Element % BodyId) % Values,'Body Force',Found, &
                 1, Model % NumberOFBodyForces)

     NodalSource = 0.0d0
     IF ( Found .AND. k > 0  ) THEN
        NodalSource(1:n) = ListGetReal( Model % BodyForces(k) % Values, &
             'Charge Density', n, Element % NodeIndexes, stat )
        IF ( .NOT. stat )  &
             NodalSource(1:n) = ListGetReal( Model % BodyForces(k) % Values, &
             'Source', n, Element % NodeIndexes )
     END IF
!
!    Integrate square of residual over element:
!    ------------------------------------------

     ResidualNorm = 0.0d0
     Area = 0.0d0

     IntegStuff = GaussPoints( Element )

     DO t=1,IntegStuff % n
        u = IntegStuff % u(t)
        v = IntegStuff % v(t)
        w = IntegStuff % w(t)

        stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
            Basis, dBasisdx, ddBasisddx, .TRUE., .FALSE. )

        IF ( CurrentCoordinateSystem() == Cartesian ) THEN
           s = IntegStuff % s(t) * detJ
        ELSE
           u = SUM( Basis(1:n) * Nodes % x(1:n) )
           v = SUM( Basis(1:n) * Nodes % y(1:n) )
           w = SUM( Basis(1:n) * Nodes % z(1:n) )

           CALL CoordinateSystemInfo( Metric, SqrtMetric, &
                       Symb, dSymb, u, v, w )
           s = IntegStuff % s(t) * detJ * SqrtMetric
        END IF

        Permittivity = SUM( NodalPermittivity(1:n) * Basis(1:n) )
!
!       Residual of the electrostatic equation:
!
!        R = -div(e grad(u)) - s
!       ---------------------------------------------------
!
!       or more generally:
!
!        R = -g^{jk} (C T_{,j}}_{,k} - s
!       ---------------------------------------------------
!
        Residual = -SUM( NodalSource(1:n) * Basis(1:n) )

        IF ( CurrentCoordinateSystem() == Cartesian ) THEN
           DO j=1,DIM
!
!             - grad(e).grad(T):
!             --------------------
!
              Residual = Residual - &
                 SUM( Potential(1:n) * dBasisdx(1:n,j) ) * &
                 SUM( NodalPermittivity(1:n) * dBasisdx(1:n,j) )

!
!             - e div(grad(u)):
!             -------------------
!
              Residual = Residual - Permittivity * &
                 SUM( Potential(1:n) * ddBasisddx(1:n,j,j) )
           END DO
        ELSE
           DO j=1,DIM
              DO k=1,DIM
!
!                - g^{jk} C_{,k}T_{j}:
!                ---------------------
!
                 Residual = Residual - Metric(j,k) * &
                    SUM( Potential(1:n) * dBasisdx(1:n,j) ) * &
                    SUM( NodalPermittivity(1:n) * dBasisdx(1:n,k) )

!
!                - g^{jk} C T_{,jk}:
!                -------------------
!
                 Residual = Residual - Metric(j,k) * Permittivity * &
                    SUM( Potential(1:n) * ddBasisddx(1:n,j,k) )
!
!                + g^{jk} C {_jk^l} T_{,l}:
!                ---------------------------
                 DO l=1,DIM
                    Residual = Residual + Metric(j,k) * Permittivity * &
                      Symb(j,k,l) * SUM( Potential(1:n) * dBasisdx(1:n,l) )
                 END DO
              END DO
           END DO
        END IF

!
!       Compute also force norm for scaling the residual:
!       -------------------------------------------------
        DO i=1,DIM
           Fnorm = Fnorm + s * ( SUM( NodalSource(1:n) * Basis(1:n) ) ) ** 2
        END DO

        Area = Area + s
        ResidualNorm = ResidualNorm + s *  Residual ** 2
     END DO

!    Fnorm = Element % hk**2 * Fnorm
     Indicator = Element % hK**2 * ResidualNorm

     DEALLOCATE( Nodes % x, Nodes % y, Nodes % z, NodalPermittivity, &
        Basis, dBasisdx, ddBasisddx, PrevPot, NodalSource, Potential )
!------------------------------------------------------------------------------
  END FUNCTION ElectricInsideResidual
!------------------------------------------------------------------------------

!==============================================================================
