
!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Utility routines for the elmer main program.
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen, Ville Savolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 08 Jun 1997
! *
! *****************************************************************************/

MODULE MainUtils

!------------------------------------------------------------------------------

  USE SolverUtils
  USE ModelDescription

!------------------------------------------------------------------------------
  IMPLICIT NONE
!------------------------------------------------------------------------------

    TYPE SubVector_t 
      TYPE(Variable_t), POINTER :: Var 
      REAL(KIND=dp) :: rnorm, bnorm, xnorm
      REAL(KIND=dp), ALLOCATABLE :: r(:),rtmp(:),rhs(:)
    END TYPE SubVector_t
    
    TYPE SubMatrix_t
       TYPE(Matrix_t), POINTER :: Mat
    END TYPE SubMatrix_t

    TYPE BlockMatrix_t
      INTEGER :: NoVar = 0, MaxSize, TotSize
      INTEGER, POINTER :: Offset(:)
      TYPE(Solver_t), POINTER :: Solver
      REAL(KIND=dp) :: rnorm, bnorm, xnorm
      TYPE(SubMatrix_t), ALLOCATABLE :: SubMatrix(:,:)
      LOGICAL, ALLOCATABLE :: SubMatrixActive(:,:)
      TYPE(SubVector_t), ALLOCATABLE :: SubVector(:)
    END TYPE BlockMatrix_t
    
    TYPE(BlockMatrix_t), TARGET, SAVE :: TotMatrix

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION GetMatrixFormat( Model, Equation ) RESULT(FORMAT)
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    CHARACTER(LEN=*) :: Equation
!------------------------------------------------------------------------------
    INTEGER :: FORMAT

    INTEGER :: i
    LOGICAL :: Found
    CHARACTER(LEN=MAX_NAME_LEN) :: str
!------------------------------------------------------------------------------
!
!
    FORMAT = MATRIX_CRS

!
! TODO: The following code always selects the MATRIX_CRS as format
! and should be removed...
! -----------------------------------------------------------------
    DO i=1,Model % NumberOfSolvers
       FORMAT = MATRIX_CRS

       IF (  &
            ListGetString(Model % Solvers(i) % Values, 'Equation') == Equation &
            ) THEN

          str = ListGetString( Model % Solvers(i) % Values, & 
                  'Linear System Solver', Found )

          IF ( str == 'direct' ) THEN
             str = ListGetString(Model % Solvers(i) % Values, &
                  'Linear System Direct Method', Found )

             IF ( ParEnv % PEs>1 ) THEN
               IF ( str /= 'mumps' ) &
                 CALL Fatal( 'GetMatrixFormat', 'Only MUMPS direct solver' // &
                                ' implemented in parallel!')
             ELSE
               IF ( str == 'mumps' ) &
                 CALL Fatal( 'GetMatrixFormat', 'Currently no serial version' // &
                           ' of the MUMPS solver implemented, sorry!')
             END IF

             IF ( .NOT. Found ) THEN
             ELSE
                SELECT CASE( str )
                CASE( 'umfpack', 'big umfpack' )
#include "../config.h"
#ifndef HAVE_UMFPACK
                   CALL Fatal( 'GetMatrixFormat', 'UMPACK solver has not been installed.' )
#endif
                CASE( 'mumps' )
#ifndef HAVE_MUMPS
                   CALL Fatal( 'GetMatrixFormat', 'MUMPS solver has not been installed.' )
#endif
                CASE( 'superlu' )
#ifndef HAVE_SUPERLU
                   CALL Fatal( 'GetMatrixFormat', 'SuperLU solver has not been installed.' )
#endif
                CASE( 'pardiso' )
#ifndef HAVE_PARDISO
                   CALL Fatal( 'GetMatrixFormat', 'Pardiso solver has not been installed.' )
#endif
                CASE DEFAULT
                   CALL Warn( 'GetMatrixFormat', 'Unknown direct solver method: ' // TRIM(str) )
                   CALL Warn( 'GetMatrixFormat', 'band solver (LAPACK) will be used.' )
                END SELECT
             END IF
          END IF

          EXIT
       END IF
    END DO
!------------------------------------------------------------------------------
  END FUNCTION GetMatrixFormat
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddSolverProcedure( Solver,PROCEDURE  )
!------------------------------------------------------------------------------
    TYPE(Solver_t) :: Solver
    EXTERNAL :: PROCEDURE
    INTEGER  :: PROCEDURE
!------------------------------------------------------------------------------
    INTEGER(KIND=AddrInt) :: AddrFunc
!------------------------------------------------------------------------------
    Solver % PROCEDURE = AddrFunc( PROCEDURE )
!------------------------------------------------------------------------------
  END SUBROUTINE AddSolverProcedure
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddEquationBasics( Solver, Name,Transient )
!------------------------------------------------------------------------------
    TYPE(Solver_t), POINTER :: Solver
    LOGICAL :: Transient
    CHARACTER(LEN=*) :: Name
!------------------------------------------------------------------------------
    REAL(KIND=dp), POINTER :: Solution(:)

    INTEGER, POINTER :: Perm(:)

    INTEGER(KIND=AddrInt) :: InitProc

    INTEGER :: MaxDGDOFs, MaxNDOFs, MaxEDOFs, MaxFDOFs, MaxBDOFs
    INTEGER :: i,j,k,l,NDeg,Nrows,nSize,n,m,DOFs,MatrixFormat,istat,Maxdim

    LOGICAL :: Found, Stat, BandwidthOptimize, EigAnal, ComplexFlag, &
    MultigridActive, VariableOutput, GlobalBubbles, HarmonicAnal, MGAlgebraic, &
    VariableGlobal, NoMatrix, IsAssemblySolver, IsCoupledSolver, IsBlockSolver

    CHARACTER(LEN=MAX_NAME_LEN) :: str,eq,var_name, tmpname

    TYPE(ValueList_t), POINTER :: SolverParams
    TYPE(Mesh_t),   POINTER :: NewMesh,OldMesh
    TYPE(Element_t), POINTER :: CurrentElement
    TYPE(Matrix_t), POINTER :: NewMatrix, Oldmatrix

    TYPE(Variable_t), POINTER :: Var
    TYPE(Variable_t), POINTER :: NewVariable

    REAL(KIND=dp) :: tt, CPUTime, InitValue
    REAL(KIND=dp), POINTER :: freqv(:,:)
    REAL(KIND=dp), POINTER :: Component(:)

    EXTERNAL FlowSolver, HeatSolver, MagneticSolver, StressSolver, MeshSolver
    INTEGER :: FlowSolver, HeatSolver, MagneticSolver, StressSolver, MeshSolver

    !------------------------------------------------------------------------------


    SolverParams => Solver % Values

    eq = ListGetString( SolverParams, 'Equation', Found )
    IF ( Found ) THEN
      MAXdim = 0
      DO i=1,Solver % Mesh % NumberOfBulkElements+Solver % Mesh % NumberOFBoundaryElements
        CurrentElement => Solver % Mesh % Elements(i)
        IF ( CheckElementEquation( CurrentModel, CurrentElement, eq ) ) THEN
          Maxdim = MAX( CurrentElement % TYPE % DIMENSION, Maxdim )
        END IF
      END DO
      CALL ListAddInteger( SolverParams, 'Active Mesh Dimension', Maxdim )
    END IF

    str = ListGetString( Solver  % Values, 'Procedure', Found )
    IF ( Found ) THEN
      InitProc = GetProcAddr( TRIM(str)//'_Init', abort=.FALSE. )
      IF ( InitProc /= 0 ) THEN
        CALL ExecSolver( InitProc, CurrentModel, Solver, &
            Solver % dt, Transient )
      END IF
    END IF
     
    Solver % SolverMode = SOLVER_MODE_DEFAULT
    IF( ListGetLogical( SolverParams, 'Auxiliary Solver', Found ) ) &
        Solver % SolverMode = SOLVER_MODE_COUPLED
    IF( ListGetLogical( SolverParams, 'Coupled Solver', Found ) ) &
        Solver % SolverMode = SOLVER_MODE_COUPLED
    IF( ListGetLogical( SolverParams, 'Block Solver', Found ) ) &
        Solver % SolverMode = SOLVER_MODE_BLOCK
    IF( ListGetLogical( SolverParams, 'Assembly Solver', Found ) ) &
        Solver % SolverMode = SOLVER_MODE_ASSEMBLY

    IF( Solver % SolverMode == SOLVER_MODE_DEFAULT ) THEN
      eq = ListGetString( Solver  % Values, 'Equation', Found )
      IF(.NOT. Found ) Solver % SolverMode = SOLVER_MODE_AUXILIARY 
    END IF

    IsCoupledSolver = ( Solver % SolverMode == SOLVER_MODE_COUPLED ) 
    IsBlockSolver = ( Solver % SolverMode == SOLVER_MODE_BLOCK ) 
    IsAssemblySolver = ( Solver % SolverMode == SOLVER_MODE_ASSEMBLY ) 
    IsAssemblySolver = IsAssemblySolver .OR. IsCoupledSolver .OR. IsBlockSolver

    ! Default order of equation
    !--------------------------
    Solver % Order = 1
    Solver % TimeOrder = 1
    
    IF ( Transient ) THEN
      str = ListGetString( SolverParams, 'Timestepping Method',Found )
      IF ( .NOT. Found ) THEN
        str = ListGetString( CurrentModel % Simulation, 'Timestepping Method',Found )
        IF ( Found ) THEN
          CALL ListAddString( SolverParams, 'Timestepping Method', str )
        END IF
      END IF
      
      IF ( Found ) THEN
        IF (str=='bdf') THEN
          Solver % Order = ListGetInteger( SolverParams, &
              'BDF Order', Found, minv=1, maxv=5 )
          IF ( .NOT. Found ) THEN
            Solver % Order = ListGetInteger( CurrentModel % &
                Simulation, 'BDF Order', Found, minv=1, maxv=5 )
          END IF
          IF ( .NOT.Found ) THEN
            Solver % Order = 2
            CALL Warn( 'AddEquation', 'BDF order defaulted to 2.' )
          END IF
        ELSE IF ( str=='runge-kutta') THEN
          Solver % Order = ListGetInteger( CurrentModel % &
              Simulation, 'Runge-Kutta Order', Found, minv=2, maxv=4 )
          IF ( .NOT.Found ) Solver % Order = 2
        END IF
      ELSE
        CALL Warn( 'AddEquation', 'Time stepping method defaulted to IMPLICIT EULER' )
        CALL ListAddString( SolverParams, 'Timestepping Method', 'Implicit Euler' )
      END IF
    END IF

    !------------------------------------------------------------------------------

    DOFs = CoordinateSystemDimension()
    InitValue = 0.0_dp
    
    !------------------------------------------------------------------------------
    ! These are historical solvers that may be built-in on some .sif files
    ! Therefore some special strategies are used for them.
    !------------------------------------------------------------------------------
    SELECT CASE( Name )       
      !------------------------------------------------------------------------------
      
      !------------------------------------------------------------------------------
    CASE('navier-stokes')
      !------------------------------------------------------------------------------
      IF( .NOT. ListCheckPresent( SolverParams,'Variable') ) THEN        
        DOFs = CoordinateSystemDimension()        
        IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = DOFs + 1
        IF( Dofs == 3 ) THEN
          CALL ListAddString( SolverParams,'Variable','Flow Solution[Velocity:3 Pressure:1]')
        ELSE
          CALL ListAddString( SolverParams,'Variable','Flow Solution[Velocity:2 Pressure:1]')
        END IF
      END IF
      IF( .NOT. ListCheckPresent( SolverParams,'Procedure') ) THEN      
        CALL AddSolverProcedure( Solver, FlowSolver )
      END IF
      InitValue = 1.0d-6
      !------------------------------------------------------------------------------

      !------------------------------------------------------------------------------
    CASE('magnetic induction')
      !------------------------------------------------------------------------------
      IF( .NOT. ListCheckPresent( SolverParams,'Variable') ) THEN        
        CALL ListAddString( SolverParams,'Variable','-dofs 3 Magnetic Field')
        CALL ListAddString( SolverParams,&
            NextFreeKeyword('Exported Variable',SolverParams),&
            'Electric Current[Electric Current:3]')                  
      END IF
      IF( .NOT. ListCheckPresent( SolverParams,'Procedure') ) THEN      
        CALL AddSolverProcedure( Solver, MagneticSolver )
      END IF
      !------------------------------------------------------------------------------      
      
      !------------------------------------------------------------------------------
    CASE('stress analysis')
      !------------------------------------------------------------------------------
      IF( .NOT. ListCheckPresent( SolverParams,'Variable') ) THEN
        IF( Dofs == 2 ) THEN
          CALL ListAddString( SolverParams,'Variable','-dofs 2 Displacement')
        ELSE
          CALL ListAddString( SolverParams,'Variable','-dofs 3 Displacement')
        END IF
      END IF
      IF( .NOT. ListCheckPresent( SolverParams,'Procedure') ) THEN      
        CALL AddSolverProcedure( Solver, StressSolver )
      END IF
      !------------------------------------------------------------------------------
            
      !------------------------------------------------------------------------------
    CASE('mesh update')
      !------------------------------------------------------------------------------
      IF( .NOT. ListCheckPresent( SolverParams,'Variable') ) THEN        
        IF( Dofs == 2 ) THEN
          CALL ListAddString( SolverParams,'Variable','-dofs 2 Mesh Update')
        ELSE
          CALL ListAddString( SolverParams,'Variable','-dofs 3 Mesh Update')
        END IF
      END IF

      IF( Transient ) THEN
        IF( Dofs == 2 ) THEN
          CALL ListAddString( SolverParams,&
              NextFreeKeyword('Exported Variable',SolverParams),&
              '-dofs 2 Mesh Velocity')        
        ELSE
          CALL ListAddString( SolverParams,&
              NextFreeKeyword('Exported Variable',SolverParams),&
              '-dofs 3 Mesh Velocity')                  
        END IF
      END IF

      IF( .NOT. ListCheckPresent( SolverParams,'Procedure') ) THEN      
        CALL AddSolverProcedure( Solver, MeshSolver )
      END IF
      !------------------------------------------------------------------------------
      
      !------------------------------------------------------------------------------
    CASE('heat equation')
      !------------------------------------------------------------------------------
      IF( .NOT. ListCheckPresent( SolverParams,'Variable') ) THEN
        CALL ListAddString( SolverParams,'Variable','Temperature')
      END IF
      
      IF( .NOT. ListCheckPresent( SolverParams,'Procedure') ) THEN      
        CALL AddSolverProcedure( Solver, HeatSolver )
      END IF

      IF( .NOT. ListCheckPresent( SolverParams,'Radiation Solver') ) THEN
        CALL ListAddLogical( SolverParams,'Radiation Solver',.TRUE.)
      END IF
      !------------------------------------------------------------------------------
    END SELECT


    ! Get the procudure that really runs the solver
    !------------------------------------------------------------------------------
    IF( Solver % PROCEDURE == 0 ) THEN
      str = ListGetString( SolverParams, 'Procedure', Found )        
      IF(Found) THEN
        Solver % PROCEDURE = GetProcAddr(str)
      ELSE
        IF(.NOT. IsAssemblySolver ) THEN
          CALL Fatal('AddEquationBasics','No procedure associated with equation')
        END IF
      END IF
    END IF
    
    ! Initialize and get the variable 
    !------------------------------------------------------------------------    
    Solver % TimeOrder = 0
    NULLIFY( Solver % Matrix )    
    var_name = ListGetString( SolverParams, 'Variable', Found )
    
    IF(.NOT. Found ) THEN
      ! Variable does not exist
      !------------------------------------------------------

      ALLOCATE( Solver % Variable )
      Solver % Variable % Name = ''
      Solver % Variable % NameLen = 0
      Solver % Variable % Norm = 0.0d0
      NULLIFY( Solver % Variable % Perm )
      NULLIFY( Solver % Variable % Values )
      
      
    ELSE IF( IsCoupledSolver .OR. IsBlockSolver ) THEN
      ! Coupled solvers are treated differently
      !-----------------------------------------------------------------
      
    ELSE
      ! It may be a normal field variable or a global (0D) variable
      !------------------------------------------------------------------------
      VariableGlobal = ListGetLogical( SolverParams, 'Variable Global', Found )
      
      VariableOutput = ListGetLogical( SolverParams, 'Variable Output', Found )
      IF ( .NOT. Found ) VariableOutput = .TRUE.
      
      DOFs = ListGetInteger( SolverParams, 'Variable DOFs', Found, minv=1 )
      IF ( .NOT. Found ) THEN
        j = 0
        DOFs = 0
        DO WHILE( .TRUE. )
          i = INDEX( var_name(j+1:), ':' ) + j
          IF ( i<=j ) EXIT
          READ( var_name(i+1:),'(i1)' ) k
          DOFs = DOFs + k
          j = i + 1
        END DO
      END IF
      
      DO WHILE( var_name(1:1) == '-' )
        IF ( var_name(1:10) == '-nooutput ' ) THEN
          VariableOutput = .FALSE.
          var_name(1:LEN(var_name)-10) = var_name(11:)
        END IF
        
        IF ( var_name(1:8) == '-global ' ) THEN
          VariableGlobal = .TRUE.
          var_name(1:LEN(var_name)-8) = var_name(9:)
        END IF
        
        IF ( var_name(1:6) == '-dofs ' ) THEN
          READ( var_name(7:), * ) DOFs
          i = 7
          j = LEN_TRIM( var_name )
          DO WHILE( var_name(i:i) /= ' '  )
            i = i + 1
            IF ( i > j ) EXIT
          END DO
          var_name(1:LEN(var_name)-i) = var_name(i+1:)
        END IF
      END DO
      IF ( DOFs == 0 ) DOFs = 1
      
      n = LEN_TRIM(var_name)
      
      ! If the variable is 'global' it has nothing to do with the mesh and it may be simply 
      ! allocated. 
      !------------------------------------------------------------------------------------
      IF( VariableGlobal ) THEN
        Solver % SolverMode = SOLVER_MODE_GLOBAL
        ALLOCATE( Solution( DOFs ) )
        Solution = 0.0_dp
        
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver, &
            var_name(1:n), DOFs, Solution )
        Solver % Variable => VariableGet( Solver % Mesh % Variables, var_name(1:n) )
        IF( DOFs > 1 ) THEN
          DO i=1,DOFs
            tmpname = ComponentName( var_name(1:n), i )
            Component => Solution( i:i )
            CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                tmpname, 1, Component )
          END DO
        END IF
      ELSE        
        
        ! If the variable is a field variable create a permutation and matrix related to it
        !----------------------------------------------------------------------------------
        eq = ListGetString( SolverParams, 'Equation', Found )
        IF(.NOT. Found) THEN
          CALL Fatal('AddEquationBasics','Variable exists but equation is not defined')
        END IF
        Found = .FALSE.
        DO i=1, CurrentModel % NumberOfEquations
          IF( ListGetLogical( CurrentModel % Equations(i) % Values, TRIM(eq), Stat)) THEN
            Found = .TRUE.
            EXIT
          END IF
        END DO
        IF(.NOT. Found ) THEN
          CALL Fatal('AddEquationBasics','Variable exists but it is not associated to any equation')
        END IF
        

        ! Computate the size of the permutation vector
        !-----------------------------------------------------------------------------------------
        Ndeg = 0
        IF( Solver % SolverMode == SOLVER_MODE_DEFAULT .OR. &
            Solver % SolverMode == SOLVER_MODE_ASSEMBLY ) THEN
          eq = ListGetString( Solver  % Values, 'Equation', Found )
          MaxNDOFs  = 0
          MaxDGDOFs = 0
          DO i=1,Solver % Mesh % NumberOFBulkElements
            CurrentElement => Solver % Mesh % Elements(i)
            MaxDGDOFs = MAX( MaxDGDOFs, CurrentElement % DGDOFs )
            MaxNDOFs  = MAX( MaxNDOFs,  CurrentElement % NDOFs )
          END DO
          
          MaxEDOFs = 0
          DO i=1,Solver % Mesh % NumberOFEdges 
            CurrentElement => Solver % Mesh % Edges(i)
            MaxEDOFs  = MAX( MaxEDOFs,  CurrentElement % BDOFs )
          END DO
          
          MaxFDOFs = 0
          DO i=1,Solver % Mesh % NumberOFFaces 
            CurrentElement => Solver % Mesh % Faces(i)
            MaxFDOFs  = MAX( MaxFDOFs,  CurrentElement % BDOFs )
          END DO
          
          MaxBDOFs = 0
          DO i=1,Solver % Mesh % NumberOFBulkElements
            CurrentElement => Solver % Mesh % Elements(i)
            MaxBDOFs  = MAX( MaxBDOFs,  CurrentElement % BDOFs )
          END DO
          
          GlobalBubbles = ListGetLogical( SolverParams, 'Bubbles in Global System', Found )
          IF (.NOT.Found) GlobalBubbles = .TRUE.
          
          Ndeg = Ndeg + Solver % Mesh % NumberOfNodes 
          IF ( MaxEDOFs > 0 ) Ndeg = Ndeg + MaxEDOFs * Solver % Mesh % NumberOFEdges
          IF ( MaxFDOFs > 0 ) Ndeg = Ndeg + MaxFDOFs * Solver % Mesh % NumberOFFaces
          IF ( GlobalBubbles ) &
              Ndeg = Ndeg + MaxBDOFs * Solver % Mesh % NumberOfBulkElements
          IF ( ListGetLogical( SolverParams, 'Discontinuous Galerkin', Found ) ) &
              Ndeg = MAX( NDeg, MaxDGDOFs * (Solver % Mesh % NumberOfBulkElements+ &
              Solver % Mesh % NumberOfBoundaryElements) )
        END IF
        
        IF( ListGetLogical( SolverParams,'Radiation Solver',Found ) ) THEN
          !        eq = ListGetString( CurrentModel % Simulation, 'Gebhardt Factors',Found )
          !        IF ( Found ) THEN
          !          CALL LoadGebhardtFactors( Solver % Mesh,eq )
          !        ELSE
          CALL RadiationFactors( Solver, .TRUE.)
          !        END IF
        END IF
        
        BandwidthOptimize = ListGetLogical( SolverParams, &
            'Optimize Bandwidth', Found )
        IF ( .NOT. Found ) BandwidthOptimize = .TRUE.
        MatrixFormat = GetMatrixFormat( CurrentModel, Name )

        ALLOCATE( Perm(Ndeg) )
        Perm = 0
        Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
            Perm, DOFs, MatrixFormat, BandwidthOptimize, eq(1:LEN_TRIM(eq)), &
            ListGetLogical( SolverParams,'Discontinuous Galerkin', Found ), &
            GlobalBubbles=GlobalBubbles )          
        Nrows = DOFs * Ndeg
        IF (ASSOCIATED(Solver % Matrix)) Nrows = Solver % Matrix % NumberOfRows
        
        ! Basically the solver could be matrix free but still the matrix
        ! is used here temperarily since it is needed when making the 
        ! permutation vector
        !-----------------------------------------------------------------
        IF( ListGetLogical( SolverParams, 'No Matrix', Found ) ) THEN
          Solver % SolverMode = SOLVER_MODE_MATRIXFREE
          CALL FreeMatrix( Solver % Matrix )
        END IF
       

        IF ( Nrows > 0 ) THEN
          ALLOCATE( Solution( Nrows ) )
          Solution = InitValue
          
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver, &
              var_name(1:n), DOFs, Solution, Perm, Output=VariableOutput )          
          Solver % Variable => VariableGet( Solver % Mesh % Variables, var_name(1:n) )
          
          IF ( DOFs > 1 ) THEN
            DO i=1,DOFs
              tmpname = ComponentName( var_name(1:n), i )
              Component => Solution( i:Nrows-DOFs+i:DOFs )
              CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                  tmpname, 1, Component, Perm, Output=VariableOutput )
            END DO
          END IF
        END IF

        IF ( ASSOCIATED(Solver % Matrix) ) THEN
          Solver % Matrix % Comm = MPI_COMM_WORLD
          IF ( Solver % Matrix % DGMatrix ) &
              Solver % Variable % TYPE = Variable_on_nodes_on_elements
        END IF
      END IF
      !------------------------------------------------------------------------------
    END IF
    
    !------------------------------------------------------------------------------
    ! Add the exported variables which are typically auxiliary variables derived
    ! from the solution without their own matrix equation.  
    !------------------------------------------------------------------------------
    l = 0
    DO WHILE( .TRUE. )
      l = l + 1
      str = ComponentName( 'exported variable', l )
      var_name = ListGetString( SolverParams, str, Found )
      
      IF(.NOT. Found) EXIT
      
      str = TRIM( ComponentName( 'exported variable', l ) ) // ' Output'
      VariableOutput = ListGetLogical( SolverParams, str, Found )
      IF ( .NOT. Found ) VariableOutput = .TRUE.
      
      str = TRIM( ComponentName( 'exported variable', l ) ) // ' DOFs'
      DOFs = ListGetInteger( SolverParams, str, Found )
      IF ( .NOT. Found ) THEN
        j = 0
        DOFs = 0
        DO WHILE( .TRUE. )
          i = INDEX( var_name(j+1:), ':' ) + j
          IF ( i<=j ) EXIT
          READ( var_name(i+1:),'(i1)' ) k
          DOFs = DOFs + k
          j = i + 1
        END DO
      END IF
      
      VariableOutput = .TRUE.
      VariableGlobal = .FALSE.
      
      DO WHILE( var_name(1:1) == '-' )
        IF ( var_name(1:10) == '-nooutput ' ) THEN
          VariableOutput = .FALSE.
          var_name(1:LEN(var_name)-10) = var_name(11:)
        END IF
        
        IF ( var_name(1:8) == '-global ' ) THEN
          VariableGlobal = .TRUE.
          var_name(1:LEN(var_name)-8) = var_name(9:)
        END IF
        
        IF ( var_name(1:6) == '-dofs ' ) THEN
          READ( var_name(7:), * ) DOFs 
          j = LEN_TRIM( var_name )
          k = 7
          DO WHILE( var_name(k:k) /= ' '  )
            k = k + 1
            IF ( k > j ) EXIT
          END DO
          var_name(1:LEN(var_name)-(k+2)) = var_name(k+1:)
        END IF
      END DO
      IF ( DOFs == 0 ) DOFs = 1
      
      NewVariable => VariableGet( Solver % Mesh % Variables, Var_name )
      
      IF ( .NOT. ASSOCIATED(NewVariable) ) THEN
        IF( VariableGlobal ) THEN
          nSize = DOFs
          NULLIFY( Perm )
        ELSE
          nSize = DOFs * SIZE(Solver % Variable % Values) / Solver % Variable % DOFs
          Perm => Solver % Variable % Perm
        END IF
        
        ALLOCATE( Solution(nSize) )
        Solution = 0.0d0
        IF( ASSOCIATED(Perm) ) THEN
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
              var_name, DOFs, Solution, Solver % Variable % Perm, &
              Output=VariableOutput, TYPE=Solver % Variable % TYPE )
        ELSE          
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
              var_name, DOFs, Solution, TYPE=Solver % Variable % TYPE )
        END IF
        
        IF ( DOFs > 1 .AND. .NOT. VariableGlobal ) THEN
          n = LEN_TRIM( var_name )
          DO j=1,DOFs
            tmpname = ComponentName( var_name(1:n), j )
            Component => Solution( j:nSize-DOFs+j:DOFs )
            IF( ASSOCIATED(Perm) ) THEN
              CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                  tmpname, 1, Component, Perm,  &
                  Output=VariableOutput, TYPE=Solver % Variable % TYPE )
            ELSE
              CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                  tmpname, 1, Component, TYPE=Solver % Variable % TYPE )
            END IF
          END DO
        END IF
      END IF
    END DO


    !------------------------------------------------------------------
    ! Check for special solvers, to be executed only 
    ! at a certain instances during the simulation:
    !------------------------------------------------------------------

    Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS

    SELECT CASE( ListGetString( SolverParams, 'Exec Solver', Found )  )
      CASE( 'never' )
      Solver % SolverExecWhen = SOLVER_EXEC_NEVER
      CASE( 'always' )
      Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS
      CASE( 'after simulation', 'after all' )
      Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
      CASE( 'before simulation', 'before all' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
      CASE( 'before timestep' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_TIME
      CASE( 'after timestep' )
         Solver % SolverExecWhen = SOLVER_EXEC_AFTER_TIME
      CASE( 'before saving' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_SAVE
      CASE( 'after saving' )
         Solver % SolverExecWhen = SOLVER_EXEC_AFTER_SAVE
      CASE DEFAULT
         Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS
    END SELECT

    IF ( ListGetLogical( SolverParams, 'Before All', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
    ELSE IF ( ListGetLogical( SolverParams, 'Before Simulation', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
    ELSE IF ( ListGetLogical( SolverParams, 'After All', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
    ELSE IF ( ListGetLogical( SolverParams, 'After Simulation', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
    ELSE IF ( ListGetLogical( SolverParams, 'Before Timestep', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_TIME
    ELSE IF ( ListGetLogical( SolverParams, 'After Timestep', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_TIME
    ELSE IF ( ListGetLogical( SolverParams, 'Before Saving', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_SAVE
    ELSE IF ( ListGetLogical( SolverParams, 'After Saving', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_SAVE
    END IF

    Solver % LinAfterProc  = 0
    Solver % LinBeforeProc = 0
    str = ListGetString( Solver  % Values, 'Before Linsolve', Found )
    IF ( Found ) Solver % LinBeforeProc = GetProcAddr( str )

    str = ListGetString( Solver  % Values, 'After Linsolve', Found )
    IF ( Found ) Solver % LinAfterProc = GetProcAddr( str )

    str = ListGetString( Solver  % Values, 'Matrix Vector Proc', Found )
    IF ( Found ) Solver % Matrix % MatVecSubr = GetProcAddr( str )

  END SUBROUTINE AddEquationBasics


  !------------------------------------------------------------------------------
  SUBROUTINE AddEquationSolution(Solver, Transient )
    !------------------------------------------------------------------------------
    ! Add information that is typically only needed if there's a matrix equation
    ! to work with. This should be called only after both the solution vector and
    ! matrix have been created.
    !------------------------------------------------------------------------------  
    TYPE(Solver_t), POINTER :: Solver
    LOGICAL :: Transient
!------------------------------------------------------------------------------
    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=MAX_NAME_LEN) :: str, var_name, tmpname
    INTEGER :: i,j,k,n,nrows,DOFs
    REAL(KIND=dp), POINTER :: Solution(:)
    INTEGER, POINTER :: Perm(:)
    LOGICAL :: Found, Stat, ComplexFlag, HarmonicAnal,EigAnal,VariableOutput, &
        MGAlgebraic,MultigridActive
    REAL(KIND=dp), POINTER :: Component(:)
    REAL(KIND=dp), POINTER :: freqv(:,:)
    TYPE(Mesh_t),   POINTER :: NewMesh,OldMesh
    TYPE(Element_t), POINTER :: CurrentElement
    TYPE(Matrix_t), POINTER :: NewMatrix, Oldmatrix, SaveMatrix

    !------------------------------------------------------------------------------
    Solver % DoneTime = 0
    IF ( .NOT. ASSOCIATED( Solver % Variable ) ) RETURN
    IF ( .NOT. ASSOCIATED(Solver % Variable % Values) ) RETURN
    !------------------------------------------------------------------------------

	
    !------------------------------------------------------------------------------
    ! If soft limiters are applied then also loads must be computed
    !------------------------------------------------------------------------------
     IF( ListGetLogical( Solver % Values,'Apply Limiter',Found) ) THEN
       CALL ListAddLogical( Solver % Values,'Calculate Loads',.TRUE.)
     END IF
	    
    !------------------------------------------------------------------------------
    ! Create the variable needed for the computation of nodal loads: r=b-Ax
    !------------------------------------------------------------------------------
    IF ( ListGetLogical( Solver % Values,'Calculate Loads', Found ) ) THEN
      Var_name = GetVarName(Solver % Variable) // ' Loads'
      Var => VariableGet( Solver % Mesh % Variables, var_name )
      IF ( .NOT. ASSOCIATED(Var) ) THEN
        ALLOCATE( Solution(SIZE(Solver % Variable % Values)) )
        DOFs = Solver % Variable % DOFs
        Solution = 0.0d0
        nrows = SIZE( Solution ) 
        Perm => Solver % Variable % Perm
        VariableOutput = Solver % Variable % Output

        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
            var_name, Solver % Variable % DOFs, Solution, &
            Solver % Variable % Perm, Output=VariableOutput )

        IF ( DOFs > 1 ) THEN
          n = LEN_TRIM( Var_name )
          DO j=1,DOFs
            tmpname = ComponentName( var_name(1:n), j )
            Component => Solution( j:nRows-DOFs+j:DOFs )
            CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                tmpname, 1, Component, Perm, Output=VariableOutput )
          END DO
        END IF
        NULLIFY( Solution )
      END IF
    END IF

    !------------------------------------------------------------------------------
    ! Add computation of the weights resulting from Galerkin integration
    !------------------------------------------------------------------------------
    IF ( ListGetLogical( Solver % Values,'Calculate Weights', Found ) ) THEN
      Var_name = GetVarName(Solver % Variable) // ' Weights'
      Var => VariableGet( Solver % Mesh % Variables, var_name )
      IF ( .NOT. ASSOCIATED(Var) ) THEN
        Perm => Solver % Variable % Perm
        IF( ASSOCIATED( Perm ) ) THEN
          ALLOCATE( Solution(SIZE(Solver % Variable % Perm)) )
          Solution = 0.0d0        
          VariableOutput = Solver % Variable % Output
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
              var_name, 1, Solution, &
              Solver % Variable % Perm, Output=VariableOutput )
          NULLIFY( Solution )
        END IF
      END IF
    END IF
    !------------------------------------------------------------------------------

    Solver % NOFEigenValues = 0
    !   NULLIFY( Solver % Variable % PrevValues )
    !   NULLIFY( Solver % Variable % EigenValues )
    !   NULLIFY( Solver % Variable % EigenVectors )

    Solver % MultiGridLevel = 1
    Solver % MultiGridTotal = 0
    Solver % MultiGridSolver = .FALSE.
    Solver % MultiGridEqualSplit = .FALSE.


    HarmonicAnal = ListGetLogical( Solver % Values, 'Harmonic Analysis', Found )
    
    IF ( ASSOCIATED( Solver % Matrix ) ) THEN
      IF(.NOT. ASSOCIATED(Solver % Matrix % RHS)) THEN
        ALLOCATE( Solver % Matrix % RHS(Solver % Matrix % NumberOFRows) )
        Solver % Matrix % RHS = 0.0d0
        
        Solver % Matrix % RHS_im => NULL()
        IF ( HarmonicAnal ) THEN
          ALLOCATE( Solver % Matrix % RHS_im(Solver % Matrix % NumberOFRows) )
          Solver % Matrix % RHS_im = 0.0d0
        END IF
      END IF
    END IF
!------------------------------------------------------------------------------

    EigAnal = ListGetLogical( Solver % Values, 'Eigen Analysis', Found )
    
    IF ( Transient .AND. .NOT. EigAnal .AND. .NOT. HarmonicAnal ) THEN
      k = ListGetInteger( Solver % Values, 'Time Derivative Order', Found, &
          minv=0, maxv=2 )
      Solver % TimeOrder = 1
      IF ( Found ) Solver % TimeOrder = MIN(MAX(1,k),2)
      
      IF ( ASSOCIATED( Solver % Matrix ) ) THEN
        ALLOCATE( Solver % Matrix % Force(Solver % Matrix % NumberOFRows, &
            Solver % TimeOrder+1) )
        Solver % Matrix % Force = 0.0d0
      END IF
      
      IF ( .NOT. ASSOCIATED( Solver % Variable % PrevValues ) ) THEN
        IF ( Solver % TimeOrder == 2 ) THEN
          ALLOCATE( Solver % Variable % PrevValues( &
              SIZE(Solver % Variable % Values),5) )
        ELSE IF ( Solver % Order > Solver % TimeOrder ) THEN
          ALLOCATE(Solver % Variable % PrevValues( &
              SIZE(Solver % Variable % Values), Solver % Order))
        ELSE
          ALLOCATE(Solver % Variable % PrevValues( &
              SIZE(Solver % Variable % Values), Solver % TimeOrder))
        END IF
        Solver % Variable % PrevValues = 0.0d0
        
        IF ( Solver % Variable % DOFs > 1 ) THEN
          IF ( Solver % Variable % Name == 'flow solution' ) THEN
            DO k=1,Solver % Variable % DOFs-1
              str = 'Velocity ' // CHAR(k+ICHAR('0'))
              Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
              Var % PrevValues =>  &
                  Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
            END DO
            Var => VariableGet( Solver % Mesh % Variables, 'Pressure', .TRUE. )
            Var % PrevValues =>  &
                Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
          ELSE
            DO k=1,Solver % Variable % DOFs
              str = ComponentName( Solver % Variable % Name, k ) 
              Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
              Var % PrevValues =>  &
                  Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
            END DO
          END IF
        END IF
      END IF


      IF( ListGetLogical( Solver % Values,'Calculate Velocity',Found) ) THEN
        IF ( Solver % TimeOrder == 1 ) THEN
          ALLOCATE( Solution( SIZE( Solver % Variable % Values) ) )
          Solution = 0.0_dp
          str = TRIM( Solver % Variable % Name ) // ' Velocity'
          CALL VariableAddVector( Solver % Mesh % Variables, Solver % Mesh, Solver, &
              str, Solver % Variable % Dofs, Solution, Solver % Variable % Perm )
          NULLIFY( Solution )
        ELSE IF ( Solver % TimeOrder >= 2 ) THEN
          Component => Solver % Variable % PrevValues(:,1)
          str = TRIM( Solver % Variable % Name ) // ' Velocity'
          CALL VariableAddVector( Solver % Mesh % Variables, Solver % Mesh, Solver, &
              str, Solver % Variable % Dofs, Component, Solver % Variable % Perm, &
              Secondary = .TRUE. )
        END IF
      END IF

      IF( ListGetLogical( Solver % Values,'Calculate Acceleration',Found) ) THEN
        IF ( Solver % TimeOrder == 1 ) THEN
          CALL Warn('AddEquationSolution',&
              'No velocity computation implemented for 1st order time integration')
        ELSE IF ( Solver % TimeOrder >= 2 ) THEN
          Component => Solver % Variable % PrevValues(:,2)
          str = TRIM( Solver % Variable % Name ) // ' Acceleration'
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver, &
              str, Solver % Variable % Dofs, Component, Solver % Variable % Perm, &
              Secondary = .TRUE. )
          
          DO k=1,Solver % Variable % DOFs
            Component => Solver % Variable % PrevValues(k::Solver % Variable % DOFs,2)          
            str = ComponentName( Solver % Variable % Name) // ' Acceleration ' // CHAR(i+ICHAR('0'))
            CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver, &
                str, 1, Component, Solver % Variable % Perm, Secondary = .TRUE. )
          END DO
        END IF
      END IF

    ELSE
      Solver % TimeOrder = 0

      IF( ListGetLogical( Solver % Values,'Calculate Derivative',Found) ) THEN
        NULLIFY( Solution ) 
        ALLOCATE( Solution( SIZE( Solver % Variable % Values) ) )
        Solution = 0.0_dp
        str = TRIM( Solver % Variable % Name ) // ' Derivative'
        CALL VariableAddVector( Solver % Mesh % Variables, Solver % Mesh, Solver, &
            str, Solver % Variable % Dofs, Solution, Solver % Variable % Perm )
        NULLIFY( Solution )
      END IF

      IF ( EigAnal ) THEN
        ComplexFlag = ListGetLogical( Solver % Values,  'Eigen System Complex', Found )
        IF ( .NOT. Found ) ComplexFlag = .FALSE.
        
        n = ListGetInteger( Solver % Values,  'Eigen System Values', Found )
        IF ( Found .AND. n > 0 ) THEN
          Solver % NOFEigenValues = n
          IF ( .NOT. ASSOCIATED( Solver % Variable % EigenValues ) ) THEN
            ALLOCATE( Solver % Variable % EigenValues(n) )
            ALLOCATE( Solver % Variable % EigenVectors(n, &
                SIZE( Solver % Variable % Values ) ) )
            
            Solver % Variable % EigenValues  = 0.0d0
            Solver % Variable % EigenVectors = 0.0d0
            
            DO k=1,Solver % Variable % DOFs
              str = ComponentName( Solver % Variable % Name, k )
              Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
              IF ( ASSOCIATED( Var ) ) THEN
                Var % EigenValues => Solver % Variable % EigenValues
                IF ( ComplexFlag ) THEN
                  Var % EigenVectors => Solver % Variable % EigenVectors
                ELSE
                  Var % EigenVectors =>  & 
                      Solver % Variable % EigenVectors(:,k::Solver % Variable % DOFs )
                END IF
              END IF
            END DO
          END IF
          ALLOCATE( Solver % Matrix % MassValues(SIZE(Solver % Matrix % Values)) )
          Solver % Matrix % MassValues = 0.0d0
        END IF
      ELSE IF ( HarmonicAnal ) THEN
        freqv => ListGetConstRealArray( Solver % Values, 'Frequency', Found )
        IF ( Found ) THEN
          n = SIZE(Freqv,1)
          Solver % NOFEigenValues = n
          IF ( .NOT. ASSOCIATED( Solver % Variable % EigenValues ) ) THEN
            ALLOCATE( Solver % Variable % EigenValues(n) )
            ALLOCATE( Solver % Variable % EigenVectors(n, &
                SIZE( Solver % Variable % Values ) ) )
            
            Solver % Variable % EigenValues  = 0.0d0
            Solver % Variable % EigenVectors = 0.0d0
            
            DO k=1,Solver % Variable % DOFs
              str = ComponentName( Solver % Variable % Name, k )
              Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
              IF ( ASSOCIATED( Var ) ) THEN
                Var % EigenValues => Solver % Variable % EigenValues
                Var % EigenVectors => &
                    Solver % Variable % EigenVectors(:,k::Solver % Variable % DOFs)
              END IF
            END DO
          END IF
          ALLOCATE( Solver % Matrix % MassValues(SIZE(Solver % Matrix % Values)) )
          Solver % Matrix % MassValues = 0.0d0
        ELSE
          CALL Fatal( 'AddEquation', 'Frequency must be given for harmonic analysis.' )
        END IF
      END IF
    END IF


!------------------------------------------------------------------------------

    IF ( ASSOCIATED( Solver % Matrix ) ) THEN
      Solver % Matrix % Symmetric = ListGetLogical( Solver % Values, &
          'Linear System Symmetric', Found )
      
      Solver % Matrix % Lumped = ListGetLogical( Solver % Values, &
          'Lumped Mass Matrix', Found )
      
      MultigridActive = &
          ListGetString( Solver % Values, 'Linear System Solver', Found ) == 'multigrid' .OR. &
          ListGetString( Solver % Values, 'Linear System Preconditioning', Found ) == 'multigrid'


!      Check for multigrid solver:
!      ---------------------------
       IF ( MultigridActive ) THEN

         str = ListGetString( Solver % Values,'MG Method',Found) 
         IF( Found ) THEN
           MGAlgebraic = ( str == 'algebraic' ) .OR. ( str == 'cluster')
         ELSE    
           MGAlgebraic = ListGetLogical( Solver % Values, 'MG Algebraic', Found ) &
              .OR. ListGetLogical( Solver % Values, 'MG Cluster', Found )
         END IF
         
         Solver % MultiGridTotal = ListGetInteger( Solver % Values, &
             'MG Levels', Found, minv=1 )
         
         IF ( .NOT. Found ) THEN
           Solver % MultiGridTotal = ListGetInteger( Solver % Values, &
               'Multigrid Levels', Found, minv=1 )
         END IF
         IF ( .NOT. Found ) THEN
           IF( MGAlgebraic ) THEN 
             Solver % MultiGridTotal = 10
           ELSE
             Solver % MultiGridTotal = 3
           END IF
         END IF

!         Check if h/2 splitting of mesh requested:
!         ------------------------------------------
         Solver % MultiGridEqualSplit = ListGetLogical( &
             Solver % Values, 'MG Equal Split', Found )
         
         IF ( Solver % MultiGridEqualSplit ) THEN
           CALL ParallelInitMatrix( Solver, Solver % Matrix )
           Solver % MultiGridLevel = 1

           DO WHILE( Solver % MultiGridLevel < Solver % MultiGridTotal )
             IF ( ASSOCIATED( Solver % Mesh % Child ) ) THEN
               NewMesh => Solver % Mesh % Child
               
               OldMesh   => Solver % Mesh
               OldMatrix => Solver % Matrix
               
               CALL UpdateSolverMesh( Solver, NewMesh )
               Solver % Mesh % Changed = .FALSE.
             ELSE
               NewMesh => SplitMeshEqual( Solver % Mesh )
               NewMesh % Next => CurrentModel % Meshes
               CurrentModel % Meshes => NewMesh
               
               OldMesh   => Solver % Mesh
               OldMatrix => Solver % Matrix
               
               CALL UpdateSolverMesh( Solver, NewMesh )
               Solver % Mesh % Changed = .FALSE.
               
               NewMesh % Parent => OldMesh
               OldMesh % Child  => NewMesh
               NewMesh % Name = OldMesh % Name
             END IF
             Newmesh % OutputActive = .TRUE.
             OldMesh % OutputActive = .FALSE.
             
             NewMatrix => Solver % Matrix
             NewMatrix % Parent => OldMatrix
             OldMatrix % Child  => NewMatrix
             CALL ParallelInitMatrix( Solver, Solver % Matrix )
             Solver % MultiGridLevel = Solver % MultiGridLevel + 1
           END DO
         ELSE
           CALL ParallelInitMatrix( Solver, Solver % Matrix )
           OldMesh   => Solver % Mesh
           Var => Solver % Variable
           SaveMatrix => Solver % Matrix

           Solver % MultiGridLevel = 1
           DO WHILE( Solver % MultiGridLevel < Solver % MultigridTotal )
             IF ( ASSOCIATED(Solver % Mesh % Parent) ) THEN
               NewMesh => Solver % Mesh % Parent
               OldMatrix => Solver % Matrix
               CALL UpdateSolverMesh( Solver, NewMesh )
               Solver % Mesh % Changed = .FALSE.
               NewMatrix => Solver % Matrix
               NewMatrix % Child => OldMatrix
               OldMatrix % Parent  => NewMatrix
               CALL ParallelInitMatrix(Solver, Solver % Matrix )
             END IF
             Solver % MultiGridLevel = Solver % MultiGridLevel+1
           END DO

           Solver % Mesh => OldMesh
           Solver % Variable => Var
           Solver % Matrix => SaveMatrix
           CALL SetCurrentMesh(CurrentModel,Solver % Mesh)
         END IF

         CALL MeshStabParams( Solver % Mesh )
         Solver % MultiGridSolver = ListGetString(Solver % Values, &
             'Linear System Solver', Found ) == 'multigrid'
         Solver % MultiGridLevel  = Solver % MultiGridTotal
       END IF
     END IF
     
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
   END SUBROUTINE AddEquationSolution
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE SolveEquations( Model, dt, TransientSimulation, &
      CoupledMinIter, CoupledMaxIter, SteadyStateReached, RealTimestep )
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    REAL(KIND=dp) :: dt
    INTEGER, OPTIONAL :: RealTimestep
    INTEGER :: CoupledMinIter, CoupledMaxIter
    LOGICAL :: TransientSimulation, SteadyStateReached
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: RelativeChange, Tolerance, PrevDT = 0.0d0, Relaxation
    INTEGER :: i,j,k,l,n,ierr,istat,Visited=0, RGorder=0, nSolvers
    LOGICAL :: Found, Stat, AbsNorm, Scanning, Convergence, RungeKutta, MeActive, &
       NeedSol, CalculateDerivative, TestConvergence
    LOGICAL, ALLOCATABLE :: DoneThis(:), AfterConverged(:)
    TYPE(Solver_t), POINTER :: Solver
    TYPE(Mesh_t),   POINTER :: Mesh
    CHARACTER(LEN=max_name_len) :: When
    TYPE(Variable_t), POINTER :: IterV, TimestepV
    REAL(KIND=dp), POINTER :: steadyIt,nonlnIt
    REAL(KIND=dp), POINTER :: k1(:), k2(:), k3(:), k4(:)

    TYPE RungeKutta_t
      REAL(KIND=dp), ALLOCATABLE :: k1(:),k2(:),k3(:),k4(:)
    END TYPE RungeKutta_t
    TYPE(RungeKutta_t), ALLOCATABLE, TARGET :: RGCoeff(:)
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!   Intialize equation solvers for new timestep
!------------------------------------------------------------------------------
    nSolvers = Model % NumberOfSolvers

    Scanning = &
      ListGetString( CurrentModel % Simulation, 'Simulation Type', Found ) == 'scanning'

    IF ( TransientSimulation ) THEN
       DO k=1,nSolvers
          Solver => Model % Solvers(k)
          IF ( Solver % PROCEDURE /= 0 ) CALL InitializeTimestep(Solver)
       END DO
    END IF

    IF( TransientSimulation .OR. Scanning ) THEN
       IterV => VariableGet(Model % Solvers(1) % Mesh % Variables, 'coupled iter')
       steadyIt => IterV % Values(1)
    END IF
!------------------------------------------------------------------------------

    DO k=1,nSolvers
      Solver => Model % Solvers(k)
      IF ( Solver % PROCEDURE==0 ) CYCLE

      when  = ListGetString( Solver % Values, 'Exec Solver', Found )
      IF ( Found ) THEN
        IF ( When == 'before timestep' ) THEN
          CALL SolverActivate( Model,Solver,dt,TransientSimulation )
          CALL ParallelBarrier
        END IF
      ELSE
        IF ( Solver % SolverExecWhen == SOLVER_EXEC_AHEAD_TIME ) THEN
          CALL SolverActivate( Model,Solver,dt,TransientSimulation )
          CALL ParallelBarrier
        END IF
      END IF
    END DO

!------------------------------------------------------------------------------

    ALLOCATE( DoneThis(nSolvers), AfterConverged(nSolvers) )

    DO i=1,nSolvers
      Solver => Model % Solvers(i)
      AfterConverged(i) = ListGetLogical( Solver % Values, &
             'Coupled System After Others Converged', Found )
    END DO

    IF ( PrevDT==0 ) PrevDT = dt

    IF ( RealTimestep>2 ) THEN
      DO i=1,nSolvers
        Solver => Model % Solvers(i)
        IF ( Solver % PROCEDURE==0 ) CYCLE

        RungeKutta = .FALSE.
        IF ( TransientSimulation .AND. Solver % TimeOrder == 1 ) THEN
            RungeKutta = ListGetString( Solver % Values, &
               'Timestepping Method', Found ) == 'runge-kutta'
        END IF

        IF ( .NOT. RungeKutta ) CYCLE

        IF ( .NOT. ALLOCATED(RGCoeff) ) ALLOCATE(RGCoeff(nSolvers))

        n = SIZE(Solver % Variable % Values)
        ALLOCATE(RGCoeff(i) % k1(n), RGCoeff(i) % k2(n), RGCoeff(i) % k3(n), &
                  RGCoeff(i) % k4(n) )

        k1 => RGCoeff(i) % k1
        k1 = Solver % Variable % PrevValues(:,1)-Solver % Variable % PrevValues(:,2)
        k1 = dt * k1 / PrevDT
        RGorder = Solver % Order
        SELECT CASE(RGOrder)
        CASE(2)
          Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k1
        CASE(4)
          Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k1/2
        END SELECT
      END DO
      IF ( RGorder==4 ) dt = dt/2
    END IF

    CALL SolveCoupled()

    IF ( ALLOCATED(RGCoeff) ) THEN
      DO i=1,nSolvers
        Solver => Model % Solvers(i)
        IF ( .NOT. ALLOCATED(RGCoeff(i) % k1)) CYCLE

        k1 => RGCoeff(i) % k1
        k2 => RGCoeff(i) % k2
        RGorder = Solver % Order
        SELECT CASE(RGorder)
        CASE(2)
          k2 = Solver % Variable % Values - Solver % Variable % PrevValues(:,1)
          Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + &
                         ( k1 + k2 )/2
          Solver % Variable % Norm = &
              ComputeNorm(Solver, n, Solver % Variable % Values)
        CASE(4)
          k2 = 2*(Solver % Variable % Values - Solver % Variable % PrevValues(:,1))
          Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k2/2
        END SELECT
      END DO

      IF ( RGorder>2 ) THEN
        CALL SolveCoupled()

        DO i=1,nSolvers
          Solver => Model % Solvers(i)
          IF ( .NOT. ALLOCATED(RGCoeff(i) % k1)) CYCLE

          k3 => RGCoeff(i) % k3
          k3 = 2*(Solver % Variable % Values - Solver % Variable % PrevValues(:,1))
          Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k3
        END DO
        dt = 2 * dt
        CALL SolveCoupled()

        DO i=1,nSolvers
          Solver => Model % Solvers(i)
          IF ( .NOT. ALLOCATED(RGCoeff(i) % k1)) CYCLE

          k1 => RGCoeff(i) % k1
          k2 => RGCoeff(i) % k2
          k3 => RGCoeff(i) % k3
          k4 => RGCoeff(i) % k4
          k4 = Solver % Variable % Values - Solver % Variable % PrevValues(:,1)

          Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + &
                             ( k1 + 2*k2 + 2*k3 + k4 ) / 6

          Solver % Variable % Norm = &
              ComputeNorm(Solver, n, Solver % Variable % Values)
        END DO
      END IF
        
      DO i=1,nSolvers
        Solver => Model % Solvers(i)
        IF ( ALLOCATED(RGCoeff(i) % k1) ) THEN
          DEALLOCATE(RGCoeff(i) % k1, RGCoeff(i) % k2, RGCoeff(i) % k3, RGCoeff(i) % k4)
        END IF
      END DO
      DEALLOCATE(RgCoeff)
    END IF

    PrevDt = dt

!------------------------------------------------------------------------------

    DO k=1,nSolvers
      Solver => Model % Solvers(k)
      IF ( Solver % PROCEDURE==0 ) CYCLE

      When = ListGetString( Solver % Values, 'Exec Solver', Found )
      IF (  Found ) THEN
         IF ( When == 'after timestep' ) THEN
           CALL SolverActivate( Model,Solver,dt,TransientSimulation )
           CALL ParallelBarrier
         END IF
      ELSE
         IF ( Solver % SolverExecWhen == SOLVER_EXEC_AFTER_TIME ) THEN
           CALL SolverActivate( Model,Solver,dt,TransientSimulation )
           CALL ParallelBarrier
         END IF
      END IF
    END DO

!------------------------------------------------------------------------------
    IF ( .NOT.TransientSimulation ) SteadyStateReached = ALL(DoneThis)
!------------------------------------------------------------------------------
    DEALLOCATE( DoneThis, AfterConverged )
!------------------------------------------------------------------------------

CONTAINS

    SUBROUTINE SolveCoupled()
!------------------------------------------------------------------------------
    DO i=1,CoupledMaxIter
       IF ( TransientSimulation .OR. Scanning ) THEN
         IF( CoupledMaxIter > 1 ) THEN
           CALL Info( 'SolveEquations', '-------------------------------------', Level=3 )
           WRITE( Message, * ) 'Coupled system iteration: ', i
           CALL Info( 'SolveEquations', Message, Level=3 )
           CALL Info( 'SolveEquations', '-------------------------------------', Level=3 )         
         END IF
         steadyIt = i
       END IF

       DoneThis = .FALSE.

!      Initialize the mesh output flag to FALSE here, reactivated
!      later for meshes connected to active solvers.
!      ----------------------------------------------------------
       Mesh => Model % Meshes
       DO WHILE( ASSOCIATED( Mesh ) )
          Mesh % OutputActive = .FALSE.
          Mesh => Mesh % Next
       END DO

!------------------------------------------------------------------------------
!      Go trough number of solvers (heat,laminar or turbulent flow, etc...)
!------------------------------------------------------------------------------
       DO k=1,Model % NumberOfSolvers
!------------------------------------------------------------------------------

          Solver => Model % Solvers(k)

          IF ( Solver % PROCEDURE == 0 ) THEN
            IF( .NOT. ( Solver % SolverMode == SOLVER_MODE_COUPLED .OR. &
              Solver % SolverMode == SOLVER_MODE_ASSEMBLY .OR. &
              Solver % SolverMode == SOLVER_MODE_BLOCK ) ) THEN

              CALL Warn('SolveEquations','No routine related to solver!')
              DoneThis(k) = .TRUE.
              CYCLE
            END IF
          END IF

          When = ListGetString( Solver % Values, 'Exec Solver', Found )
          IF ( Found ) THEN
            IF ( When /= 'always' ) THEN
              DoneThis(k) = .TRUE.
              CYCLE
            END IF
          ELSE
            IF ( Solver % SolverExecWhen /= SOLVER_EXEC_ALWAYS ) THEN
              DoneThis(k) = .TRUE.
              CYCLE
            END IF
          END IF

          IF ( AfterConverged(k) .AND. .NOT. ALL(AfterConverged .OR. DoneThis) ) CYCLE
!------------------------------------------------------------------------------

          n = 0
          IF ( ASSOCIATED(Solver % Variable) ) THEN
            IF ( ASSOCIATED(Solver % Variable % Values) ) &
                n = SIZE(Solver % Variable % Values)
            Solver % Variable % PrevNorm = Solver % Variable % Norm
          END IF

          ! There are some operations that require that the previous steady state values
          ! are present. Check for these operations.
          !------------------------------------------------------------------------------
          CalculateDerivative = ListGetLogical( Solver % Values, &
                'Calculate Derivative', Stat )

          NeedSol = CalculateDerivative
          IF(.NOT. NeedSol ) THEN
            NeedSol = ( ListGetString( Solver % Values, &
                'Steady State Convergence Measure', Stat ) /= 'norm')  
            NeedSol = NeedSol .AND. Stat
          END IF
          IF(.NOT. NeedSol ) THEN
            Relaxation = ListGetConstReal( Solver % Values, &
                'Steady State Relaxation Factor', Stat )
            NeedSol = Stat .AND. (Relaxation /= 1.0d0)
          END IF

          IF ( NeedSol .AND. n > 0 ) THEN
            Stat = ASSOCIATED(Solver % Variable % SteadyValues)
            IF(Stat .AND. SIZE(Solver % Variable % SteadyValues) /= n) THEN
              DEALLOCATE(Solver % Variable % SteadyValues)
              Stat = .FALSE.
            END IF
            IF(.NOT. Stat) THEN
              ALLOCATE( Solver % Variable % SteadyValues(n), STAT=istat ) 
              IF ( istat /= 0 ) CALL Fatal( 'SolveEquations', 'Memory allocation error.' )
            END IF
            Solver % Variable % SteadyValues(1:n) = Solver % Variable % Values(1:n)
          END IF

          CALL SolverActivate(Model,Solver,dt,TransientSimulation)
!------------------------------------------------------------------------------
!         check for coupled system convergence
!------------------------------------------------------------------------------

           IF ( Scanning ) THEN
             
             TestConvergence = ( i >= CoupledMinIter .AND. i /= CoupledMaxIter )

             IF ( TestConvergence .OR. CalculateDerivative ) THEN
               IF ( ParEnv % PEs>1 ) THEN
                 IF ( ParEnv % Active(ParEnv % MyPE+1) ) &
                     CALL ComputeChange(Solver,.TRUE., n)
               ELSE
                 CALL ComputeChange(Solver,.TRUE.)
                 !                 CALL ComputeChange(Solver,.TRUE.,n)
               END IF

               ! The ComputeChange subroutine sets a flag to zero if not yet
               ! converged (otherwise -1/1)
               !------------------------------------------------------------
               IF( TestConvergence ) THEN
                 IF( Solver % Variable % SteadyConverged == 0 ) THEN
                   DoneThis(k) = .FALSE.
                 ELSE                   
                   DoneThis(k) = .TRUE.
                 END IF                   
               END IF
             END IF
             
           ELSE IF( TransientSimulation ) THEN
             
             TestConvergence = ( i >= CoupledMinIter .AND. i /= CoupledMaxIter )
             IF ( TestConvergence ) THEN
               IF ( ParEnv % PEs>1 ) THEN
                 IF ( ParEnv % Active(ParEnv % MyPE+1) ) &
                     CALL ComputeChange(Solver,.TRUE., n)
               ELSE
                 CALL ComputeChange(Solver,.TRUE.)
                 !                 CALL ComputeChange(Solver,.TRUE.,n)
               END IF
               IF( Solver % Variable % SteadyConverged == 0 ) THEN
                 DoneThis(k) = .FALSE.
               ELSE                   
                 DoneThis(k) = .TRUE.
               END IF
             END IF

           ELSE    ! Steady-state
             IF ( ParEnv % PEs > 1 ) THEN
               IF ( ParEnv % Active(ParEnv % MyPE+1) ) &
                   CALL ComputeChange(Solver,.TRUE., n)
             ELSE
               CALL ComputeChange(Solver,.TRUE.)
               !                 CALL ComputeChange(Solver,.TRUE.,n)
             END IF             

             IF( Solver % Variable % SteadyConverged == 0 ) THEN
               DoneThis(k) = .FALSE.
             ELSE                   
               DoneThis(k) = .TRUE.
             END IF
           END IF
           
           CALL ParallelAllReduceAnd( DoneThis(k) )
           IF( ALL(DoneThis) ) EXIT
!------------------------------------------------------------------------------
         END DO
!------------------------------------------------------------------------------
       Model % Mesh % Changed = .FALSE.
       IF ( ALL(DoneThis) ) EXIT
    END DO

    IF ( TransientSimulation .AND. .NOT. ALL(DoneThis) ) THEN
       IF ( ListGetLogical( Model % Simulation,  &
               'Coupled System Abort Not Converged', Found ) ) THEN
          CALL Error( 'SolveEquations', ' ' )
          WRITE( Message, * ) 'Coupled system iteration: ', i
          CALL Error( 'SolveEquations', Message )
          CALL Fatal( 'SolveEquations', ' ' )
       ELSE
!         CALL Error( 'SolveEquations', ' ' )
!         WRITE( Message, * ) 'Coupled system iteration: ', i
!         CALL Error( 'SolveEquations', Message )
!         CALL Error( 'SolveEquations', ' ' )
       END IF
    END IF

    END SUBROUTINE SolveCoupled
!------------------------------------------------------------------------------
  END SUBROUTINE SolveEquations
!------------------------------------------------------------------------------


  !-----------------------------------------------------------------------------------
  ! If a block variable does not exist it will be created. 
  ! Here only normal nodal elements are supported for the moment. 
  ! Then also the creation of permutation vector is straight-forward.
  ! Note that no reordering is currently performed.
  !
  ! There is limitation regarding non-nodal elements which stems partly from the fact
  ! that an elementtype is solver specific while this one solver could have a number of
  ! different elementtypes for different equations.
  !-----------------------------------------------------------------------------------
  FUNCTION CreateBlockVariable( Solver, VariableNo ) RESULT ( Var )

    USE DefUtils

    TYPE(Solver_t), POINTER :: Solver
    INTEGER :: VariableNo
    TYPE(Variable_t), POINTER :: Var

    TYPE(Solver_t), POINTER :: PSolver
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Element_t), POINTER :: Element
    INTEGER :: i,j,t,n,ndeg,body_id,body_id_prev,eq_id,solver_id,Dofs
    INTEGER, POINTER :: VarPerm(:), ActiveVariables(:)
    INTEGER, ALLOCATABLE :: Indexes(:)
    REAL(KIND=dp), POINTER :: Values(:)
    LOGICAL :: Hit, GotIt
    CHARACTER(LEN=max_name_len) :: str, VarName, eq

    LOGICAL :: GlobalBubbles, Found
    INTEGER :: MaxNDOFs, MaxDGDOFs, MaxEDOFs, MaxFDOFs, MaxBDOFs


    Mesh => Solver % Mesh

    Ndeg = 0
    MaxNDOFs  = 0
    MaxBDOFs = 0
    MaxDGDOFs = 0
    DO i=1, Mesh % NumberOFBulkElements
      Element => Mesh % Elements(i)
      MaxNDOFs  = MAX( MaxNDOFs,  Element % NDOFs )
      MaxBDOFs  = MAX( MaxBDOFs,  Element % BDOFs )
      MaxDGDOFs = MAX( MaxDGDOFs, Element % DGDOFs )
    END DO

    MaxEDOFs = 0
    DO i=1, Mesh % NumberOFEdges
      Element => Solver % Mesh % Edges(i)
      MaxEDOFs  = MAX( MaxEDOFs,  Element % BDOFs )
    END DO

    MaxFDOFs = 0
    DO i=1, Mesh % NumberOFFaces
      Element => Solver % Mesh % Faces(i)
      MaxFDOFs  = MAX( MaxFDOFs,  Element % BDOFs )
    END DO

    GlobalBubbles = GetLogical( GetSolverParams(), 'Bubbles in Global System', Found )
    IF (.NOT.Found) GlobalBubbles = .TRUE.

    Ndeg = Ndeg + Mesh % NumberOfNodes
    IF ( MaxEDOFs > 0 ) Ndeg = Ndeg + MaxEDOFs * Mesh % NumberOFEdges
    IF ( MaxFDOFs > 0 ) Ndeg = Ndeg + MaxFDOFs * Mesh % NumberOFFaces
    IF ( GlobalBubbles ) &
        Ndeg = Ndeg + MaxBDOFs * Mesh % NumberOfBulkElements
    IF ( GetLogical( GetSolverParams(), 'Discontinuous Galerkin', Found ) ) &
        Ndeg = MAX( NDeg, MaxDGDOFs * ( Mesh % NumberOfBulkElements + &
                        Mesh % NumberOfBoundaryElements) )

    ALLOCATE( VarPerm(ndeg) )
    VarPerm = 0
        
    WRITE (str,'(A,I0)') 'Variable ',VariableNo
    VarName = ListGetString( Solver % Values, TRIM(str), GotIt )

    solver_id = 0
    DO i = 1, CurrentModel % NumberOfSolvers
      PSolver => CurrentModel % Solvers(i)
      IF( ASSOCIATED( Solver, PSolver ) ) THEN
        solver_id = i
        EXIT
      END IF
    END DO
 
    ALLOCATE(Indexes(Mesh % MaxElementDOFs))
    body_id_prev = -1
    DO t=1,Mesh % NumberOfBulkElements + Mesh % NumberOFBoundaryElements
      Element => Mesh % Elements(t)
      CurrentModel % CurrentElement => Element
      
      body_id = Element % BodyId 
      IF( body_id /= body_id_prev ) THEN
        Hit = .FALSE.
        body_id_prev = body_id
        
        IF( body_id < 1 ) CYCLE
        eq_id = GetInteger( CurrentModel % Bodies(body_id) % Values,'Equation')
        IF( eq_id < 1 ) CYCLE
        
        str='Active Variables['//TRIM(i2s(solver_id))//']'            
        ActiveVariables => ListGetIntegerArray(CurrentModel % Equations(eq_id) % Values, str)
        IF(.NOT. ASSOCIATED(ActiveVariables)) THEN
          ActiveVariables => ListGetIntegerArray( CurrentModel % Equations(eq_id) % Values, &
              'Active Variables')
        END IF
        IF( .NOT. ASSOCIATED(ActiveVariables)) CYCLE
        IF( .NOT. ANY(ActiveVariables == VariableNo) )  CYCLE
        Hit = .TRUE.
      END IF
          
      IF( Hit ) THEN
        n=GetElementDOFs(Indexes)
        VarPerm(Indexes(1:n)) = 1
      END IF
    END DO
        
    j = 0
    DO i = 1, SIZE(VarPerm)
      IF( VarPerm(i) > 0 ) THEN
        j = j + 1
        VarPerm(i) = j
      END IF
    END DO
        
    IF( j > 0 ) THEN
      WRITE (str,'(A,I0,A)') 'Variable ',VariableNo,' Dofs'
      Dofs = ListGetInteger( Solver % Values, TRIM(str), GotIt )
      IF(.NOT. GotIt) Dofs = 1
      
      ALLOCATE(Values(Dofs*j))
      Values = 0.0_dp
          
      CALL VariableAddVector( Mesh % Variables, Mesh, Solver, &
          VarName, Dofs, Values, VarPerm )          
      WRITE( Message,'(A,I0,A)') 'Creating variable '//TRIM(VarName)//' with ',Dofs,' dofs'
      CALL Info('BlockSolver',Message)

      Var => VariableGet( Mesh % Variables, VarName )         
    ELSE 
      CALL Fatal('BlockSolver','Variable '//TRIM(VarName)//' cannot be created')
    END IF

  END FUNCTION CreateBlockVariable



!---------------------------------------------------
  SUBROUTINE BlockSystemAssembly(Solver,dt,Transient,RowVar,ColVar,&
      RowIndOffset,ColIndOffset)
    !---------------------------------------------------
    ! Perform normal assembly for the coupled system linear
    ! system of equations.
    !---------------------------------------------------
    USE DefUtils

    TYPE(Solver_t), POINTER :: Solver
    REAL(KIND=dp) :: dt
    LOGICAL :: Transient
    INTEGER :: RowVar, ColVar
    INTEGER, OPTIONAL :: RowIndOffset,ColIndOffset

    INTEGER :: RowInd0, ColInd0
    REAL(KIND=dp) :: SymmCoeff
    TYPE(Element_t), POINTER :: Element
    TYPE(Variable_t), POINTER :: Var
    TYPE(Matrix_t), POINTER :: Amat
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Valuelist_t), POINTER :: SolverParams
    INTEGER :: i,j,t,n,nd,istat
    INTEGER :: ElementsFirst, ElementsLast, Row, Col, RowDofs, ColDofs, Ncol, Nrow
    INTEGER :: AllocCols, AllocRows
    INTEGER, POINTER :: ColPerm(:), RowPerm(:), Indexes(:),ColInds(:),RowInds(:) 
    LOGICAL :: GotIt
    REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), DAMP(:,:), MASS(:,:), FORCE(:)
    REAL(KIND=dp), POINTER :: ForceVector(:)
    CHARACTER(LEN=MAX_NAME_LEN) :: ProcName, RowName, ColName, str
    INTEGER(KIND=AddrInt) :: ProcPntr    
    LOGICAL :: BulkMode, AssemblySymmetric, AssemblyAntiSymmetric, IsListMatrix
    LOGICAL :: AllocationsDone = .FALSE., Diagonal

    INTERFACE 
      SUBROUTINE ExecLocalAssembly( Proc, Model, Solver, dt, Transient, &
          M, D, S, F, Element, Nrow, Ncol )
        USE Types
        INTEGER(KIND=AddrInt) :: Proc
        TYPE(Model_t)   :: Model
        TYPE(Solver_t)  :: Solver
        REAL(KIND=dp)   :: dt
        LOGICAL :: Transient
        REAL(KIND=dp) :: S(:,:), D(:,:), M(:,:), F(:)
        TYPE(Element_t) :: Element
        INTEGER :: Nrow, Ncol
      END SUBROUTINE ExecLocalAssembly
    END INTERFACE

    SAVE :: AllocationsDone, AllocCols, AllocRows, &
        FORCE, STIFF, DAMP, MASS, ColInds, RowInds, indexes

    Mesh => Solver % Mesh
    SolverParams => Solver % Values
    Amat => Solver % Matrix
    ForceVector => Amat % rhs

    RowInd0 = 0
    ColInd0 = 0
    IF( PRESENT( RowIndOffset ) ) RowInd0 = RowIndOffset
    IF( PRESENT( ColIndOffset ) ) ColInd0 = ColIndOffset

    ! Row Variable
    !-------------------------------------------
    WRITE (str,'(A,I0)') 'Variable ',RowVar
    RowName = ListGetString( SolverParams, TRIM(str), GotIt )
    Var => VariableGet( Mesh % Variables, TRIM(RowName) ) 
    IF(.NOT. ASSOCIATED( Var ) .AND. RowVar == 1 .AND. ColVar == 1 ) THEN
      Var => Solver % Variable
    END IF
    RowDofs = Var % Dofs
    RowPerm => Var % Perm
    
    ! Column variable
    !------------------------------------------
    IF( ColVar /= RowVar ) THEN
      WRITE (str,'(A,I0)') 'Variable ',ColVar
      ColName = ListGetString( SolverParams, TRIM(str), GotIt )
      Var => VariableGet( Mesh % Variables, TRIM(ColName) )
    END IF          
    ColDofs = Var % Dofs
    ColPerm => Var % Perm

    ! These could be user provided for each block
    !-----------------------------------------
    AssemblySymmetric = ListGetLogical( SolverParams,'Symmetric Assembly',GotIt)
    AssemblyAntiSymmetric = ListGetLogical( SolverParams,'AntiSymmetric Assembly',GotIt)

    IsListMatrix = ( Solver % Matrix % FORMAT == MATRIX_LIST ) 
    N = Mesh % MaxElementDOFs    

    IF( AllocationsDone ) THEN
      IF( RowDofs * n > AllocRows .OR. ColDofs * n > AllocCols )  THEN
        DEALLOCATE( FORCE, STIFF, DAMP, MASS, ColInds, RowInds )        
        AllocationsDone = .FALSE.
      END IF
    END IF
    
    IF( .NOT. AllocationsDone ) THEN
      AllocRows = RowDofs * n
      AllocCols = ColDofs * n
      ALLOCATE(Indexes(AllocRows))

      ALLOCATE( FORCE( AllocRows ),      &
          STIFF( AllocRows, AllocCols ), &
          DAMP( AllocRows, AllocCols ),  &
          MASS( AllocRows, AllocCols ), &
          ColInds( N ), RowInds( N ),    &
          STAT=istat )
      IF ( istat /= 0 ) CALL FATAL('CoupledSolver','Memory allocation error')
      AllocationsDone = .TRUE.
    END IF
      
    CALL Info('BlockSystemAssembly','Starting block system assembly',Level=5)
    
    BulkMode = .TRUE.
    
100 IF(BulkMode) THEN
      ! CALL Info('BlockSystemAssembly','Starting bulk assembly',Level=5)
      ElementsFirst = 1
      ElementsLast = Mesh % NumberOFBulkElements
    ELSE
      ! CALL Info('BlockSystemAssembly','Starting boundary assembly',Level=5)
      ElementsFirst = Mesh % NumberOFBulkElements+1
      ElementsLast = Mesh % NumberOfBulkElements + &
          Mesh % NumberOFBoundaryElements
    END IF
        
      
    ! Load the assembly procudure
    !-----------------------------------------
    IF( BulkMode ) THEN
      WRITE (str,'(A,I0,I0)') 'Bulk Assembly Procedure ',RowVar,ColVar
    ELSE
      WRITE (str,'(A,I0,I0)') 'Boundary Assembly Procedure ',RowVar,ColVar
    END IF    
    ProcName = ListGetString( SolverParams, TRIM(str), GotIt )

    ! Test if the 11 block is not given with 'ij' indexes
    !--------------------------------------------------------
    IF(.NOT. GotIt .AND. RowVar == 1 .AND. ColVar == 1) THEN
      IF( BulkMode ) THEN
        WRITE (str,'(A)') 'Bulk Assembly Procedure'
      ELSE
        WRITE (str,'(A)') 'Boundary Assembly Procedure'
      END IF
      ProcName = ListGetString( SolverParams, TRIM(str), GotIt )
    END IF

    Diagonal = (RowVar == ColVar) 
    
    IF( .NOT. GotIt ) THEN
      IF( BulkMode .AND. Diagonal ) THEN
        CALL Warn('BlockSystemAssembly','Diagonal bulk entries should be assembled!')
      END IF
      RETURN
    END IF

    ProcPntr = GetProcAddr( TRIM(ProcName), abort=.FALSE.,quiet=.FALSE.)
    IF ( ProcPntr == 0 ) THEN
      CALL Fatal('BlockSystemAssembly','Assembly routine not found: '//TRIM(ProcName))
    ELSE
      CALL Info('BlockSystemAssembly','Using assembly routine: '//TRIM(ProcName))
    END IF
    
    ! These may be fetched within the assembly routine, if needed
    CALL ListAddInteger( SolverParams,'Block Matrix Row',RowVar )
    CALL ListAddInteger( SolverParams,'Block Matrix Column',ColVar )


    ! The assembly loop for a submatrix starts here
    !------------------------------------------------------------------------------             
    DO t=ElementsFirst,ElementsLast
      
      Element => Mesh % Elements(t)
      CurrentModel % CurrentElement => Element
      
      !-----------------------------------------------------------------
      n  = GetElementNOFNodes()
      nd = GetElementDOFs(Indexes)
!     Indexes => Element % NodeIndexes
!     n = Element % TYPE % NumberOfnodes
!     nd = n
      Nrow = nd

      RowInds(1:Nrow) = RowPerm(Indexes(1:nd))
      IF(.NOT. ALL(RowInds(1:Nrow) > 0)) CYCLE

      Ncol = nd
      ColInds(1:Ncol) = ColPerm(Indexes(1:nd))
      IF(.NOT. ALL(ColInds(1:Ncol) > 0)) CYCLE                 

      ! Here just the matrix structure is set, no values
      !---------------------------------------------------------------
      IF( IsListMatrix ) THEN
        CALL GlueLocalSubMatrix( Amat, &
            RowInd0,ColInd0,Nrow,Ncol,RowInds,ColInds,&
            RowDofs,ColDofs,STIFF )
        IF( AssemblySymmetric .OR. AssemblyAntiSymmetric ) THEN
          CALL GlueLocalSubMatrix( Amat, &
              ColInd0,RowInd0,Ncol,Nrow,ColInds,RowInds,&
              ColDofs,RowDofs,STIFF )          
        END IF
        CYCLE
      END IF
      
      ! Do the assembly, now really
      !---------------------------------------------------------------
      STIFF = 0.0_dp
      DAMP = 0.0_dp
      MASS = 0.0_dp
      FORCE = 0.0_dp
      
      CALL ExecLocalAssembly( ProcPntr, CurrentModel, Solver, &
          dt, Transient, MASS, DAMP, STIFF, FORCE, Element, &
          Nrow, Ncol )

      IF ( Transient ) THEN
        IF( Solver % TimeOrder == 1 ) THEN
          CALL Default1stOrderTime( MASS,STIFF,FORCE)
        ELSE IF( Solver % TimeOrder == 2) THEN
          CALL Default2ndOrderTime( MASS,DAMP,STIFF,FORCE )
        END IF
      END IF
      
      IF ( Solver % NOFEigenValues > 0 ) THEN
        IF( Solver % TimeOrder == 1 ) THEN
          CALL DefaultUpdateMass(MASS)
        ELSE IF( Solver % TimeOrder == 2) THEN
          CALL DefaultUpdateDamp(DAMP)
          CALL DefaultUpdateMass(MASS)
        END IF
      END IF

      
      ! Assemble the matrix with offset
      !-----------------------------------------------
      IF( .TRUE. .OR. ColInd0 > 0 .OR. RowInd0 > 0 ) THEN
        CALL GlueLocalSubMatrix( Amat, &
            RowInd0,ColInd0,Nrow,Ncol,RowInds,ColInds,&
            RowDofs,ColDofs,STIFF )
        
        ! Assemble the r.h.s with offset
        !-----------------------------------------------
        DO i=1,Nrow
          DO j=1,RowDofs
            Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
            ForceVector(Row) = ForceVector(Row) + &
                FORCE(RowDofs*(i-1)+j)
          END DO
        END DO
        
        ! For some constraints assemble also the transpose
        !--------------------------------------------------
        IF( AssemblySymmetric ) THEN
          CALL GlueLocalSubMatrix( Amat, &
              ColInd0,RowInd0,Ncol,Nrow,ColInds,RowInds,&
              ColDofs,RowDofs,TRANSPOSE(STIFF) )               
        ELSE IF( AssemblyAntisymmetric ) THEN
          CALL GlueLocalSubMatrix( Amat, &
              ColInd0,RowInd0,Ncol,Nrow,ColInds,RowInds,&
              ColDofs,RowDofs,-TRANSPOSE(STIFF) )               
        END IF
      ELSE              
        CALL DefaultUpdateEquations( STIFF, FORCE )
      END IF
      
    END DO
    
    IF(BulkMode) THEN
      ! CALL Info( 'BlockSystemAssembly', 'Bulk assembly done for blocks', Level=4 )
      BulkMode = .FALSE.
!      GOTO 100
    ELSE 
      ! CALL Info( 'BlockSystemAssembly', 'Boundary assembly done for blocks', Level=4 )
    END IF

  END SUBROUTINE BlockSystemAssembly
  !-----------------------------------------------------------------------------------
  





!------------------------------------------------------------------------------
! This is a line of monolithic solvers where different physics and constraints 
! are assemblied to the same matrix.
!------------------------------------------------------------------------------
  SUBROUTINE CoupledSolver( Model, Solver, dt, Transient )
!------------------------------------------------------------------------------
! Provide assembly loop and solution of linear and nonlinear systems
! This routine uses minimalistic assmebly routines to create the 
! matrices. Often the results to less labour in coding which may be 
! comprimized by less flexibility.
! 
! There are currently two modes
! IsCoupledSolver:  the variable consists of several pieces and the matrix equation
!                   is created within this solver.
! IsAssemblySolver: only one assembly routine is used and the matrix equation may
!                   be formed externally using standard procedures.
!------------------------------------------------------------------------------

! TODO:
! non-nodal elements (internal allocation & right elementtype)
! solution (and perm) vectors could be reused by setting pointers to correct positions
! check the time-dependency
! check for eigenmode analysis
! different lumped functionalities (energy,...)
! bandwidth optimization for coupled system

    
    USE DefUtils
    
    IMPLICIT NONE
!------------------------------------------------------------------------------
    TYPE(Solver_t), TARGET :: Solver
    TYPE(Model_t) :: Model
    REAL(KIND=dp) :: dt
    LOGICAL :: Transient
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
    TYPE(Solver_t), POINTER :: PSolver, PSolver2
    TYPE(Variable_t), POINTER :: Var
    TYPE(Element_t),POINTER :: Element
    INTEGER :: i,j,k,l,t,n,nd,NoIterations,NoTests,iter,istat,tests
    REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), DAMP(:,:), MASS(:,:), FORCE(:)
    LOGICAL :: GotIt, GotIt2, GotProc, BulkMode, ThisConstraint, &
        IsCoupledSolver, IsAssemblySolver, IsListMatrix
    INTEGER :: Row, Col, ColDofs, RowDofs, ColInd0, RowInd0, MaxDofs, &
         ColVar, RowVar, Nrow, Ncol, NoVar, NoCons, TotSize, ConDofs, OffSet(20), &
         VarSizes(20),VarDofs(20)
    INTEGER :: ElementsFirst, ElementsLast, bf_id, bc_id, body_id, eq_id
    INTEGER, POINTER :: VarPerm(:), ColPerm(:), RowPerm(:), ColInds(:), RowInds(:), DirPerm(:)
    REAL(KIND=dp), POINTER :: ConsValues(:)
    REAL(KIND=dp) :: NonlinearTol, Norm, PrevNorm, ConsValue, ConsCoeff, ConsVolume, &
        Residual, PrevResidual
    CHARACTER(LEN=max_name_len) :: str, VarName, ColName, RowName, ConsType
    LOGICAL :: Coupling, Equality, AssemblySymmetric, AssemblyAntisymmetric, &
        AllDirFlag, Robust, ErrorReduced
    INTEGER, POINTER :: Rows(:),Cols(:),Diag(:),Indexes(:),AllPerm(:)
    TYPE(ListMatrix_t), POINTER :: Alist(:) => NULL()
    REAL(KIND=dp), POINTER :: ForceVector(:),AllValues(:)
    LOGICAL, POINTER :: AllDir(:)
    TYPE (Matrix_t), POINTER :: Amat
    REAL(KIND=dp), POINTER :: Component(:)
    INTEGER, POINTER :: VarInds(:)
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(ValueList_t), POINTER :: SolverParams

    INTERFACE 
      SUBROUTINE ExecLocalAssembly( Proc, Model, Solver, dt, Transient, &
          M, D, S, F, Element, Nrow, Ncol )
        USE Types
        INTEGER(KIND=AddrInt) :: Proc
        TYPE(Model_t)   :: Model
        TYPE(Solver_t)  :: Solver
        REAL(KIND=dp)   :: dt
        LOGICAL :: Transient
        REAL(KIND=dp) :: S(:,:), D(:,:), M(:,:), F(:)
        TYPE(Element_t) :: Element
        INTEGER :: Nrow, Ncol
      END SUBROUTINE ExecLocalAssembly
    END INTERFACE
    

    IsCoupledSolver = .FALSE.
    IsAssemblySolver = .FALSE.

    CALL Info('CoupledSolver','---------------------------------------',Level=5)
    IF( Solver % SolverMode == SOLVER_MODE_COUPLED ) THEN
      CALL Info('CoupledSolver','Solving a system of equations',Level=5)
      IsCoupledSolver = .TRUE.
    ELSE IF( Solver % SolverMode == SOLVER_MODE_ASSEMBLY ) THEN
      CALL Info('CoupledSolver','Solving one equation',Level=5)      
      IsAssemblySolver = .TRUE.
    ELSE
      CALL Fatal('CoupledSolver','You should maybe not be here?')
    END IF
    CALL Info('CoupledSolver','---------------------------------------',Level=5)


    Mesh => GetMesh()
    SolverParams => GetSolverParams()
    PSolver => Solver

    !------------------------------------------------------------------------------
    ! Check out which variables the coupled model includes
    ! and compure size information related to the new coupled dof.
    !------------------------------------------------------------------------------
    Offset = 0
    VarSizes = 0    
    NoVar = 0
    NoCons = 0
    VarDofs = 0

    AllDirFlag = .FALSE.
    IF( IsCoupledSolver ) THEN

      DO i = 1,9
        WRITE (str,'(A,I0)') 'Variable ',i
        VarName = ListGetString( SolverParams, TRIM(str), GotIt )
        IF(.NOT. GotIt) EXIT
        Var => VariableGet( Mesh % Variables, TRIM(VarName) )
        
        IF(.NOT. ASSOCIATED( Var )) THEN
          CALL Info('CoupledSolver','Variable '//TRIM(VarName)//' does not exist, creating')
          PSolver => Solver
          Var => CreateBlockVariable(PSolver, i)
        END IF

        NoVar = NoVar + 1
        VarDofs(NoVar) = Var % Dofs
        VarSizes(NoVar) = SIZE( Var % Values )
        Offset(NoVar+1) = Offset(NoVar) + VarSizes(NoVar)
      END DO

      !------------------------------------------------------------------------------------
      ! Here is a hack for taking constraints into account where dofs are created on-the-fly
      ! might be better to create special solvers somewhere else.
      ! The size of constraint is deduced directly from its type.
      !-------------------------------------------------------------------------------------
      DO i = 1,9
        WRITE (str,'(A,I0)') 'Constraint ',i
        VarName = ListGetString( SolverParams, TRIM(str), GotIt )
        IF(.NOT. GotIt) EXIT
        
        NoCons = NoCons + 1      
        
        WRITE (str,'(A,I0,A)') 'Constraint ',i,' Type'
        ConsType = ListGetString( SolverParams,TRIM(str))
        
        SELECT CASE( ConsType )
          
        CASE('integral')
          ConDofs = 1
          
        CASE('floating')
          ConDofs = 1
          AllDirFlag = .TRUE.
          
        CASE('equality')
          ConDofs = 0
          AllDirFlag = .TRUE.
          
        CASE DEFAULT          
          CALL Warn('CoupledSolver','Coupled constraint does not really work yet')
          WRITE (str,'(A,I0,A)') 'Constraint ',i,' DOFs'
          ConDofs = ListGetInteger( SolverParams, str)

        END SELECT

        ! Create the constrained variables for possible other use
        !-----------------------------------------------------------
        IF( ConDofs > 0 ) THEN
          Var => VariableGet( Mesh % Variables, VarName )
          IF( .NOT. ASSOCIATED(Var) ) THEN
            CALL Info('CoupledSolver','Constraint '//TRIM(VarName)//' does not exist, creating')
            ALLOCATE(ConsValues(ConDofs))
            CALL VariableAdd( Mesh % Variables, Mesh, Solver, &
                VarName, ConDofs, ConsValues, Output = .FALSE. )          
            Var => VariableGet( Mesh % Variables, VarName )         
          END IF
        END IF
        
        j = NoVar + NoCons
        VarDofs(j) = ConDofs
        VarSizes(j) = 1
        Offset(j+1) = Offset(j) + VarSizes(j)
      END DO

      DO j=1,NoVar+NoCons
        WRITE(Message,'(A,I0,A,T35,I0)') 'Permutation offset ',j,': ',OffSet(j)
        CALL Info('CoupledSolver',Message)
      END DO
      
      TotSize = SUM( VarSizes )
      MaxDofs = MAXVAL( VarDofs )
      
      WRITE(Message,'(A,T35,I0)') 'Number of coupled variables: ',NoVar
      CALL Info('CoupledSolver',Message)
      
      WRITE(Message,'(A,T35,I0)') 'Number of constraints: ',NoCons
      CALL Info('CoupledSolver',Message)
      
      WRITE(Message,'(A,T35,I0)') 'Size of coupled system: ',TotSize
      CALL Info('CoupledSolver',Message)
      
      ! For the 1st time the matrix should be a list, later CRS
      !--------------------------------------------------------
      IF(.NOT. ASSOCIATED(Solver % Matrix)) THEN
        Amat => AllocateMatrix()
        Amat % ListMatrix => Alist
        Amat % FORMAT = MATRIX_LIST      
        Solver % Matrix => Amat
      END IF

      ! This actual variable is not saved, so a dummy name suffices
      !------------------------------------------------------------
      VarName = ListGetString( SolverParams,'Variable', GotIt )
      IF(.NOT. GotIt) THEN
        CALL Info('CoupledSolver','New coupled variable added: Alldofs', Level=5)
        VarName = 'alldofs'
      END IF

      ! If the variable hasn't been created do it now
      !----------------------------------------------
      Var => VariableGet(Mesh % Variables, VarName )
      IF(.NOT. ASSOCIATED(Var) ) THEN

        ALLOCATE(AllPerm(TotSize),AllValues(TotSize),ForceVector(TotSize))
        DO i=1,TotSize
          AllPerm(i) = i
          AllValues(i) = 0.0_dp
        END DO
        CALL VariableAdd( Mesh % Variables, Mesh, Solver, &
            VarName,1,AllValues,AllPerm,Output=.FALSE.)        
        Amat % Rhs => ForceVector
        Solver % Variable => VariableGet(Mesh % Variables, VarName )
        Var => Solver % Variable
       
        ! Map the original vectors to the monolithic vector if requested
        !----------------------------------------------------------------------------------
        IF( ListGetLogical( SolverParams,'Coupled Initial Guess',GotIt)) THEN
          CALL SingleToCoupledVector()
        END IF
      END IF
    ELSE
      CALL Info('CoupledSolver','Using existing variable and matrix')
      IF(.NOT. ASSOCIATED(Solver % Matrix)) THEN
        CALL Fatal('CoupledSolver','In Assembly Solver mode the Matrix should exist!')
      END IF
      IF(.NOT. ASSOCIATED(Solver % Variable)) THEN
        CALL Fatal('CoupledSolver','In Assembly Solver mode the Variable should exist!')
      END IF
      NoVar = 1
      Var => Solver % Variable
      VarDofs(1) = Var % Dofs
      VarSizes(1) = SIZE( Var % Values )
      TotSize = VarSizes(1)
      MaxDofs = VarDofs(1)
    END IF
      

!------------------------------------------------------------------------------
! Do some initial stuff common for both modes
!------------------------------------------------------------------------------
  
    N = Mesh % MaxElementDOFs
    
    ALLOCATE( FORCE( MaxDofs*N ),      &
        STIFF( MaxDofs*N, MaxDofs*N ), &
        DAMP( MaxDofs*N, MaxDofs*N ),  &
        MASS(  MaxDofs*N, MaxDofs*N ), &
        ColInds( N ), RowInds( N ),    &
        Indexes( n ), STAT=istat )
    IF ( istat /= 0 ) CALL FATAL('CoupledSolver','Memory allocation error')
    
    NoIterations = GetInteger( SolverParams,'Nonlinear System Max Iterations',GotIt)
    IF(.NOT. GotIt) NoIterations = 1
    NonlinearTol = GetCReal( SolverParams,'Nonlinear System Convergence Tolerance',gotIt)
    Robust = ListGetLogical(Solver % Values,'Nonlinear System Linesearch',GotIt)
    IF( Robust ) THEN
      NoTests = GetInteger( SolverParams,'Nonlinear System Linesearch Iterations',GotIt)
      IF(.NOT. GotIt) NoTests = NoIterations
      CALL ListAddString(Solver % Values,'Nonlinear System Convergence Measure','residual')
      CALL ListAddLogical(Solver % Values,'Skip Compute Nonlinear Change',.TRUE.)
    END IF
       
    Amat => GetMatrix()
    ForceVector => Amat % Rhs
    IF( AllDirFlag ) ALLOCATE( AllDir(TotSize) ) 
   
!------------------------------------------------------------------------------
! Iterate over any nonlinearity of material or source
!------------------------------------------------------------------------------
    CALL Info('CoupledSolver','-------------------------------------------------',Level=5)
    Residual = -1.0_dp
    PrevResidual = -1.0_dp
    IsListMatrix = ( Amat % FORMAT == MATRIX_LIST )
    
    DO iter = 1,NoIterations
      
      WRITE(Message,'(A,T35,I5)') 'Coupled iteration:',iter
      CALL Info('CoupledSolver',Message,Level=5)
   
      tests = 0
100   IF(.NOT. IsListMatrix ) CALL DefaultInitialize()
      IF( AllDirFlag ) AllDir = .FALSE.

!----------------------------------------------------------------
! Here we use the same assembly for coupled system and block system
! approach.
!----------------------------------------------------------------

      DO RowVar = 1,NoVar 
        DO ColVar = 1,NoVar          
          CALL BlockSystemAssembly(PSolver,dt,Transient,RowVar,ColVar,&
                   Offset(RowVar),Offset(ColVar))
        END DO
      END DO
    
!-------------------------------------------------------------------------
! Tailored assembly routines for setting the constraints to the same matrix
!-------------------------------------------------------------------------

      IF( IsCoupledSolver .AND. NoCons > 0 ) THEN
        CALL CoupledConstraintAssembly()
      END IF
      
!----------------------------------------------------------------------
! The CRS matrix may be created only when the matrix structure is known
! and some initialization may be done only when the matrix exists
!----------------------------------------------------------------------
      IF( IsListMatrix ) THEN
        CALL List_ToCRSMatrix(Amat)
        IsListMatrix = .FALSE.
        CALL AddEquationSolution(PSolver, Transient )
        GOTO 100  
      END IF
      CALL DefaultFinishAssembly()
      
!------------------------------------------------------------------------------
!    Do the Dirichlet conditions using offset
!------------------------------------------------------------------------------          
      IF( IsCoupledSolver ) THEN
        CALL CoupledSystemDirichlet()
      ELSE      
        CALL DefaultDirichletBCs()
      END IF

!------------------------------------------------------------------------------
!    Check the stepsize of nonlinear iteration using the Armijo-GoldStein 
!    criterion for the stepsize.
!------------------------------------------------------------------------------          
      IF( Robust  ) THEN   
        ErrorReduced = CheckStepSize(Solver,tests==0,PrevResidual,Residual)
        tests = tests + 1
        
        IF( tests >  NoTests ) THEN
          CALL Warn('CoupledSolver','Maximum number of linesearch steps exceeded')
          ErrorReduced = .TRUE.
        END IF
        
        ! Update the reference residual only when new step is accepted
        IF( iter == 1 ) THEN
          PrevResidual = Residual
        ELSE
          IF( ErrorReduced ) THEN 
            PrevResidual = Residual
            IF(Solver % Variable % NonlinChange < NonlinearTol) EXIT
          ELSE
            IF( IsCoupledSolver ) CALL CoupledToSingleVector()
            GOTO 100
          END IF
        END IF
      END IF

!------------------------------------------------------------------------------
!   Finally solve the system
!------------------------------------------------------------------------------          
      Norm = DefaultSolve()     
      CALL Info('CoupledSolver','-------------------------------------------------',Level=5)

      IF( IsCoupledSolver ) CALL CoupledToSingleVector()

      ! The non-robust solver will use one assembly routine less 
      IF(.NOT. Robust) THEN
        IF(Solver % Variable % NonlinChange < NonlinearTol) EXIT
      END IF
    END DO

    
    DEALLOCATE( FORCE, STIFF, DAMP, MASS, ColInds, RowInds, Indexes )
    IF( AllDirFlag ) DEALLOCATE( AllDir ) 
    
    CALL Info('CoupledSolver','All done')
    CALL Info('CoupledSolver','-------------------------------------------------',Level=5)


  CONTAINS 

!------------------------------------------------------------------------------
   SUBROUTINE IntegralConstraint( Mass, Damp, Stiff, Force, Element, n )
!------------------------------------------------------------------------------
! Integration routine for integral type of constraints i.e. body or boundary
! integral of some dof is known a priori.
!------------------------------------------------------------------------------
     
      IMPLICIT NONE
!------------------------------------------------------------------------------
      REAL(KIND=dp) :: Stiff(:,:), Damp(:,:), Mass(:,:), Force(:)
      TYPE(Element_t), POINTER :: Element
      INTEGER :: n
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------
      TYPE(GaussIntegrationPoints_t) :: IntegStuff
      REAL(KIND=dp) :: Basis(n)
      REAL(KIND=dp) :: Weight, DetJ
      INTEGER :: i,j,t,p,q
      LOGICAL :: Found
      
      TYPE(Nodes_t),SAVE :: Nodes
      
      CALL GetElementNodes( Nodes ) 
      IntegStuff = GaussPoints( Element )
      
      DO t=1,IntegStuff % n
        Found = ElementInfo( Element, Nodes, IntegStuff % u(t), &
            IntegStuff % v(t), IntegStuff % w(t), detJ, Basis )     
        Weight = IntegStuff % s(t) * detJ
        DO p=1,n
          STIFF(1,p) = STIFF(1,p) + Weight * Basis(p)
          FORCE(p) = FORCE(p) + ConsValue * Weight * Basis(p)
        END DO
        ConsVolume = ConsVolume + Weight 
      END DO

!------------------------------------------------------------------------------
    END SUBROUTINE IntegralConstraint
!------------------------------------------------------------------------------
 
   
    !------------------------------------------------------------------------------          
    ! Subroutine sets the Dirichlet conditions for the coupled system 
    ! using the single system vector names and sizes.
    !----------------------------------------------------------------------------------
    SUBROUTINE CoupledSystemDirichlet()
      CALL Info( 'CoupledSolver', 'Setting coupled system Dirichlet conditions', Level=4 )
      
      DO i = 1,NoVar
        WRITE (str,'(A,I0)') 'Variable ',i
        VarName = ListGetString( SolverParams, TRIM(str), GotIt )
        IF(.NOT. GotIt) EXIT
        
        Var => VariableGet( Mesh % Variables, TRIM(VarName) )
        IF (.NOT. ASSOCIATED(Var)) EXIT 
        
        CALL DefaultDirichletBCs( Ux=Var, UOffset=Offset(i) )
      END DO
 
    END SUBROUTINE CoupledSystemDirichlet


    !------------------------------------------------------------------------------          
    ! Subroutine copies results from the single system vectors to a coupled system
    ! initial guess.
    !----------------------------------------------------------------------------------
    SUBROUTINE SingleToCoupledVector()
      CALL Info('CoupledSolver','Copying an initial guess',Level=5)
      
      DO i = 1,NoVar + NoCons
        IF( VarDofs(i) == 0 ) CYCLE
        
        IF( i <= NoVar ) THEN
          WRITE (str,'(A,I0)') 'Variable ',i
        ELSE
          WRITE (str,'(A,I0)') 'Constraint ',i-NoVar        
        END IF
        VarName = ListGetString( SolverParams, TRIM(str), GotIt )
        Var => VariableGet( Mesh % Variables, TRIM(VarName) )
        
        ! CALL Info('CoupledSolver','Copying from variable: '//TRIM(VarName),Level=5)
        DO j=1,SIZE(Var % Values)
          Solver % Variable % Values(Offset(i)+j) = Var % Values(j)
        END DO
      END DO

    END SUBROUTINE SingleToCoupledVector


    !------------------------------------------------------------------------------          
    ! Subroutine copies results from the coupled system vector back to the 
    ! original vectors.
    !----------------------------------------------------------------------------------
    SUBROUTINE CoupledToSingleVector()
      CALL Info('CoupledSolver','Copying results into original variables',Level=5)
      DO i = 1,NoVar + NoCons
        IF( VarDofs(i) == 0 ) CYCLE
        
        IF( i <= NoVar ) THEN
          WRITE (str,'(A,I0)') 'Variable ',i
        ELSE
          WRITE (str,'(A,I0)') 'Constraint ',i-NoVar        
        END IF
        VarName = ListGetString( SolverParams, TRIM(str), GotIt )
        Var => VariableGet( Mesh % Variables, TRIM(VarName) )
        
        ! CALL Info('CoupledSolver','Copying to variable: '//TRIM(VarName),Level=5)
        DO j=1,SIZE(Var % Values)
          Var % Values(j) = Solver % Variable % Values(Offset(i)+j)
        END DO

        CALL InvalidateVariable( Model % Meshes, Solver % Mesh, VarName )
      END DO

    END SUBROUTINE CoupledToSingleVector


    !-----------------------------------------------------------------------------------
    SUBROUTINE CoupledConstraintAssembly()
      !-----------------------------------------------------------------------------------
      ! Perform constraints assembly
      ! Some constraints are assembled by integration while others are done by elimination.
      ! It is important that constraints are applied after the normal assembly process. 
      !-----------------------------------------------------------------------------------
      INTEGER :: TargetDof, TmpInds(4) 

      CALL Info('CoupledSolver','Starting constraint assembly',Level=5)
      
      BulkMode = .TRUE.
200   IF(BulkMode) THEN
        ! CALL Info('CoupledSolver','Starting constraing bulk assembly',Level=5)
        ElementsFirst = 1
        ElementsLast = Mesh % NumberOfBulkElements 
      ELSE
        ! CALL Info('CoupledSolver','Starting boundary assembly',Level=5)
        ElementsFirst = Mesh % NumberOfBulkElements + 1
        ElementsLast =  Mesh % NumberOfBulkElements + &
              Mesh % NumberOfBoundaryElements
      END IF
      
      ! Variables over rows
      !-------------------------------------------
      DO RowVar = 1,NoCons        

        RowDofs = VarDofs(NoVar + RowVar) 
        RowInd0 = Offset(NoVar + RowVar)

        AssemblySymmetric = .FALSE.
        AssemblyAntiSymmetric = .FALSE.

        WRITE (str,'(A,I0)') 'Constraint ',RowVar
        RowName = ListGetString( Solver % Values, TRIM(str), GotIt )

        WRITE (str,'(A,I0,A)') 'Constraint ',RowVar,' Variables'
        VarInds => ListGetIntegerArray( Solver % Values, TRIM(str) )

        IF( ASSOCIATED(VarInds)) THEN
          ColVar =  VarInds(1) 
        ELSE        
          CALL Fatal('CoupledSolver','Cannot continue without pointer to variables')
        END IF
        
        WRITE (str,'(A,I0,A)') 'Constraint ',RowVar,' Components'
        TargetDof = ListGetInteger( Solver % Values, TRIM(str), GotIt )
      
        WRITE (str,'(A,I0,A)') 'Constraint ',RowVar,' Value'
        ConsValue = GetCReal(Solver % Values,TRIM(str), GotIt)

        WRITE (str,'(A,I0,A)') 'Constraint ',RowVar,' Coeff'
        ConsCoeff = GetCReal(Solver % Values,TRIM(str), GotIt)
        IF(.NOT. GotIt) ConsCoeff = 1.0_dp


        IF ( ConsType == 'equality' ) THEN
          WRITE (str,'(A,I0)') 'Variable ',VarInds(2)
          VarName = ListGetString( SolverParams, TRIM(str) )
          Var => VariableGet( Mesh % Variables, TRIM(VarName) ) 
          RowPerm => Var % Perm
          RowDofs = VarDofs(VarInds(2))
          RowInd0 = Offset(VarInds(2)) 
        ELSE
          Nrow = 1
          RowInds(1:Nrow) = 1         
          Var => VariableGet( Mesh % Variables, TRIM(RowName) )      
          
          ! Add the diagonal entry expected by some subroutines
          !-------------------------------------------------------          
          DO i=1,Nrow
            DO j=1,RowDofs
              Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
              CALL AddToMatrixElement( Amat, Row, Row, 0.0_dp )
            END DO
          END DO
        END IF
         
        IF( ConsType == 'integral') THEN
          AssemblySymmetric = .TRUE.
          ConsVolume = 0.0_dp
        END IF

        WRITE (str,'(A,I0)') 'Variable ',ColVar
        ColName = ListGetString( Solver % Values, TRIM(str), GotIt )
        Var => VariableGet( Mesh % Variables, TRIM(ColName) )
          
        ! Constrain only the target variable
        !-----------------------------------------------
        
        ColPerm => Var % Perm
        ColDofs = Var % Dofs
        ColInd0 = Offset(ColVar)
          
        ! The assembly loop for a submatrix starts here
        !------------------------------------------------------------------------------             
        DO t=ElementsFirst,ElementsLast

          Element => Mesh % Elements(t)
          Model % CurrentElement => Element
          
          ! How to treat non-nodal elements must be rethought 
          ! nd = GetElementNOFDOFs( Element, Solver )                  
          !-----------------------------------------------------------------
          n  = GetElementNOFNodes()
          nd = GetElementDOFs(Indexes)
                        
          ! Set the permutations for equality constraint
          !----------------------------------------------------
          IF( ConsType == 'equality') THEN
            Nrow = nd
            RowInds(1:Nrow) = RowPerm(Indexes)
            IF(.NOT. ALL(RowInds(1:Nrow) > 0)) CYCLE
          END IF
            
          Ncol = nd
          ColInds(1:n) = ColPerm(Indexes)
          IF(.NOT. ALL(ColInds(1:Ncol) > 0)) CYCLE                 

            
          ! Check where constraints are active, both bodies and BCs
          !-------------------------------------------------------------------                         
          Coupling = .FALSE.              
          IF( BulkMode ) THEN
            ! Check coupling to bodies using Body/Equation section
            Coupling = GetLogical( GetBodyForce(), RowName, gotIt)
          ELSE 
            Coupling = GetLogical( GetBC(), RowName, gotIt)
          END IF
          IF( .NOT. Coupling ) CYCLE
              
          ! These two constraints are based on moving already assembled information
          ! rather than assembling new information. If the row is already treated cycle.
          ! The constrainst have been tested only with one-component cases.
          !-----------------------------------------------------------------------------
          IF( ConsType == 'floating' .OR. ConsType == 'equality') THEN

            DO i=1,Ncol                
              DO k=0,ColDofs-1
                
                ! Note that for this type the column is rather also a row
                !--------------------------------------------------------
                Col  = ColInd0 + ColDofs * ColInds(i) - k                  
                IF( AllDir(Col) ) CYCLE
                AllDir(Col) = .TRUE.
                
                IF( ConsType == 'floating') THEN
                  Row = RowInd0 + 1
                ELSE IF( ConsType == 'equality') THEN
                  Row = RowInd0 + RowDofs * RowInds(i) - k
                END IF

                IF( IsListMatrix ) THEN
                  CALL MoveRow( Amat, Col, Row )
                  CALL SetMatrixElement( Amat,Col,Col,0.0_dp )
                  CALL SetMatrixElement( Amat,Col,Row,0.0_dp )
                  CYCLE
                END IF

                CALL MoveRow( Amat, Col, Row, ConsCoeff ) 
                ForceVector(Row) = ForceVector(Row) + ForceVector(Col)
                ForceVector(Col) = 0.0_dp
                
                ForceVector(Row) = ForceVector(Row) + ConsValue
                CALL SetMatrixElement( Amat,Col,Col,1.0_dp )
                CALL SetMatrixElement( Amat,Col,Row,-ConsCoeff)
              END DO
            END DO
            CYCLE
          END IF


          ! Do the assembly, now really (active only for some constraints)
          !----------------------------------------------------------------
            
          STIFF = 0.0_dp
          DAMP = 0.0_dp
          MASS = 0.0_dp
          FORCE = 0.0_dp
          
          CALL IntegralConstraint( MASS, DAMP, STIFF, FORCE, Element, Ncol )
          
          IF ( Transient ) THEN
            IF( Solver % TimeOrder == 1 ) THEN
              CALL Default1stOrderTime( MASS,STIFF,FORCE)
            ELSE IF( Solver % TimeOrder == 2) THEN
              CALL Default2ndOrderTime( MASS,DAMP,STIFF,FORCE )
            END IF
          END IF

           
          ! Assemble the matrix with offset
          ! Because we want to have constraints component-wise
          ! There is somewhat dirty hack for calling the gluematrix
          !---------------------------------------------------------
          DO k=1,ColDofs
            IF( TargetDof /= 0 .AND. TargetDof /= k) CYCLE
            TmpInds(1:Ncol) = ColDofs * (ColInds(1:Ncol)-1) + k

            IF( IsListMatrix ) THEN            
              CALL GlueLocalSubMatrix( Amat, &
                  RowInd0,ColInd0,Nrow,Ncol,RowInds,TmpInds,&
                  RowDofs,1,STIFF )
              IF( AssemblySymmetric .OR. AssemblyAntisymmetric ) THEN
                CALL GlueLocalSubMatrix( Amat, &
                    ColInd0,RowInd0,Ncol,Nrow,TmpInds,RowInds,&
                    1,RowDofs,STIFF )               
              END IF
              CYCLE
            END IF

            CALL GlueLocalSubMatrix( Amat, &
                RowInd0,ColInd0,Nrow,Ncol,RowInds,TmpInds,&
                RowDofs,1,STIFF )

            ! For some constraints assemble also the transpose
            !--------------------------------------------------
            IF( AssemblySymmetric ) THEN
              CALL GlueLocalSubMatrix( Amat, &
                  ColInd0,RowInd0,Ncol,Nrow,TmpInds,RowInds,&
                  1,RowDofs,TRANSPOSE(STIFF) )               
            ELSE IF( AssemblyAntisymmetric ) THEN
              CALL GlueLocalSubMatrix( Amat, &
                  ColInd0,RowInd0,Ncol,Nrow,TmpInds,RowInds,&
                  1,RowDofs,-TRANSPOSE(STIFF) )               
            END IF
            
            ! Assemble the r.h.s with offset
            !-----------------------------------------------
            DO i=1,Nrow
              DO j=1,RowDofs
                Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
                ForceVector(Row) = ForceVector(Row) + &
                    FORCE(RowDofs*(i-1)+j)
              END DO
            END DO
          
          END DO          
        END DO
      
        ! For constraints do some special setting
        !---------------------------------------------------
        IF( ConsType == 'integral' ) THEN
          ! PRINT *,'Integral constraint sum of weights: ',ConsVolume
          DO i=1,Nrow
            DO j=1,RowDofs
              Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
              ForceVector(Row) = ConsValue
            END DO
          END DO
        END IF
      END DO
      
      IF(BulkMode) THEN
        ! CALL Info( 'CoupledSolver', 'Bulk assembly done for constraints', Level=4 )
        BulkMode = .FALSE.
        GOTO 200
      ELSE 
        ! CALL Info( 'CoupledSolver', 'Boundary assembly done for constraints', Level=4 )
      END IF

    END SUBROUTINE CoupledConstraintAssembly

!------------------------------------------------------------------------------
  END SUBROUTINE CoupledSolver
!------------------------------------------------------------------------------
 


  


! THIS IS STILL HEAVILY UNDER DEVELOPMENT
    SUBROUTINE BlockMatrixVectorProd( u,v,ipar )
      INTEGER :: i,j,k,NoVar,ipar(*)
      REAL(KIND=dp) :: u(*), v(*)
      REAL(KIND=dp), ALLOCATABLE :: tmp(:)
      INTEGER :: maxsize
      INTEGER, POINTER :: Offset(:)

      NoVar = TotMatrix % NoVar
      Offset => TotMatrix % Offset
      MaxSize = TotMatrix % MaxSize

      ALLOCATE(tmp(maxsize))

      v(1:offset(NoVar+1)) = 0
      DO i=1,NoVar
         DO j=1,NoVar
           CALL CRS_MatrixVectorMultiply( TotMatrix % SubMatrix(i,j) % Mat, &
                    u(offset(j)+1:offset(j+1)), tmp )
           DO k=1,offset(i+1)-offset(i)
             v(k+offset(i)) = v(k+offset(i)) + tmp(k)
           END DO
         END DO
       END DO
    END SUBROUTINE BlockMatrixVectorProd


    SUBROUTINE BlockMatrixPrec( u,v,ipar )
      USE DefUtils

      REAL(KIND=dp), TARGET :: u(*), v(*)
      REAL(KIND=dp) :: Norm
      INTEGER :: i,j,NoVar,ipar(*)
      TYPE(Solver_t), POINTER :: Solver
      REAL(KIND=dp), POINTER :: sol_save(:),rhs_save(:)
      INTEGER, POINTER :: Offset(:)

      LOGICAL :: l
      TYPE(Varying_string) :: namesp

      NoVar = TotMatrix % NoVar
      Solver => TotMatrix % Solver
      offset => TotMatrix % Offset

      L = ListGetNameSpace(namesp)
      u(1:offset(NoVar+1)) = v(1:offset(NoVar+1))
      DO i=1,NoVar
        Solver % Variable => TotMatrix % SubVector(i) % Var
        sol_save => Solver % Variable % Values
        Solver % Variable % Values => u(offset(i)+1:offset(i+1))

        Solver % Matrix => TotMatrix % Submatrix(i,i) % Mat
        rhs_save => Solver % Matrix % rhs
        Solver % Matrix % Rhs => v(offset(i)+1:offset(i+1))

        CALL ListSetNameSpace('block '//trim(i2s(i))//trim(i2s(i))//':')
        Norm = DefaultSolve()

        Solver % Matrix % rhs => rhs_save
        Solver % Variable % Values  => sol_save
      END DO
      CALL ListSetNameSpace(char(namesp))

    END SUBROUTINE BlockMatrixPrec


!------------------------------------------------------------------------------
! This is a line of solvers where a matrix is matrices and a vector of vectors 
! are created to allow different kinds of block strategies for the solvers.
!------------------------------------------------------------------------------
  SUBROUTINE BlockSolver( Model, Solver, dt, Transient )
!------------------------------------------------------------------------------
    
    USE DefUtils
    
    IMPLICIT NONE
 !------------------------------------------------------------------------------
    TYPE(Solver_t), TARGET :: Solver
    TYPE(Model_t) :: Model
    REAL(KIND=dp) :: dt
    LOGICAL :: Transient
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------


    TYPE(Solver_t), POINTER :: PSolver
    TYPE(Variable_t), POINTER :: Var
    INTEGER :: i,j,k,l,n,nd,NoIterations,tests,NoTests,iter
    CHARACTER(LEN=MAX_NAME_LEN) :: BlockMethod
    LOGICAL :: GotIt
    INTEGER :: ColVar, RowVar, NoVar

    REAL(KIND=dp) :: NonlinearTol, Norm, PrevNorm, Residual, PrevResidual, &
        TotNorm, MaxChange, alpha, beta, omega, rho, oldrho, s, r, PrevTotNorm
    REAL(KIND=dp), POINTER :: rhs_save(:), sol_save(:)
    CHARACTER(LEN=max_name_len) :: str, VarName, ColName, RowName
    LOGICAL :: Robust, LinearSearch, ErrorReduced
    
    TYPE (Matrix_t), POINTER :: Amat
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(ValueList_t), POINTER :: SolverParams


    CALL Info('BlockSolver','---------------------------------------',Level=5)
    IF( Solver % SolverMode /= SOLVER_MODE_BLOCK ) THEN
      CALL Fatal('BlockSolver','You should maybe not be here?')
    ELSE
      CALL Info('BlockSolver','Solving system of equations utilizing block strategies')
    END IF
    CALL Info('BlockSolver','---------------------------------------',Level=5)


    Mesh => GetMesh()
    SolverParams => GetSolverParams()
    PSolver => Solver
    
    BlockMethod = GetString( SolverParams,'Linear System Block Method',GotIt)
    IF(.NOT. GotIt ) BlockMethod = 'jacobi'

    !------------------------------------------------------------------------------
    ! Check out which variables the coupled model includes
    ! and compure size information related to the new coupled dof.
    !------------------------------------------------------------------------------
    NoVar = TotMatrix % NoVar

    IF( NoVar == 0 ) THEN
      DO i = 1,9
        WRITE (str,'(A,I0)') 'Variable ',i
        IF(.NOT. ListCheckPresent( SolverParams, TRIM(str)) ) EXIT
      END DO
      NoVar = i-1
      
      CALL InitializeBlockMatrix( TotMatrix, NoVar )
      TotMatrix % Solver => Solver
      
      WRITE(Message,'(A,T35,I0)') 'Number of coupled variables: ',NoVar
      CALL Info('BlockSolver',Message)

      !------------------------------------------------------------------------------
      ! On the first round create the matrix structures using the list structure as 
      ! the aid. 
      !------------------------------------------------------------------------------    
      CALL Info('BlockSolver','Creating matrix structured using list matrices')
      DO RowVar=1,NoVar
        Solver % Variable => TotMatrix % SubVector(RowVar) % Var
        
        DO ColVar=1,NoVar            
          Solver % Variable => TotMatrix % SubVector(ColVar) % Var        
          Solver % Matrix => TotMatrix % Submatrix(RowVar,ColVar) % Mat

          Amat => Solver % Matrix        
          Amat % ListMatrix => NULL()
          Amat % FORMAT = MATRIX_LIST      
          Amat % NumberOfRows = 0

          CALL BlockSystemAssembly(PSolver,dt,Transient,RowVar,ColVar)

          IF( .NOT. ASSOCIATED( Amat % ListMatrix ) ) THEN
            Amat % Format = MATRIX_CRS
          ELSE
            CALL List_ToCRSMatrix(Amat)
            CALL AddEquationSolution(PSolver, Transient )            
          END IF
        END DO
      END DO
    END IF

!------------------------------------------------------------------------------
! Get some parameters
!------------------------------------------------------------------------------
      
    NoIterations = GetInteger( SolverParams,'Nonlinear System Max Iterations',GotIt)
    IF(.NOT. GotIt) NoIterations = 1
    NonlinearTol = GetCReal( SolverParams,'Nonlinear System Convergence Tolerance',gotIt)

    Robust = ListGetLogical(Solver % Values,'Nonlinear System Linesearch',GotIt)
    IF( Robust ) THEN
      LinearSearch = ListGetLogical( Solver % Values,'Nonlinear System Linesearch Linear')
      NoTests = GetInteger( SolverParams,'Nonlinear System Linesearch Iterations',GotIt)
      IF(.NOT. GotIt) NoTests = NoIterations
      CALL ListAddString(Solver % Values,'Nonlinear System Convergence Measure','residual')
      CALL ListAddLogical(Solver % Values,'Skip Compute Nonlinear Change',.TRUE.)
    END IF       

    CALL Info('BlockSolver','-------------------------------------------------',Level=5)
    Residual = -1.0_dp
    PrevResidual = -1.0_dp


    !------------------------------------------------------------------------------
    ! This is the nonlinear loop that may currently be used either for true 
    ! nonlinearities or to those iterative features stemming up from the block
    ! solution strategy
    !------------------------------------------------------------------------------    
    
    DO iter = 1,NoIterations
      
      WRITE(Message,'(A,T35,I0)') 'Coupled iteration: ',iter
      CALL Info('BlockSolver',Message,Level=5)

      tests = 0
100   DO RowVar=1,NoVar

        Solver % Variable => TotMatrix % SubVector(RowVar) % Var

        DO ColVar=1,NoVar            

          Solver % Matrix => TotMatrix % Submatrix(RowVar,ColVar) % Mat
          IF( Solver % Matrix % NumberOfRows == 0 ) CYCLE

          CALL ListSetNameSpace('block '//TRIM(i2s(RowVar))//TRIM(i2s(ColVar))//':')

          Solver % Variable => TotMatrix % SubVector(ColVar) % Var
          CALL InitializeToZero(Solver % Matrix, Solver % Matrix % rhs)
          CALL BlockSystemAssembly(PSolver,dt,Transient,RowVar,ColVar)

          ! Mainly sets the r.h.s. in transient case correctly
          CALL DefaultFinishAssembly()                    

          CALL BlockSystemDirichlet(TotMatrix,RowVar,ColVar)
        END DO
      END DO
      CALL ListSetNameSpace('')
!------------------------------------------------------------------------------
!    Check the stepsize of nonlinear iteration using the Armijo-GoldStein 
!    criterion for the stepsize.
!------------------------------------------------------------------------------          
      IF( Robust  ) THEN   
200     ErrorReduced = CheckStepSizeBlock(TotMatrix,tests==0,PrevResidual,Residual)
        tests = tests + 1
        
        IF( tests >  NoTests ) THEN
          CALL Fatal('BlockSolver','Maximum number of linesearch steps exceeded')
        END IF
        
        ! Update the reference residual only when new step is accepted
        IF( iter == 1 ) THEN
          PrevResidual = Residual
        ELSE
          IF( ErrorReduced ) THEN 
            PrevResidual = Residual
            IF(Solver % Variable % NonlinChange < NonlinearTol) EXIT
          ELSE
            IF( LinearSearch ) THEN
              GOTO 100
            ELSE
              GOTO 200
            END IF
          END IF
        END IF
      END IF


!------------------------------------------------------------------------------
!   Finally solve the system
!------------------------------------------------------------------------------          

      TotNorm = 0.0_dp
      MaxChange = 0.0_dp

      
      CALL Info('BlockSolver','Using block method:'//TRIM(BlockMethod))


      IF( NoVar == 1 ) THEN
        Solver % Variable => TotMatrix % SubVector(1) % Var
        Solver % Matrix => TotMatrix % Submatrix(1,1) % Mat

        TotNorm = DefaultSolve()
        MaxChange = Solver % Variable % NonlinChange 
       

      ELSE IF( BlockMethod == 'jacobi' .OR. BlockMethod == 'gauss-seidel') THEN
        
        ! In block Jacobi the r.h.s. is not updated during the iteration cycle
        !----------------------------------------------------------------------
        IF( BlockMethod == 'jacobi') THEN
          CALL UpdateBlockRhs(TotMatrix)
        END IF
        
        DO RowVar=1,NoVar
          Solver % Variable => TotMatrix % SubVector(RowVar) % Var
          Solver % Matrix => TotMatrix % Submatrix(RowVar,RowVar) % Mat

          ! In gauss-seidel the partial update is immediately taken into account
          !---------------------------------------------------------------------
          IF( BlockMethod == 'gauss-seidel') THEN
            CALL UpdateBlockRhs(TotMatrix,RowVar)
          END IF
          
          rhs_save => Solver % Matrix % rhs
          Solver % Matrix % rhs => TotMatrix % SubVector(RowVar) % rhs
          CALL ListSetNameSpace('block '//TRIM(i2s(RowVar))//TRIM(i2s(RowVar))//':')
          Norm = DefaultSolve()
          Solver % Matrix % rhs => rhs_save

          TotNorm = TotNorm + Norm
          MaxChange = MAX( MaxChange, Solver % Variable % NonlinChange )

	  ! PRINT *,'LocalChange:',MaxChange,Solver % Variable % NonlinChange,&
	  !                  Norm, TotNorm
        END DO
        CALL ListSetNameSpace('')
      ELSE
!       CALL Fatal('BlockSolver','Unknown block solution method!')
        CALL IterC()
      END IF

      IF(.NOT. Robust) THEN
        IF( MaxChange < NonlinearTol) EXIT
      END IF
    END DO

    
    ! The variable and solver pointer should direct somewhere as they are used to 
    ! monitor the steady-state solution, for example. Therefore the user may
    ! choose the component if not preferring one.
    !---------------------------------------------------------------------------
    RowVar = ListGetInteger( SolverParams,'Primary Variable',GotIt)
    IF(.NOT. GotIt) RowVar = 1
    Solver % Variable => TotMatrix % SubVector(RowVar) % Var
    Solver % Matrix => TotMatrix % Submatrix(RowVar,RowVar) % Mat

    CALL Info('BlockSolver','All done')
    CALL Info('BlockSolver','-------------------------------------------------',Level=5)


  CONTAINS 

    SUBROUTINE IterC
      USE IterSolve

      INTEGER(KIND=AddrInt) :: AddrFunc, iterProc,precProc, mvProc,dotProc,nmrProc, zero=0
      REAL(KIND=dp) :: dpar(20), xMaxChange
      REAL(KIND=dp), ALLOCATABLE :: x(:),b(:)

      TYPE(Matrix_t), POINTER :: A

      INTEGER :: ndim, maxsize
      LOGICAL :: Converged, Diverged
      INTEGER :: Rounds, OutputInterval, PolynomialDegree
      INTEGER, POINTER :: Offset(:)
      LOGICAL :: l
      TYPE(Varying_string) :: namesp

      Offset => TotMatrix % Offset
      ndim = TotMatrix % TotSize 
      ALLOCATE(x(ndim), b(ndim))
      DO i=1,NoVar
        x(offset(i)+1:offset(i+1)) = TotMatrix % SubVector(i) % Var % Values
        b(offset(i)+1:offset(i+1)) = TotMatrix % SubMatrix(i,i) % Mat % rhs
      END DO

      precProc = AddrFunc(BlockMatrixPrec)
      mvProc = AddrFunc(BlockMatrixVectorProd)

      xMaxChange = SQRT(SUM(x**2))

      L = ListGetNameSpace(namesp)
      CALL ListSetNameSpace('outer:')
      A => TotMatrix % SubMatrix(1,1) % Mat
      CALL IterSolver( A,x,b,Solver,ndim=ndim,MatvecF=mvProc,PrecF=precProc )
      CALL ListSetNameSpace(char(namesp))

      MaxChange = SQRT(SUM(x**2))
      MaxChange = 2*ABS(xMaxChange-MaxChange)/(xMaxChange+MaxChange)

      DO i=1,NoVar
        TotMatrix % SubVector(i) % Var % Values = x(offset(i)+1:offset(i+1))
      END DO
    END SUBROUTINE IterC


    !-------------------------------------------------------------------
    ! This subroutine initializes the block matrix structure so that the 
    ! matrices and vectors have a natural location to save.
    !------------------------------------------------------------------
    SUBROUTINE InitializeBlockMatrix( BlockMatrix, NoVar )
      
      TYPE(BlockMatrix_t) :: BlockMatrix
      TYPE(Matrix_t), POINTER :: Amat
      INTEGER :: i,j,NoVar

      BlockMatrix % NoVar = NoVar
      ALLOCATE( BlockMatrix % SubMatrix(NoVar,NoVar) )
      DO i=1,NoVar
        DO j=1,NoVar
          ALLOCATE(Amat)
          CALL ClearMatrix(Amat)
          Amat % ListMatrix => NULL()
          Amat % FORMAT = MATRIX_LIST      
          BlockMatrix % Submatrix(i,j) % Mat => Amat
        END DO
      END DO
      
      ALLOCATE( BlockMatrix % SubMatrixActive(NoVar,NoVar) )
      BlockMatrix % SubMatrixActive = .FALSE.

      ALLOCATE( BlockMatrix % SubVector(NoVar))
      ALLOCATE( BlockMatrix % Offset(NoVar+1))
      BlockMatrix % Offset = 0
      BlockMatrix % maxsize = 0

      DO i = 1,NoVar
        WRITE (str,'(A,I0)') 'Variable ',i
        VarName = ListGetString( SolverParams, TRIM(str), GotIt )
        Var => VariableGet( Mesh % Variables, VarName )
        
        !-----------------------------------------------------------------------------------
        ! If variable does not exist it will be created. 
        ! Here only normal nodal elements are supported for the moment. 
        ! Then also the creation of permutation vector is straight-forward.
        ! Note that no reordering is currently performed.
        !
        ! There is limitation regarding non-nodal elements which stems partly from the fact
        ! that an elementtype is solver specific while this one solver could have a number of
        ! different elementtypes for different equations.
        !-----------------------------------------------------------------------------------
        IF(.NOT. ASSOCIATED( Var )) THEN
          CALL Info('BlockSolver','Variable '//TRIM(VarName)//' does not exist, creating')
          PSolver => Solver
          Var => CreateBlockVariable(PSolver, i)
        END IF
        
        BlockMatrix % SubVector(i) % Var => Var
        n = SIZE( Var % Values )

        BlockMatrix % Offset(i+1) = BlockMatrix % Offset(i) + n
        BlockMatrix % MaxSize = MAX( BlockMatrix % MaxSize, n )
        ALLOCATE( BlockMatrix % SubVector(i) % r(n) )
        ALLOCATE( BlockMatrix % SubVector(i) % rtmp(n) )
        ALLOCATE( BlockMatrix % SubVector(i) % rhs(n) )
        BlockMatrix % SubVector(i) % r = 0.0_dp
        BlockMatrix % SubVector(i) % rtmp = 0.0_dp
        BlockMatrix % SubVector(i) % rhs = 0.0_dp
      END DO

      BlockMatrix % TotSize = BlockMatrix % Offset( NoVar + 1 )

            
    END SUBROUTINE InitializeBlockMatrix



    !------------------------------------------------------------------------------          
    ! Subroutine sets the Dirichlet conditions for the block system 
    ! using the single system vector names and sizes. For that aim there is an 
    ! additional flag that is used to detect that the matrix cannot have the digonal 
    ! entry that is by default set to unity and the r.h.s. to the target value.
    ! Now for off-diagonal matrices they will be both omitted. 
    ! The routine assumes that the r.h.s. of the off diagonal matrices is zero.
    !----------------------------------------------------------------------------------
    SUBROUTINE BlockSystemDirichlet(BlockMatrix,NoRow,NoCol)

      TYPE(BlockMatrix_t) :: BlockMatrix
      INTEGER :: NoRow, NoCol

      LOGICAL :: OffDiagonal

      CALL Info( 'BlockSolver', 'Setting block system Dirichlet conditions', Level=4 )
      
      Solver % Matrix => BlockMatrix % SubMatrix( NoRow, NoCol ) % Mat
      IF( Solver % Matrix % NumberOfRows == 0 ) RETURN
       
      WRITE (str,'(A,I0)') 'Variable ',NoRow
      VarName = ListGetString( SolverParams, TRIM(str), GotIt )
      IF(.NOT. GotIt) RETURN

      Var => VariableGet( Mesh % Variables, TRIM(VarName) )
      IF (.NOT. ASSOCIATED(Var)) RETURN
 
      Solver % Variable => Var
      OffDiagonal = ( NoRow /= NoCol )
      CALL DefaultDirichletBCs( Ux=Var, OffDiagonalMatrix = OffDiagonal )
 
    END SUBROUTINE BlockSystemDirichlet


    !------------------------------------------------------------------------------          
    ! Compute the block norm, optionally 
    !----------------------------------------------------------------------------------
    FUNCTION ComputeBlockNorm(BlockMatrix, DiagonalOnly, MatrixOnly ) RESULT ( Residual )
      
      TYPE(BlockMatrix_t), TARGET :: BlockMatrix
      LOGICAL, OPTIONAL :: DiagonalOnly, MatrixOnly
      REAL(KIND=dp) :: Residual

      REAL(KIND=dp) :: rnorm, xnorm, bnorm, TotXnorm, TotRnorm, TotBnorm, TotRelNorm
      REAL(KIND=dp), POINTER :: x(:),r(:),b(:),rtmp(:)
      INTEGER :: n, NoRow,NoCol, NoVar
      TYPE(Matrix_t), POINTER :: A


      CALL Info('BlockSolver','Computing block matrix norm',Level=5)
      
      NoVar = BlockMatrix % NoVar

      DO NoRow = 1,NoVar 
        Var => BlockMatrix % SubVector(NoRow) % Var
        n = SIZE( Var % Values )

        x => Var % Values
        xNorm = ComputeNorm(Solver, n, x)

        A => BlockMatrix % SubMatrix(NoRow,NoRow) % Mat
        Solver % Matrix => A
        b => A % rhs
        
        xNorm = ComputeNorm(Solver, n, x)
        bNorm = ComputeNorm(Solver, n, b)

        r => BlockMatrix % SubVector(NoRow) % r
        IF( PRESENT( MatrixOnly ) ) THEN
          IF( MatrixOnly ) THEN              
            r = 0.0_dp
          ELSE
            r = r - b
          END IF
        ELSE
          r = r - b
        END IF
                
        rtmp => BlockMatrix % SubVector(NoRow) % rtmp
        rtmp = 0.0_dp  
        
        DO NoCol = 1,NoVar           
          IF( PRESENT( DiagonalOnly ) ) THEN
            IF( DiagonalOnly .AND. NoCol /= NoRow ) CYCLE
          END IF
          
          Var => BlockMatrix % SubVector(NoCol) % Var
          x => Var % Values

          A => BlockMatrix % SubMatrix( NoRow, NoCol )  % Mat
          IF( A % NumberOfRows == 0 ) CYCLE
          b => A % rhs
          
          CALL MatrixVectorMultiply( A, x, rtmp)      
          r = r + rtmp
        END DO
        
        rNorm = ComputeNorm(Solver, n, r)

        ! PRINT *,'comp norms:',NoRow,Rnorm,Xnorm


        BlockMatrix % SubVector(NoRow) % rnorm = rnorm
        BlockMatrix % SubVector(NoRow) % xnorm = xnorm
        BlockMatrix % SubVector(NoRow) % bnorm = bnorm
      END DO

      TotRnorm = SUM( BlockMatrix % SubVector(1:NoVar) % rnorm ** 2) 
      TotXnorm = SUM( BlockMatrix % SubVector(1:NoVar) % xnorm ** 2) 
      TotBnorm = SUM( BlockMatrix % SubVector(1:NoVar) % bnorm ** 2) 

      TotRnorm = SQRT( TotRnorm / NoVar )
      TotXnorm = SQRT( TotXnorm / NoVar )
      TotBnorm = SQRT( TotBnorm / NoVar )

      BlockMatrix % Rnorm = TotRNorm
      BlockMatrix % Xnorm = TotXnorm
      BlockMatrix % Bnorm = TotBnorm

      ! PRINT *,'tot norms:',TotRnorm,TotXnorm

      Residual = BlockMatrix % Rnorm

    END FUNCTION ComputeBlockNorm
    

    !------------------------------------------------------------------------------          
    ! Compute the rhs for the block matrix system which is solved
    ! accounting only the diagonal entries i.e. subtract the non-diagonal 
    ! matrix-vector results from the original r.h.s. vectors.
    ! After this the block diagonal problem Ax=b may be solved.
    !----------------------------------------------------------------------------------
    SUBROUTINE UpdateBlockRhs( BlockMatrix, ThisRow )
      
      TYPE(BlockMatrix_t), TARGET :: BlockMatrix
      INTEGER, OPTIONAL :: ThisRow
      
      TYPE(Matrix_t), POINTER :: A
      INTEGER :: n, NoRow,NoCol, NoVar
      REAL(KIND=dp), POINTER :: x(:),r(:),rhs(:)
      
      CALL Info('BlockSolver','Computing block r.h.s',Level=5)
      
      
      NoVar = BlockMatrix % NoVar

      DO NoRow = 1,NoVar 

        ! Optionally only one diagonal block may be updated for
        IF( PRESENT( ThisRow ) ) THEN
          IF( NoRow /= ThisRow ) CYCLE 
        END IF
        
        Var => BlockMatrix % SubVector(NoRow) % Var
        x => Var % Values
        n = SIZE( x )
        
        ! The residual is used only as a temporary vector
        r => BlockMatrix % SubVector(NoRow) % r
        r = 0.0_dp
        
        ! The r.h.s. of the initial system
        rhs => BlockMatrix % SubVector(NoRow) % rhs

        A => BlockMatrix % SubMatrix( NoRow, NoRow ) % Mat
        rhs = A % rhs

        DO NoCol = 1,NoVar           
          ! This ensures that the diagonal itself is not subtracted
          ! Otherwise the linear system should be solved for dx rather than x
          IF( NoCol == NoRow ) CYCLE
          
          Var => BlockMatrix % SubVector(NoCol) % Var
          x => Var % Values
          A => BlockMatrix % SubMatrix( NoRow, NoCol ) % Mat
          IF( A % NumberOfRows == 0 ) CYCLE
          
          CALL MatrixVectorMultiply( A, x, r)      
          rhs = rhs - r
        END DO

      END DO

    END SUBROUTINE UpdateBlockRhs


!------------------------------------------------------------------------------
    FUNCTION CheckStepSizeBlock(BlockMatrix,FirstTrial,PrevResidual,Residual) &
        RESULT (Success) 
!------------------------------------------------------------------------------
      TYPE(BlockMatrix_t) :: BlockMatrix
      REAL(KIND=dp) :: PrevResidual, Residual
      LOGICAL :: FirstTrial,Success
!------------------------------------------------------------------------------
      INTEGER :: i,n,niter
      TYPE(Matrix_t), POINTER :: A
      REAL(KIND=dp), POINTER CONTIG :: b(:), x(:), x0(:), r(:)
      REAL(KIND=dp) :: Norm, PrevNorm, rNorm, bNorm, Relaxation, Alpha, Myy
      TYPE(Variable_t), POINTER :: iterV
      LOGICAL :: Stat
      CHARACTER(LEN=MAX_NAME_LEN) :: SolverName
      
      
      SAVE Alpha, Relaxation, Myy
      
      !--------------------------------------------------------------------------
      ! This is the real residual r=b-Ax
      !--------------------------------------------------------------------------
      Residual = ComputeBlockNorm( BlockMatrix ) 
      
      
      ! Negative (impossible) value may be used as indicator that's its the 1st step
      !-----------------------------------------------------------------------------
      IF( PrevResidual < 0.0 ) THEN
        Success = .FALSE.
        RETURN
      END IF
      
      ! At the first step set the relaxation
      !-----------------------------------------------------------------------------
      IF( FirstTrial ) THEN
        Alpha = 1.0_dp
        Relaxation = ListGetConstReal( Solver % Values, &
            'Nonlinear System Linesearch Factor', Stat )
        IF(.NOT. Stat) Relaxation = 0.5_dp
        Myy = ListGetConstReal( Solver % Values, &
            'Nonlinear System Linesearch Limit', Stat )
        IF(.NOT. Stat) Myy = 0.5_dp
      END IF
      
      ! Armijo GoldStein Criterion for accepting stepsize
      !-----------------------------------------------------------------
      Success = ( PrevResidual - Residual > Myy * Alpha * PrevResidual)
      
      IF( Success ) THEN      
        iterV => VariableGet( Solver % Mesh % Variables, 'nonlin iter' )
        niter = NINT(iterV % Values(1))
        
        DO i=1,BlockMatrix % NoVar
          Var => BlockMatrix % SubVector(i) % Var
          b => BlockMatrix % SubMatrix(i,i) % Mat % rhs
          x => Var % Values
          n = SIZE( b )
          
          Solver % Variable => Var
          bNorm = ComputeNorm(Solver, n, b)
          
          Var % NonlinChange = Residual / bNorm
          
          Norm = ComputeNorm(Solver, n, x)
          Solver % Variable % Norm = Norm
          
          SolverName = ListGetString( Solver % Values, 'Equation',Stat)
          IF(.NOT. Stat) SolverName = Solver % Variable % Name
          
          WRITE( Message, '(a,g15.8,g15.8,a,I2)') &
              'NS (ITER='//TRIM(i2s(niter))//') (NRM,RELC): (',Norm, Residual / bNorm,&
              ' ) :: '// TRIM(SolverName),i
          CALL Info( 'CheckStepSize', Message, Level=3 )       
        END DO
        iterV % Values(1) = niter + 1 
      ELSE
        
        DO i=1,BlockMatrix % NoVar
          Var => BlockMatrix % SubVector(i) % Var
          IF(.NOT. ASSOCIATED(Var % NonlinValues)) &
              CALL Fatal('CheckStepSize','Previous nonlinear solution is needed')       
          x0 => Var % NonlinValues

          x => Var % Values

          ! PRINT *,'Before Range:',i,MINVAL(x),MAXVAL(x),MINVAL(x0),MAXVAL(x0)

          x = (1-Relaxation) * x0 + Relaxation * x

          ! PRINT *,'After Range:',i,MINVAL(x),MAXVAL(x),MINVAL(x0),MAXVAL(x0)

        END DO
        
        Alpha = Alpha * Relaxation
        CALL Info( 'CheckStepSize','Step rejected, increasing relaxation', Level=3 )      
        ! PRINT *,'Residual',Residual,PrevResidual,Alpha

      END IF

      RowVar = ListGetInteger( SolverParams,'Primary Variable',GotIt)
      IF(.NOT. GotIt) RowVar = 1
      Solver % Matrix => TotMatrix % Submatrix(RowVar,RowVar) % Mat
      Solver % Variable => TotMatrix % SubVector(RowVar) % Var

      
 !------------------------------------------------------------------------------
    END FUNCTION CheckStepSizeBlock
 !------------------------------------------------------------------------------
    

   
!------------------------------------------------------------------------------
  END SUBROUTINE BlockSolver
!------------------------------------------------------------------------------
 




  

!------------------------------------------------------------------------------
! This is the original line of solvers where each solver includes looping over 
! elements and the convergence control. 
!------------------------------------------------------------------------------
  SUBROUTINE SingleSolver( Model, Solver, dt, TransientSimulation )
!------------------------------------------------------------------------------
     TYPE(Model_t)  :: Model
     TYPE(Solver_t),POINTER :: Solver
     LOGICAL :: TransientSimulation
     REAL(KIND=dp) :: dt
!------------------------------------------------------------------------------
     LOGICAL :: stat, Found, GB, MeActive
     INTEGER :: i, j, n, SolverAddr, BDOFs, maxdim
     TYPE(Element_t), POINTER :: CurrentElement
     CHARACTER(LEN=MAX_NAME_LEN) :: EquationName, str

     INTEGER, ALLOCATABLE :: memb(:)
     TYPE(Matrix_t), POINTER :: M
     INTEGER :: comm_active, group_active, group_world, ierr

!------------------------------------------------------------------------------
     IF ( Solver % Mesh % Changed .OR. Solver % NumberOfActiveElements <= 0 ) THEN
       Solver % NumberOFActiveElements = 0
       EquationName = ListGetString( Solver % Values, 'Equation', Found)

       IF ( Found ) THEN
          IF ( ASSOCIATED(Solver % ActiveElements)) DEALLOCATE( Solver % ActiveElements )
          ALLOCATE( Solver % ActiveElements( Solver % Mesh % NumberOfBulkElements + &
                       Solver % Mesh % NumberOFBoundaryElements ) )

          Maxdim = 0
          DO i=1,Solver % Mesh % NumberOfBulkElements+Solver % Mesh % NumberOFBoundaryElements
             CurrentElement => Solver % Mesh % Elements(i)
             IF ( CheckElementEquation( Model, CurrentElement, EquationName ) ) THEN
                Solver % NumberOfActiveElements = Solver % NumberOFActiveElements + 1
                Solver % ActiveElements( Solver % NumberOFActiveElements ) = i
                Maxdim = MAX( CurrentElement % TYPE % DIMENSION, Maxdim )
             END IF
          END DO
          CALL ListAddInteger( Solver % Values, 'Active Mesh Dimension', Maxdim )
          IF (ASSOCIATED(Solver % Variable)) CALL CalculateNodalWeights(Solver)
       END IF
     END IF
!------------------------------------------------------------------------------

     MeActive = ASSOCIATED(Solver % Matrix)
     IF ( MeActive ) &
        MeActive = MeActive .AND. (Solver % Matrix % NumberOfRows > 0)
     CALL ParallelActive( MeActive )

     IF ( ParEnv % PEs>1 ) THEN
       DO i=1,ParEnv % PEs
         IF ( ParEnv % Active(i) ) THEN
           EXIT
         END IF
       END DO

       OutputPE = -1
       IF ( i-1==ParEnv % MyPE .OR. i>ParEnv % PEs .AND. ParEnv % myPE==0 ) &
         OutputPE=0

       n = COUNT(ParEnv % Active)
       IF ( n>0 .AND. n<ParEnv % PEs ) THEN
         IF ( ASSOCIATED(Solver % Matrix) ) THEN
           IF ( Solver % Matrix % Comm /= MPI_COMM_WORLD ) &
              CALL MPI_Comm_Free( Solver % Matrix % Comm, ierr )
         END IF

         CALL MPI_Comm_group( MPI_COMM_WORLD, group_world, ierr )
         ALLOCATE(memb(n))
         n = 0
         DO i=1,ParEnv % PEs
           IF ( ParEnv % Active(i) ) THEN
             n=n+1
             memb(n)=i-1
           END IF
         END DO
         CALL MPI_Group_incl( group_world, n, memb, group_active, ierr)
         DEALLOCATE(memb)
         CALL MPI_Comm_create( MPI_COMM_WORLD, group_active, &
                 comm_active, ierr)

         M => Solver % Matrix
         DO WHILE(ASSOCIATED(M))
           M % Comm = comm_active
           M => M % Parent
         END DO
       ELSE
         M => Solver % Matrix
         DO WHILE( ASSOCIATED(M) )
           M % Comm = MPI_COMM_WORLD
           M => M % Parent
         END DO
       END IF
     END IF
     IF ( ASSOCIATED(Solver % Matrix) ) THEN
       ParEnv % ActiveComm = Solver % Matrix % Comm
       IF ( ParEnv % PEs>1 .AND. MeActive ) THEN
         IF ( ASSOCIATED(Solver % Mesh % ParallelInfo % INTERFACE) ) THEN
           IF (.NOT. ASSOCIATED(Solver % Matrix % ParMatrix) ) &
             CALL ParallelInitMatrix(Solver, Solver % Matrix )

           Solver % Matrix % ParMatrix % ParEnv % ActiveComm = &
                    Solver % Matrix % Comm
           ParEnv = Solver % Matrix % ParMatrix % ParEnv
         END IF
       END IF
     END IF
     str = ListGetString( Solver  % Values,'Procedure', Found )

#ifdef SGIn32
     SolverAddr = Solver % PROCEDURE
     CALL ExecSolver( SolverAddr, Model, Solver, dt, TransientSimulation)
#else
     CALL ExecSolver( Solver % PROCEDURE, &
         Model, Solver, dt, TransientSimulation)
#endif

!------------------------------------------------------------------------------
   END SUBROUTINE SingleSolver
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE SolverActivate( Model, Solver, dt, TransientSimulation )
!------------------------------------------------------------------------------
     TYPE(Model_t)  :: Model
     TYPE(Solver_t),POINTER :: Solver
     LOGICAL :: TransientSimulation, UpdateExported
     REAL(KIND=dp) :: dt, OrigDT, DTScal
!------------------------------------------------------------------------------
     LOGICAL :: stat, Found, TimeDerivativeActive, Timing, IsPassiveBC
     INTEGER :: i, j, n, BDOFs, execi, timestep, PassiveBcId
     REAL(KIND=dp) :: tcond, t0, rt0, st, rst, ct, CPUTime,RealTime
     TYPE(Variable_t), POINTER :: TimeVar, IterV
     CHARACTER(LEN=MAX_NAME_LEN) :: str
     TYPE(ValueList_t), POINTER :: Params

     SAVE TimeVar
!------------------------------------------------------------------------------

     CALL SetCurrentMesh( Model, Solver % Mesh )
     Model % Solver => Solver
     Params => Solver % Values

     st = ListGetConstReal( Params, 'Start Time', Found )
     IF ( Found ) THEN
       TimeVar => VariableGet( Model % Variables, 'Time' )
       IF ( TimeVar % Values(1) < st ) RETURN
     END IF

     execi = ListGetInteger( Params, 'Exec Interval', Found )
     IF ( Found ) THEN
       TimeVar => VariableGet( Model % Variables, 'Timestep' )
       execi = MOD( NINT(Timevar % Values(1))-1, execi )
       IF ( execi /= 0 ) RETURN
     END IF

!------------------------------------------------------------------------------

     Timing = ListGetLogical(Params,'Solver Timing',Found)
     IF( Timing ) THEN
       t0 = CPUTime(); rt0 = RealTime()
     END IF

     Solver % Mesh % OutputActive = .TRUE.
     TimeDerivativeActive = TransientSimulation

     ! This is to avoid resetting of certain info that could be interesting
     ! when saving data.
     IF(.NOT. ListGetLogical( Params,'Auxiliary Solver',Found)) THEN
       DTScal = ListGetConstReal( Params, 'Timestep Scale', Found )
       IF ( .NOT. Found ) DTScal = 1.0_dp
       Solver % dt = DtScal * dt 

       IF ( TransientSimulation ) THEN
         TimeDerivativeActive = &
           ListGetLogical( Params, 'Time Derivative Active', Found )

         IF ( .NOT. Found ) THEN
           TimeDerivativeActive = .TRUE.
           tcond = ListGetCReal(Params,'Time Derivative Condition',Found)
           IF ( Found ) TimeDerivativeActive = TimeDerivativeActive .AND. tcond>0
         END IF
       END IF

       iterV => VariableGet( Solver % Mesh % Variables, 'nonlin iter' )
       iterV % Values(1) = 1

       str = ListGetString( Params, 'Namespace', Found )
       IF (Found) CALL ListSetNamespace(TRIM(str))
     END IF

     !------------------------------------------------------------------------------
     !     Check for passive-active boundaries
     !------------------------------------------------------------------------------
     PassiveBcId = 0
     IsPassiveBC = .FALSE.
     DO j=1,Model % NumberOfBCs
        IsPassiveBC = ListGetLogical( Model % BCs(j) % Values, &
             'Passive Target',Found)
        IF (.NOT.Found) IsPassiveBC = .FALSE.
        IF (IsPassiveBC) THEN
           PassiveBcId = j
           EXIT
        END IF
     END DO
     IF (PassiveBcId /= 0 .AND. IsPassiveBC) THEN
        CALL GetPassiveBoundary( Model, Model % Mesh, PassiveBcId )
        WRITE(Message, '(A,I0,A,I0,A)' ) &
             'Passive element BC no. ',j, ' assigned to BC-ID no. ', &
             PassiveBcId
        CALL INFO('MainUtils',Message,Level=9)
     ELSE
        CALL INFO('Mainutils','No Passive element boundary found', Level=9)
     END IF
     !-------------------------------------------------------------------

     IF( Solver % SolverMode == SOLVER_MODE_COUPLED .OR. &
         Solver % SolverMode == SOLVER_MODE_ASSEMBLY ) THEN
       CALL CoupledSolver( Model, Solver, DTScal * dt, TimeDerivativeActive )
     ELSE IF( Solver % SolverMode == SOLVER_MODE_BLOCK ) THEN
       CALL BlockSolver( Model, Solver, DTScal * dt, TimeDerivativeActive )
     ELSE 
       CALL SingleSolver( Model, Solver, DTScal * dt, TimeDerivativeActive )
     END IF
   
     CALL ListSetNamespace('')
     Solver % dt = dt


!------------------------------------------------------------------------------
     IF( Timing ) THEN
       st  = CPUTime() - t0;
       rst = RealTime() - rt0

       str = ListGetString( Params,'Equation',Found)
       CALL ListAddConstReal(CurrentModel % Simulation,'res: solver cpu time '&
              //TRIM(str),st)
       CALL ListAddConstReal(CurrentModel % Simulation,'res: solver real time '&
              //TRIM(str),rst)
       WRITE(Message,'(a,f8.2,f8.2,a)') 'Solver time (CPU,REAL) for '&
        //TRIM(str)//': ',st,rst,' (s)'
       CALL Info('SolverActivate',Message)    

       IF( ListGetLogical(Params,'Solver Timing Cumulative',Found)) THEN
          ct = ListGetConstReal(CurrentModel % Simulation,'res: cum solver cpu time '&
                //TRIM(str),Found)
          st = st + ct
          ct = ListGetConstReal(CurrentModel % Simulation,'res: cum solver real time '&
                //TRIM(str),Found)
          rst = rst + ct
          CALL ListAddConstReal(CurrentModel % Simulation,'res: cum solver cpu time '&
              //TRIM(str),st)
          CALL ListAddConstReal(CurrentModel % Simulation,'res: cum solver real time '&
              //TRIM(str),rst)
        END IF 
      END IF

!------------------------------------------------------------------------------
   END SUBROUTINE SolverActivate
!------------------------------------------------------------------------------

END MODULE MainUtils
