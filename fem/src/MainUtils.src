!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Utility routines for the elmer main program.
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen, Ville Savolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 08 Jun 1997
! *
! *****************************************************************************/

MODULE MainUtils

!------------------------------------------------------------------------------

  USE SolverUtils
  USE ModelDescription

!------------------------------------------------------------------------------
  IMPLICIT NONE
!------------------------------------------------------------------------------

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION GetMatrixFormat( Model, Equation ) RESULT(FORMAT)
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    CHARACTER(LEN=*) :: Equation
!------------------------------------------------------------------------------
    INTEGER :: FORMAT

    INTEGER :: i
    LOGICAL :: Found
    CHARACTER(LEN=MAX_NAME_LEN) :: str
!------------------------------------------------------------------------------
!
!
    FORMAT = MATRIX_CRS

!
! TODO: The following code always selects the MATRIX_CRS as format
! and should be removed...
! -----------------------------------------------------------------
    DO i=1,Model % NumberOfSolvers
       FORMAT = MATRIX_CRS

       IF (  &
            ListGetString(Model % Solvers(i) % Values, 'Equation') == Equation &
            ) THEN

          str = ListGetString( Model % Solvers(i) % Values, & 
                  'Linear System Solver', Found )

          IF ( str == 'direct' ) THEN
             str = ListGetString(Model % Solvers(i) % Values, &
                  'Linear System Direct Method', Found )

             IF ( ParEnv % PEs>1 ) THEN
               IF ( str /= 'mumps' ) &
                 CALL Fatal( 'GetMatrixFormat', 'Only MUMPS direct solver' // &
                                ' implemented in parallel!')
             ELSE
               IF ( str == 'mumps' ) &
                 CALL Fatal( 'GetMatrixFormat', 'Currently no serial version' // &
                           ' of the MUMPS solver implemented, sorry!')
             END IF

             IF ( .NOT. Found ) THEN
             ELSE
                SELECT CASE( str )
                CASE( 'umfpack', 'big umfpack' )
#include "../config.h"
#ifndef HAVE_UMFPACK
                   CALL Fatal( 'GetMatrixFormat', 'UMPACK solver has not been installed.' )
#endif
                CASE( 'mumps' )
#ifndef HAVE_MUMPS
                   CALL Fatal( 'GetMatrixFormat', 'MUMPS solver has not been installed.' )
#endif
                CASE( 'superlu' )
#ifndef HAVE_SUPERLU
                   CALL Fatal( 'GetMatrixFormat', 'SuperLU solver has not been installed.' )
#endif
                CASE( 'pardiso' )
#ifndef HAVE_PARDISO
                   CALL Fatal( 'GetMatrixFormat', 'Pardiso solver has not been installed.' )
#endif
                CASE DEFAULT
                   CALL Warn( 'GetMatrixFormat', 'Unknown direct solver method: ' // TRIM(str) )
                   CALL Warn( 'GetMatrixFormat', 'band solver (LAPACK) will be used.' )
                END SELECT
             END IF
          END IF

          EXIT
       END IF
    END DO
!------------------------------------------------------------------------------
  END FUNCTION GetMatrixFormat
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddSolverProcedure( Solver,PROCEDURE  )
!------------------------------------------------------------------------------
    TYPE(Solver_t) :: Solver
    EXTERNAL :: PROCEDURE
    INTEGER  :: PROCEDURE
!------------------------------------------------------------------------------
    INTEGER(KIND=AddrInt) :: AddrFunc
!------------------------------------------------------------------------------
    Solver % PROCEDURE = AddrFunc( PROCEDURE )
!------------------------------------------------------------------------------
  END SUBROUTINE AddSolverProcedure
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddEquationBasics( Solver, Name,Transient )
!------------------------------------------------------------------------------
    TYPE(Solver_t), POINTER :: Solver
    LOGICAL :: Transient
    CHARACTER(LEN=*) :: Name
!------------------------------------------------------------------------------
    REAL(KIND=dp), POINTER :: Solution(:), Component(:)

    INTEGER, POINTER :: Perm(:)

    INTEGER(KIND=AddrInt) :: InitProc

    INTEGER :: MaxDGDOFs, MaxNDOFs, MaxEDOFs, MaxFDOFs, MaxBDOFs
    INTEGER :: i,j,k,l,NDeg,Nrows,nSize,n,DOFs,MatrixFormat,istat,Maxdim

    LOGICAL :: Found, Stat, BandwidthOptimize, EigAnal, ComplexFlag, &
    MultigridActive, VariableOutput, GlobalBubbles, HarmonicAnal, MGAlgebraic, &
    VariableGlobal, NoMatrix, IsAssemblySolver, IsCoupledSolver, IsEquation

    CHARACTER(LEN=MAX_NAME_LEN) :: str,eq,var_name, tmpname

    TYPE(Mesh_t),   POINTER :: NewMesh,OldMesh
    TYPE(Element_t), POINTER :: CurrentElement
    TYPE(Matrix_t), POINTER :: NewMatrix, Oldmatrix

    TYPE(Variable_t), POINTER :: Var
    TYPE(Variable_t), POINTER :: NewVariable

    REAL(KIND=dp) :: tt, CPUTime
    REAL(KIND=dp), POINTER :: freqv(:,:)

    EXTERNAL FlowSolver, HeatSolver, MagneticSolver, StressSolver, MeshSolver
    INTEGER :: FlowSolver, HeatSolver, MagneticSolver, StressSolver, MeshSolver

    !------------------------------------------------------------------------------

    eq = ListGetString( Solver % Values, 'Equation', Found )
    IF ( Found ) THEN
      MAXdim = 0
      DO i=1,Solver % Mesh % NumberOfBulkElements+Solver % Mesh % NumberOFBoundaryElements
        CurrentElement => Solver % Mesh % Elements(i)
        IF ( CheckElementEquation( CurrentModel, CurrentElement, eq ) ) THEN
          Maxdim = MAX( CurrentElement % TYPE % DIMENSION, Maxdim )
        END IF
      END DO
      CALL ListAddInteger( Solver % Values, 'Active Mesh Dimension', Maxdim )
    END IF

    str = ListGetString( Solver  % Values, 'Procedure', Found )
    IF ( Found ) THEN
      InitProc = GetProcAddr( TRIM(str)//'_Init', abort=.FALSE. )
      IF ( InitProc /= 0 ) THEN
        CALL ExecSolver( InitProc, CurrentModel, Solver, &
            Solver % dt, Transient )
      END IF
    END IF
    
    IsCoupledSolver = ListGetLogical( Solver % Values, 'Coupled Solver', Found )
    IsAssemblySolver = ListGetLogical( Solver % Values, 'Assembly Solver', Found )
    IsAssemblySolver = IsAssemblySolver .OR. IsCoupledSolver


    ! Computation of dofs makes only sense if it has been decleared where the solver is active
    ! and its not a coupled solver
    !-----------------------------------------------------------------------------------------
    Ndeg = 0
    eq = ListGetString( Solver  % Values, 'Equation', Found )
    IF( Found .AND. .NOT. IsCoupledSolver ) THEN
      MaxNDOFs  = 0
      MaxDGDOFs = 0
      DO i=1,Solver % Mesh % NumberOFBulkElements
        CurrentElement => Solver % Mesh % Elements(i)
        MaxDGDOFs = MAX( MaxDGDOFs, CurrentElement % DGDOFs )
        MaxNDOFs  = MAX( MaxNDOFs,  CurrentElement % NDOFs )
      END DO
      
      MaxEDOFs = 0
      DO i=1,Solver % Mesh % NumberOFEdges 
        CurrentElement => Solver % Mesh % Edges(i)
        MaxEDOFs  = MAX( MaxEDOFs,  CurrentElement % BDOFs )
      END DO
      
      MaxFDOFs = 0
      DO i=1,Solver % Mesh % NumberOFFaces 
        CurrentElement => Solver % Mesh % Faces(i)
        MaxFDOFs  = MAX( MaxFDOFs,  CurrentElement % BDOFs )
      END DO
      
      MaxBDOFs = 0
      DO i=1,Solver % Mesh % NumberOFBulkElements
        CurrentElement => Solver % Mesh % Elements(i)
        MaxBDOFs  = MAX( MaxBDOFs,  CurrentElement % BDOFs )
      END DO
      
      GlobalBubbles = ListGetLogical( Solver % Values, 'Bubbles in Global System', Found )
      IF (.NOT.Found) GlobalBubbles=.TRUE.
      
      Ndeg = Ndeg + Solver % Mesh % NumberOfNodes 
      IF ( MaxEDOFs > 0 ) Ndeg = Ndeg + MaxEDOFs * Solver % Mesh % NumberOFEdges
      IF ( MaxFDOFs > 0 ) Ndeg = Ndeg + MaxFDOFs * Solver % Mesh % NumberOFFaces
      IF ( GlobalBubbles ) &
          Ndeg = Ndeg + MaxBDOFs * Solver % Mesh % NumberOfBulkElements
      IF ( ListGetLogical( Solver % Values, 'Discontinuous Galerkin', Found ) ) &
          Ndeg = MAX( NDeg, MaxDGDOFs * (Solver % Mesh % NumberOfBulkElements+ &
          Solver % Mesh % NumberOfBoundaryElements) )
    END IF


    ! Default order of equation
    !--------------------------
    Solver % Order = 1
    Solver % TimeOrder = 1
    
    IF ( Transient ) THEN
      str = ListGetString( Solver % Values, 'Timestepping Method',Found )
      IF ( .NOT. Found ) THEN
        str = ListGetString( CurrentModel % Simulation, 'Timestepping Method',Found )
        IF ( Found ) THEN
          CALL ListAddString( Solver % Values, 'Timestepping Method', str )
        END IF
      END IF
      
      IF ( Found ) THEN
        IF (str=='bdf') THEN
          Solver % Order = ListGetInteger( Solver % Values, &
              'BDF Order', Found, minv=1, maxv=5 )
          IF ( .NOT. Found ) THEN
            Solver % Order = ListGetInteger( CurrentModel % &
                Simulation, 'BDF Order', Found, minv=1, maxv=5 )
          END IF
          IF ( .NOT.Found ) THEN
            Solver % Order = 2
            CALL Warn( 'AddEquation', 'BDF order defaulted to 2.' )
          END IF
        ELSE IF ( str=='runge-kutta') THEN
          Solver % Order = ListGetInteger( CurrentModel % &
              Simulation, 'Runge-Kutta Order', Found, minv=2, maxv=4 )
          IF ( .NOT.Found ) Solver % Order = 2
        END IF
      ELSE
        CALL Warn( 'AddEquation', 'Time stepping method defaulted to IMPLICIT EULER' )
        CALL ListAddString( Solver % Values, 'Timestepping Method', 'Implicit Euler' )
      END IF
    END IF

    !------------------------------------------------------------------------------

    DOFs = CoordinateSystemDimension()
    IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = DOFs + 1
    
    MatrixFormat = GetMatrixFormat( CurrentModel, Name )
    
    BandwidthOptimize = ListGetLogical( Solver % Values, &
        'Optimize Bandwidth', Found )
    IF ( .NOT. Found ) BandwidthOptimize = .TRUE.
    
    VariableOutput = ListGetLogical( Solver % Values, 'Variable Output', Found )
    IF ( .NOT. Found ) VariableOutput = .TRUE.
    

    !------------------------------------------------------------------------------
    SELECT CASE( Name )       
      !------------------------------------------------------------------------------
      
      !------------------------------------------------------------------------------
    CASE('navier-stokes')
      !------------------------------------------------------------------------------
      Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Flow Solution')
      
      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(Ndeg), STAT=istat )
        IF ( istat /= 0 ) CALL Fatal( 'AddEquation', 'Memory allocation error.' )
      END IF
      
      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, Perm, &
          DOFs+1, MatrixFormat, BandwidthOptimize, 'Navier-Stokes', GlobalBubbles=GlobalBubbles )

      Nrows =(DOFs+1)* Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution(Nrows), STAT=istat )
        IF ( istat /= 0 ) CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        
        ! First add components to the variable list separately (must be done
        ! this way for the output routines to work properly...):
        !---------------------------------------------------------------------
        Component => Solution( 1 : Nrows: DOFs+1 )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Velocity 1', &
            1, Component, Perm, Output=VariableOutput )
        
        Component => Solution( 2 : Nrows: DOFs+1 )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Velocity 2', &
            1, Component, Perm, Output=VariableOutput )
        
        IF ( DOFs+1 == 3 ) THEN
          Component => Solution( 3 : Nrows: DOFs+1 )
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Pressure', &
              1, Component, Perm, Output=VariableOutput )
        ELSE
          Component => Solution( 3 : Nrows: DOFs+1 )
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Velocity 3', &
              1, Component, Perm, Output=VariableOutput )
          
          Component => Solution( 4 : Nrows : DOFs+1 )
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Pressure', &
              1, Component, Perm, Output=VariableOutput )
        END IF
        
        ! Then add the thing itself:
        !---------------------------
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
            'Flow Solution',DOFs+1,Solution,Perm, Output=VariableOutput )
        
        Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Flow Solution' )
        Solution = 1.0d-6
      END IF
      CALL AddSolverProcedure( Solver, FlowSolver )
      !------------------------------------------------------------------------------


      !------------------------------------------------------------------------------
    CASE('magnetic induction')
      !------------------------------------------------------------------------------
      Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Magnetic Field')
      
      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(NDeg),STAT=istat )
        IF ( istat /= 0 ) CALL Fatal( 'AddEquation', 'Memory allocation error.' )
      END IF
      
      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
          Perm,3, MatrixFormat, BandwidthOptimize, 'Magnetic Induction', GlobalBubbles=GlobalBubbles )
      
      Nrows = 3*Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution (Nrows), STAT=istat)
        IF ( istat /= 0 ) CALL Fatal( 'AddEquation', 'Memory allocation error.' )

        CALL VariableAddVector( Solver % Mesh % Variables, Solver % Mesh,Solver, &
            'Magnetic Field',3,Solution,Perm,Output=VariableOutput )        
        Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Magnetic Field' )        
        Solution = 0.0d0

	NULLIFY( Solution )	
        ALLOCATE( Solution ( Nrows ), STAT=istat)
        IF ( istat /= 0 ) CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        CALL VariableAddVector( Solver % Mesh % Variables, Solver % Mesh,Solver,&
            'Electric Current', 3, Solution, Perm, Output=VariableOutput )
        Solution = 0.0d0
      END IF
      CALL AddSolverProcedure( Solver, MagneticSolver )
      !------------------------------------------------------------------------------
      
      
      !------------------------------------------------------------------------------
    CASE('stress analysis')
      !------------------------------------------------------------------------------
      IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = 2
      
      Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Displacement')
      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(NDeg),STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        END IF
      END IF
      
      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
          Perm, DOFs, MatrixFormat, BandwidthOptimize, &
          'Stress Analysis', GlobalBubbles=GlobalBubbles )
      
      Nrows = DOFs * Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF ( .NOT.ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution ( Nrows ), STAT=istat)
        IF ( istat /= 0 ) CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        CALL VariableAddVector( Solver % Mesh % Variables, Solver % Mesh,Solver,&
            'Displacement',DOFs,Solution,Perm,Output=VariableOutput )        
        Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Displacement')        
        Solution = 0.0D0
      END IF
      CALL AddSolverProcedure( Solver, StressSolver )
      !------------------------------------------------------------------------------
      
      
      !------------------------------------------------------------------------------
    CASE('mesh update')
      !------------------------------------------------------------------------------
      IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = 2
      
      Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Mesh Update')
      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(Ndeg), STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        END IF
      END IF
      
      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
          Perm, DOFs, MatrixFormat, BandwidthOptimize, 'Mesh Update', GlobalBubbles=GlobalBubbles )
      IF ( .NOT. ASSOCIATED( Solver % Matrix ) )  RETURN
      
      Nrows = DOFs * Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF (.NOT. ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution (Nrows), STAT=istat)
        IF ( istat /= 0 ) CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        CALL VariableAddVector( Solver % Mesh % Variables, Solver % Mesh,Solver,&
            'Mesh Update',DOFs,Solution,Perm,Output=VariableOutput )
        Solution = 0.0d0
        Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Mesh Update' )
      END IF
      
      Var =>  VariableGet( Solver % Mesh % Variables, 'Mesh Velocity')
      IF ( .NOT. ASSOCIATED(Var) ) THEN
        IF ( Transient ) THEN
          ALLOCATE( Solution ( Nrows ), STAT=istat) 
	  IF ( istat /= 0 ) CALL Fatal( 'AddEquation', 'Memory allocation error.' )
          CALL VariableAddVector( Solver % Mesh % Variables, Solver % Mesh,Solver,&
              'Mesh Velocity',DOFs,Solution,Perm,Output=VariableOutput )          
          Solution = 0.0D0
        END IF
      END IF
      CALL AddSolverProcedure( Solver, MeshSolver )
      !------------------------------------------------------------------------------

      
      !------------------------------------------------------------------------------
    CASE('heat equation')
      !------------------------------------------------------------------------------
      Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Temperature' )
      
      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(Ndeg),STAT=istat )
      END IF
      
      eq = ListGetString( CurrentModel % Simulation, 'Gebhardt Factors',Found )
      IF ( Found ) THEN
        CALL LoadGebhardtFactors( Solver % Mesh,eq )
      ELSE
        CALL RadiationFactors( Solver, .TRUE.)
      END IF
      
      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
          Perm,1, MatrixFormat, BandwidthOptimize, &
          'Heat Equation', GlobalBubbles=GlobalBubbles)
      
      Nrows = Ndeg
      IF (ASSOCIATED( Solver % Matrix)) Nrows=Solver % Matrix % NumberOfRows
      IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution(Nrows),STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        END IF
        
        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh, Solver,&
            'Temperature',1, Solution, Perm, Output=VariableOutput )
        
        Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Temperature' )
        Solution = 0.0d0
      END IF
      CALL AddSolverProcedure( Solver, HeatSolver )
      !------------------------------------------------------------------------------

      !------------------------------------------------------------------------------
    CASE DEFAULT

      !------------------------------------------------------------------------------
      str = ListGetString( Solver % Values, 'Procedure', Found )
      IF(Found) Solver % PROCEDURE = GetProcAddr(str)
      
      Solver % TimeOrder = 0
      ALLOCATE( Solver % Variable )
      Solver % Variable % Name = ''
      Solver % Variable % NameLen = 0
      Solver % Variable % Norm = 0.0d0
      NULLIFY( Solver % Variable % Perm )
      NULLIFY( Solver % Variable % Values )
      NULLIFY( Solver % Matrix )
     
      
      ! Check if a variable for the solver exists
      !------------------------------------------------------------------------

      var_name = ListGetString( Solver % Values, 'Variable', Found )
      IF( Found ) THEN

        ! It may be a normal field variable or a global (0D) variable
        !------------------------------------------------------------------------
        
        VariableGlobal = ListGetLogical( Solver % Values, 'Variable Global', Found )
        
        VariableOutput = ListGetLogical( Solver % Values, 'Variable Output', Found )
        IF ( .NOT. Found ) VariableOutput = .TRUE.
        
        DOFs = ListGetInteger( Solver % Values, 'Variable DOFs', Found, minv=1 )
        IF ( .NOT. Found ) THEN
          j = 0
          DOFs = 0
          DO WHILE( .TRUE. )
            i = INDEX( var_name(j+1:), ':' ) + j
            IF ( i<=j ) EXIT
            READ( var_name(i+1:),'(i1)' ) k
            DOFs = DOFs + k
            j = i + 1
          END DO
        END IF
        
        DO WHILE( var_name(1:1) == '-' )
          IF ( var_name(1:10) == '-nooutput ' ) THEN
            VariableOutput = .FALSE.
            var_name(1:LEN(var_name)-10) = var_name(11:)
          END IF
          
          IF ( var_name(1:8) == '-global ' ) THEN
            VariableGlobal = .TRUE.
            var_name(1:LEN(var_name)-8) = var_name(9:)
          END IF
          
          IF ( var_name(1:6) == '-dofs ' ) THEN
            READ( var_name(7:), * ) DOFs
            i = 7
            j = LEN_TRIM( var_name )
            DO WHILE( var_name(i:i) /= ' '  )
              i = i + 1
              IF ( i > j ) EXIT
            END DO
            var_name(1:LEN(var_name)-i) = var_name(i+1:)
          END IF
        END DO
        IF ( DOFs == 0 ) DOFs = 1
                
        NoMatrix = ListGetLogical( Solver % Values, 'No Matrix', Found )
        IF ( .NOT. Found ) NoMatrix = VariableGlobal
    
        n = LEN_TRIM(var_name)
        Solver % Variable => VariableGet( Solver % Mesh % Variables,var_name(1:n) )
        
        
        ! If the variable is a field variable create a permutation and matrix related to it
        !----------------------------------------------------------------------------------
        IsEquation = .FALSE.
        eq = ListGetString( Solver  % Values, 'Equation', Found )
        IF( Found ) THEN
          Found = .FALSE.
          DO i=1, CurrentModel % NumberOfEquations
            IF( ListGetLogical( CurrentModel % Equations(i) % Values, TRIM(eq), Stat)) THEN
              IsEquation = .TRUE.
              EXIT
            END IF
          END DO
        END IF
        
        IF( IsCoupledSolver ) THEN
          CALL Info('AddEquation','Coupled system matrix will be created later on')

        ELSE IF( VariableGlobal ) THEN
          ALLOCATE( Solution( DOFs ) )
          Solution = 0.0_dp
          
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver, &
              var_name(1:n), DOFs, Solution )
          Solver % Variable => VariableGet( Solver % Mesh % Variables, var_name(1:n) )
          IF( DOFs > 1 ) THEN
            DO i=1,DOFs
              tmpname = ComponentName( var_name(1:n), i )
              Component => Solution( i:i )
              CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                  tmpname, 1, Component )
            END DO
          END IF
          
          IF(.NOT. NoMatrix ) THEN
            CALL Warn('AddEquation','Implement matrix methods for global variable')
          END IF
          
        ELSE IF( IsEquation ) THEN
          IF ( ASSOCIATED( Solver % Variable ) ) THEN
            Perm => Solver % Variable % Perm
          ELSE
            ALLOCATE( Perm(Ndeg) )
          END IF
          
          Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
              Perm, DOFs, MatrixFormat, BandwidthOptimize, eq(1:LEN_TRIM(eq)), &
              ListGetLogical( Solver % Values, &
              'Discontinuous Galerkin', Found ), GlobalBubbles=GlobalBubbles )          
          Nrows = DOFs * Ndeg

          IF (ASSOCIATED(Solver % Matrix)) Nrows = Solver % Matrix % NumberOfRows
          
          ! Basically the solver coupled be matrix free but still the matrix
          ! is used here temperarily since it is needed when making the 
          ! permutation vector
          IF( NoMatrix ) THEN
            CALL FreeMatrix( Solver % Matrix )
          END IF
          
          IF (.NOT.ASSOCIATED(Solver % Variable)) THEN
            ALLOCATE( Solution( Nrows ) )
            Solution = 0.0d0
            
            CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver, &
                var_name(1:n), DOFs, Solution, Perm, Output=VariableOutput )
            
            Solver % Variable => VariableGet( Solver % Mesh % Variables, var_name(1:n) )
            
            IF ( DOFs > 1 ) THEN
              DO i=1,DOFs
                tmpname = ComponentName( var_name(1:n), i )
                Component => Solution( i:Nrows-DOFs+i:DOFs )
                CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                    tmpname, 1, Component, Perm, Output=VariableOutput )
              END DO
            END IF
          END IF
        ELSE            
          CALL Warn('AddEquation','Solver has a variable but it is not associated to any equation')
        END IF
      END IF

      IF( ListGetLogical( Solver % Values,'Radiation Solver',Found ) ) THEN
        CALL RadiationFactors( Solver, .TRUE.)
      END IF


      !------------------------------------------------------------------------------
    END SELECT

    IF ( ASSOCIATED(Solver % Matrix) ) THEN
      Solver % Matrix % Comm = MPI_COMM_WORLD
      IF ( Solver % Matrix % DGMatrix ) &
          Solver % Variable % Type=Variable_on_nodes_on_elements
    END IF

    !------------------------------------------------------------------------------
    ! Add the exported variables which are typically auxiliary variables derived
    ! from the solution without their own matrix equation.  
    !------------------------------------------------------------------------------
    l = 0
    DO WHILE( .TRUE. )
      l = l + 1
      str = ComponentName( 'exported variable', l )
      var_name = ListGetString( Solver % Values, str, Found )
      
      IF(.NOT. Found) EXIT

      str = TRIM( ComponentName( 'exported variable', l ) ) // ' Output'
      VariableOutput = ListGetLogical( Solver % Values, str, Found )
      IF ( .NOT. Found ) VariableOutput = .TRUE.
      
      str = TRIM( ComponentName( 'exported variable', l ) ) // ' DOFs'
      DOFs = ListGetInteger( Solver % Values, str, Found )
      IF ( .NOT. Found ) THEN
        j = 0
        DOFs = 0
        DO WHILE( .TRUE. )
          i = INDEX( var_name(j+1:), ':' ) + j
          IF ( i<=j ) EXIT
          READ( var_name(i+1:),'(i1)' ) k
          DOFs = DOFs + k
          j = i + 1
        END DO
      END IF
      
      VariableOutput = .TRUE.
      VariableGlobal = .FALSE.

      DO WHILE( var_name(1:1) == '-' )
        IF ( var_name(1:10) == '-nooutput ' ) THEN
          VariableOutput = .FALSE.
          var_name(1:LEN(var_name)-10) = var_name(11:)
        END IF
        
        IF ( var_name(1:8) == '-global ' ) THEN
          VariableGlobal = .TRUE.
          var_name(1:LEN(var_name)-8) = var_name(9:)
        END IF
        
        IF ( var_name(1:6) == '-dofs ' ) THEN
          READ( var_name(7:), * ) DOFs 
          j = LEN_TRIM( var_name )
          k = 7
          DO WHILE( var_name(k:k) /= ' '  )
            k = k + 1
            IF ( k > j ) EXIT
          END DO
          var_name(1:LEN(var_name)-(k+2)) = var_name(k+1:)
        END IF
      END DO
      IF ( DOFs == 0 ) DOFs = 1
      
      NewVariable => VariableGet( Solver % Mesh % Variables, Var_name )
      
      IF ( .NOT. ASSOCIATED(NewVariable) ) THEN
        IF( VariableGlobal ) THEN
          nSize = DOFs
          NULLIFY( Perm )
        ELSE
          nSize = DOFs * SIZE(Solver % Variable % Values) / Solver % Variable % DOFs
          Perm => Solver % Variable % Perm
        END IF
        
        ALLOCATE( Solution(nSize) )
        Solution = 0.0d0
        IF( ASSOCIATED(Perm) ) THEN
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
              var_name, DOFs, Solution, Solver % Variable % Perm, &
                 Output=VariableOutput, Type=Solver % Variable % Type )
        ELSE          
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
              var_name, DOFs, Solution, Type=Solver % Variable % Type )
        END IF
        
        IF ( DOFs > 1 .AND. .NOT. VariableGlobal ) THEN
          n = LEN_TRIM( var_name )
          DO j=1,DOFs
            tmpname = ComponentName( var_name(1:n), j )
            Component => Solution( j:nSize-DOFs+j:DOFs )
            IF( ASSOCIATED(Perm) ) THEN
              CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                  tmpname, 1, Component, Perm,  &
                     Output=VariableOutput, Type=Solver % Variable % Type )
            ELSE
              CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                  tmpname, 1, Component, Type=Solver % Variable % Type )
            END IF
          END DO
        END IF
      END IF
    END DO


    !------------------------------------------------------------------
    ! Check for special solvers, to be executed only 
    ! at a certain instances during the simulation:
    !------------------------------------------------------------------

    Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS

    SELECT CASE( ListGetString( Solver % Values, 'Exec Solver', Found )  )
      CASE( 'never' )
      Solver % SolverExecWhen = SOLVER_EXEC_NEVER
      CASE( 'always' )
      Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS
      CASE( 'after simulation', 'after all' )
      Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
      CASE( 'before simulation', 'before all' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
      CASE( 'before timestep' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_TIME
      CASE( 'after timestep' )
         Solver % SolverExecWhen = SOLVER_EXEC_AFTER_TIME
      CASE( 'before saving' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_SAVE
      CASE( 'after saving' )
         Solver % SolverExecWhen = SOLVER_EXEC_AFTER_SAVE
      CASE DEFAULT
         Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS
    END SELECT

    IF ( ListGetLogical( Solver % Values, 'Before All', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'Before Simulation', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'After All', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'After Simulation', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'Before Timestep', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_TIME
    ELSE IF ( ListGetLogical( Solver % Values, 'After Timestep', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_TIME
    ELSE IF ( ListGetLogical( Solver % Values, 'Before Saving', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_SAVE
    ELSE IF ( ListGetLogical( Solver % Values, 'After Saving', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_SAVE
    END IF

    Solver % LinAfterProc  = 0
    Solver % LinBeforeProc = 0
    str = ListGetString( Solver  % Values, 'Before Linsolve', Found )
    IF ( Found ) Solver % LinBeforeProc = GetProcAddr( str )

    str = ListGetString( Solver  % Values, 'After Linsolve', Found )
    IF ( Found ) Solver % LinAfterProc = GetProcAddr( str )

  END SUBROUTINE AddEquationBasics


  !------------------------------------------------------------------------------
  SUBROUTINE AddEquationSolution(Solver, Transient )
    !------------------------------------------------------------------------------
    ! Add information that is typically only needed if there's a matrix equation
    ! to work with. This should be called only after both the solution vector and
    ! matrix have been created.
    !------------------------------------------------------------------------------  
    TYPE(Solver_t), POINTER :: Solver
    LOGICAL :: Transient
!------------------------------------------------------------------------------
    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=MAX_NAME_LEN) :: str, var_name, tmpname
    INTEGER :: i,j,k,n,nrows,DOFs
    REAL(KIND=dp), POINTER :: Solution(:), Component(:)
    INTEGER, POINTER :: Perm(:)
    LOGICAL :: Found, Stat, ComplexFlag, HarmonicAnal,EigAnal,VariableOutput, &
        MGAlgebraic,MultigridActive
    REAL(KIND=dp), POINTER :: freqv(:,:)
    TYPE(Mesh_t),   POINTER :: NewMesh,OldMesh
    TYPE(Element_t), POINTER :: CurrentElement
    TYPE(Matrix_t), POINTER :: NewMatrix, Oldmatrix, SaveMatrix


    !------------------------------------------------------------------------------
    Solver % DoneTime = 0
    IF ( .NOT. ASSOCIATED( Solver % Variable ) ) RETURN
    IF ( .NOT. ASSOCIATED(Solver % Variable % Values) ) RETURN
    !------------------------------------------------------------------------------
    
    !------------------------------------------------------------------------------
    ! Create the variable needed for the computation of nodal loads: r=b-Ax
    !------------------------------------------------------------------------------
    IF ( ListGetLogical( Solver % Values,'Calculate Loads', Found ) ) THEN
      Var_name = GetVarName(Solver % Variable) // ' Loads'
      Var => VariableGet( Solver % Mesh % Variables, var_name )
      IF ( .NOT. ASSOCIATED(Var) ) THEN
        ALLOCATE( Solution(SIZE(Solver % Variable % Values)) )
        DOFs = Solver % Variable % DOFs
        Solution = 0.0d0
        nrows = SIZE( Solution ) 
        Perm => Solver % Variable % Perm
        VariableOutput = Solver % Variable % Output

        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
            var_name, Solver % Variable % DOFs, Solution, &
            Solver % Variable % Perm, Output=VariableOutput )

        IF ( DOFs > 1 ) THEN
          n = LEN_TRIM( Var_name )
          DO j=1,DOFs
            tmpname = ComponentName( var_name(1:n), j )
            Component => Solution( j:nRows-DOFs+j:DOFs )
            CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                tmpname, 1, Component, Perm, Output=VariableOutput )
          END DO
        END IF
        NULLIFY( Solution )
      END IF
    END IF

    !------------------------------------------------------------------------------
    ! Add computation of the weights resulting from Galerkin integration
    !------------------------------------------------------------------------------
    IF ( ListGetLogical( Solver % Values,'Calculate Weights', Found ) ) THEN
      Var_name = GetVarName(Solver % Variable) // ' Weights'
      Var => VariableGet( Solver % Mesh % Variables, var_name )
      IF ( .NOT. ASSOCIATED(Var) ) THEN
        Perm => Solver % Variable % Perm
        IF( ASSOCIATED( Perm ) ) THEN
          ALLOCATE( Solution(SIZE(Solver % Variable % Perm)) )
          Solution = 0.0d0        
          VariableOutput = Solver % Variable % Output
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
              var_name, 1, Solution, &
              Solver % Variable % Perm, Output=VariableOutput )
          NULLIFY( Solution )
        END IF
      END IF
    END IF
    !------------------------------------------------------------------------------

    Solver % NOFEigenValues = 0
    !   NULLIFY( Solver % Variable % PrevValues )
    !   NULLIFY( Solver % Variable % EigenValues )
    !   NULLIFY( Solver % Variable % EigenVectors )

    Solver % MultiGridLevel = 1
    Solver % MultiGridTotal = 0
    Solver % MultiGridSolver = .FALSE.
    Solver % MultiGridEqualSplit = .FALSE.


    HarmonicAnal = ListGetLogical( Solver % Values, 'Harmonic Analysis', Found )
    
    IF ( ASSOCIATED( Solver % Matrix ) ) THEN
      IF(.NOT. ASSOCIATED(Solver % Matrix % RHS)) THEN
        ALLOCATE( Solver % Matrix % RHS(Solver % Matrix % NumberOFRows) )
        Solver % Matrix % RHS = 0.0d0
        
        Solver % Matrix % RHS_im => NULL()
        IF ( HarmonicAnal ) THEN
          ALLOCATE( Solver % Matrix % RHS_im(Solver % Matrix % NumberOFRows) )
          Solver % Matrix % RHS_im = 0.0d0
        END IF
      END IF
    END IF
!------------------------------------------------------------------------------

    EigAnal = ListGetLogical( Solver % Values, 'Eigen Analysis', Found )
    
    IF ( Transient .AND. .NOT. EigAnal .AND. .NOT. HarmonicAnal ) THEN
      k = ListGetInteger( Solver % Values, 'Time Derivative Order', Found, &
          minv=0, maxv=2 )
      Solver % TimeOrder = 1
      IF ( Found ) Solver % TimeOrder = MIN(MAX(1,k),2)
      
      IF ( ASSOCIATED( Solver % Matrix ) ) THEN
        ALLOCATE( Solver % Matrix % Force(Solver % Matrix % NumberOFRows, &
            Solver % TimeOrder+1) )
        Solver % Matrix % Force = 0.0d0
      END IF
      
      IF ( .NOT. ASSOCIATED( Solver % Variable % PrevValues ) ) THEN
        IF ( Solver % TimeOrder == 2 ) THEN
          ALLOCATE( Solver % Variable % PrevValues( &
              SIZE(Solver % Variable % Values),5) )
        ELSE IF ( Solver % Order > Solver % TimeOrder ) THEN
          ALLOCATE(Solver % Variable % PrevValues( &
              SIZE(Solver % Variable % Values), Solver % Order))
        ELSE
          ALLOCATE(Solver % Variable % PrevValues( &
              SIZE(Solver % Variable % Values), Solver % TimeOrder))
        END IF
        Solver % Variable % PrevValues = 0.0d0
        
        IF ( Solver % Variable % DOFs > 1 ) THEN
          IF ( Solver % Variable % Name == 'flow solution' ) THEN
            DO k=1,Solver % Variable % DOFs-1
              str = 'Velocity ' // CHAR(k+ICHAR('0'))
              Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
              Var % PrevValues =>  &
                  Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
            END DO
            Var => VariableGet( Solver % Mesh % Variables, 'Pressure', .TRUE. )
            Var % PrevValues =>  &
                Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
          ELSE
            DO k=1,Solver % Variable % DOFs
              str = ComponentName( Solver % Variable % Name, k ) 
              Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
              Var % PrevValues =>  &
                  Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
            END DO
          END IF
        END IF
      END IF


      IF( ListGetLogical( Solver % Values,'Calculate Velocity',Found) ) THEN
        IF ( Solver % TimeOrder == 1 ) THEN
          ALLOCATE( Solution( SIZE( Solver % Variable % Values) ) )
          Solution = 0.0_dp
          str = TRIM( Solver % Variable % Name ) // ' Velocity'
          CALL VariableAddVector( Solver % Mesh % Variables, Solver % Mesh, Solver, &
              str, Solver % Variable % Dofs, Solution, Solver % Variable % Perm )
          NULLIFY( Solution )
        ELSE IF ( Solver % TimeOrder >= 2 ) THEN
          Component => Solver % Variable % PrevValues(:,1)
          str = TRIM( Solver % Variable % Name ) // ' Velocity'
          CALL VariableAddVector( Solver % Mesh % Variables, Solver % Mesh, Solver, &
              str, Solver % Variable % Dofs, Component, Solver % Variable % Perm, &
              Secondary = .TRUE. )
        END IF
      END IF

      IF( ListGetLogical( Solver % Values,'Calculate Acceleration',Found) ) THEN
        IF ( Solver % TimeOrder == 1 ) THEN
          CALL Warn('AddEquationSolution',&
              'No velocity computation implemented for 1st order time integration')
        ELSE IF ( Solver % TimeOrder >= 2 ) THEN
          Component => Solver % Variable % PrevValues(:,2)
          str = TRIM( Solver % Variable % Name ) // ' Acceleration'
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver, &
              str, Solver % Variable % Dofs, Component, Solver % Variable % Perm, &
              Secondary = .TRUE. )
          
          DO k=1,Solver % Variable % DOFs
            Component => Solver % Variable % PrevValues(k::Solver % Variable % DOFs,2)          
            str = ComponentName( Solver % Variable % Name) // ' Acceleration ' // CHAR(i+ICHAR('0'))
            CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver, &
                str, 1, Component, Solver % Variable % Perm, Secondary = .TRUE. )
          END DO
        END IF
      END IF

    ELSE
      Solver % TimeOrder = 0

      IF( ListGetLogical( Solver % Values,'Calculate Derivative',Found) ) THEN
PRINT *,'adding derivative'

        NULLIFY( Solution ) 
        ALLOCATE( Solution( SIZE( Solver % Variable % Values) ) )
        Solution = 0.0_dp
        str = TRIM( Solver % Variable % Name ) // ' Derivative'
        CALL VariableAddVector( Solver % Mesh % Variables, Solver % Mesh, Solver, &
            str, Solver % Variable % Dofs, Solution, Solver % Variable % Perm )
        NULLIFY( Solution )
      END IF

      IF ( EigAnal ) THEN
        ComplexFlag = ListGetLogical( Solver % Values,  'Eigen System Complex', Found )
        IF ( .NOT. Found ) ComplexFlag = .FALSE.
        
        n = ListGetInteger( Solver % Values,  'Eigen System Values', Found )
        IF ( Found .AND. n > 0 ) THEN
          Solver % NOFEigenValues = n
          IF ( .NOT. ASSOCIATED( Solver % Variable % EigenValues ) ) THEN
            ALLOCATE( Solver % Variable % EigenValues(n) )
            ALLOCATE( Solver % Variable % EigenVectors(n, &
                SIZE( Solver % Variable % Values ) ) )
            
            Solver % Variable % EigenValues  = 0.0d0
            Solver % Variable % EigenVectors = 0.0d0
            
            DO k=1,Solver % Variable % DOFs
              str = ComponentName( Solver % Variable % Name, k )
              Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
              IF ( ASSOCIATED( Var ) ) THEN
                Var % EigenValues => Solver % Variable % EigenValues
                IF ( ComplexFlag ) THEN
                  Var % EigenVectors => Solver % Variable % EigenVectors
                ELSE
                  Var % EigenVectors =>  & 
                      Solver % Variable % EigenVectors(:,k::Solver % Variable % DOFs )
                END IF
              END IF
            END DO
          END IF
          ALLOCATE( Solver % Matrix % MassValues(SIZE(Solver % Matrix % Values)) )
          Solver % Matrix % MassValues = 0.0d0
        END IF
      ELSE IF ( HarmonicAnal ) THEN
        freqv => ListGetConstRealArray( Solver % Values, 'Frequency', Found )
        IF ( Found ) THEN
          n = SIZE(Freqv,1)
          Solver % NOFEigenValues = n
          IF ( .NOT. ASSOCIATED( Solver % Variable % EigenValues ) ) THEN
            ALLOCATE( Solver % Variable % EigenValues(n) )
            ALLOCATE( Solver % Variable % EigenVectors(n, &
                SIZE( Solver % Variable % Values ) ) )
            
            Solver % Variable % EigenValues  = 0.0d0
            Solver % Variable % EigenVectors = 0.0d0
            
            DO k=1,Solver % Variable % DOFs
              str = ComponentName( Solver % Variable % Name, k )
              Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
              IF ( ASSOCIATED( Var ) ) THEN
                Var % EigenValues => Solver % Variable % EigenValues
                Var % EigenVectors => &
                    Solver % Variable % EigenVectors(:,k::Solver % Variable % DOFs)
              END IF
            END DO
          END IF
          ALLOCATE( Solver % Matrix % MassValues(SIZE(Solver % Matrix % Values)) )
          Solver % Matrix % MassValues = 0.0d0
        ELSE
          CALL Fatal( 'AddEquation', 'Frequency must be given for harmonic analysis.' )
        END IF
      END IF
    END IF


!------------------------------------------------------------------------------

    IF ( ASSOCIATED( Solver % Matrix ) ) THEN
      Solver % Matrix % Symmetric = ListGetLogical( Solver % Values, &
          'Linear System Symmetric', Found )
      
      Solver % Matrix % Lumped = ListGetLogical( Solver % Values, &
          'Lumped Mass Matrix', Found )
      
      MultigridActive = &
          ListGetString( Solver % Values, 'Linear System Solver', Found ) == 'multigrid' .OR. &
          ListGetString( Solver % Values, 'Linear System Preconditioning', Found ) == 'multigrid'


!      Check for multigrid solver:
!      ---------------------------
       IF ( MultigridActive ) THEN

         str = ListGetString( Solver % Values,'MG Method',Found) 
         IF( Found ) THEN
           MGAlgebraic = ( str == 'algebraic' ) .OR. ( str == 'cluster')
         ELSE    
           MGAlgebraic = ListGetLogical( Solver % Values, 'MG Algebraic', Found ) &
              .OR. ListGetLogical( Solver % Values, 'MG Cluster', Found )
         END IF
         
         Solver % MultiGridTotal = ListGetInteger( Solver % Values, &
             'MG Levels', Found, minv=1 )
         
         IF ( .NOT. Found ) THEN
           Solver % MultiGridTotal = ListGetInteger( Solver % Values, &
               'Multigrid Levels', Found, minv=1 )
         END IF
         IF ( .NOT. Found ) THEN
           IF( MGAlgebraic ) THEN 
             Solver % MultiGridTotal = 10
           ELSE
             Solver % MultiGridTotal = 3
           END IF
         END IF

!         Check if h/2 splitting of mesh requested:
!         ------------------------------------------
         Solver % MultiGridEqualSplit = ListGetLogical( &
             Solver % Values, 'MG Equal Split', Found )
         
         IF ( Solver % MultiGridEqualSplit ) THEN
           CALL ParallelInitMatrix( Solver, Solver % Matrix )
           Solver % MultiGridLevel = 1

           DO WHILE( Solver % MultiGridLevel < Solver % MultiGridTotal )
             IF ( ASSOCIATED( Solver % Mesh % Child ) ) THEN
               NewMesh => Solver % Mesh % Child
               
               OldMesh   => Solver % Mesh
               OldMatrix => Solver % Matrix
               
               CALL UpdateSolverMesh( Solver, NewMesh )
               Solver % Mesh % Changed = .FALSE.
             ELSE
               NewMesh => SplitMeshEqual( Solver % Mesh )
               NewMesh % Next => CurrentModel % Meshes
               CurrentModel % Meshes => NewMesh
               
               OldMesh   => Solver % Mesh
               OldMatrix => Solver % Matrix
               
               CALL UpdateSolverMesh( Solver, NewMesh )
               Solver % Mesh % Changed = .FALSE.
               
               NewMesh % Parent => OldMesh
               OldMesh % Child  => NewMesh
               NewMesh % Name = OldMesh % Name
             END IF
             Newmesh % OutputActive = .TRUE.
             OldMesh % OutputActive = .FALSE.
             
             NewMatrix => Solver % Matrix
             NewMatrix % Parent => OldMatrix
             OldMatrix % Child  => NewMatrix
             CALL ParallelInitMatrix( Solver, Solver % Matrix )
             Solver % MultiGridLevel = Solver % MultiGridLevel + 1
           END DO
         ELSE
           CALL ParallelInitMatrix( Solver, Solver % Matrix )
           OldMesh   => Solver % Mesh
           Var => Solver % Variable
           SaveMatrix => Solver % Matrix

           Solver % MultiGridLevel = 1
           DO WHILE( Solver % MultiGridLevel < Solver % MultigridTotal )
             IF ( ASSOCIATED(Solver % Mesh % Parent) ) THEN
               NewMesh => Solver % Mesh % Parent
               OldMatrix => Solver % Matrix
               CALL UpdateSolverMesh( Solver, NewMesh )
               Solver % Mesh % Changed = .FALSE.
               NewMatrix => Solver % Matrix
               NewMatrix % Child => OldMatrix
               OldMatrix % Parent  => NewMatrix
               CALL ParallelInitMatrix(Solver, Solver % Matrix )
             END IF
             Solver % MultiGridLevel = Solver % MultiGridLevel+1
           END DO

           Solver % Mesh => OldMesh
           Solver % Variable => Var
           Solver % Matrix => SaveMatrix
           CALL SetCurrentMesh(CurrentModel,Solver % Mesh)
         END IF

         CALL MeshStabParams( Solver % Mesh )
         Solver % MultiGridSolver = ListGetString(Solver % Values, &
             'Linear System Solver', Found ) == 'multigrid'
         Solver % MultiGridLevel  = Solver % MultiGridTotal
       END IF
     END IF
     
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
   END SUBROUTINE AddEquationSolution
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE SolveEquations( Model, dt, TransientSimulation, &
      CoupledMinIter, CoupledMaxIter, SteadyStateReached )
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    REAL(KIND=dp) :: dt
    INTEGER :: CoupledMinIter, CoupledMaxIter
    LOGICAL :: TransientSimulation, SteadyStateReached
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: RelativeChange, Tolerance, PrevDT = 0.0d0, Relaxation
    INTEGER :: i,j,k,l,n,ierr,istat
    LOGICAL :: Found, Stat, AbsNorm, Scanning, Convergence, RungeKutta, MeActive, &
       NeedSol, IsCoupledSolver, IsAssemblySolver, CalculateDerivative, TestConvergence
    LOGICAL, ALLOCATABLE :: DoneThis(:), AfterConverged(:)
    TYPE(Solver_t), POINTER :: Solver
    TYPE(Mesh_t),   POINTER :: Mesh
    CHARACTER(LEN=max_name_len) :: When
    TYPE(Variable_t), POINTER :: IterV
    REAL(KIND=dp), POINTER :: steadyIt,nonlnIt
    REAL(KIND=dp), ALLOCATABLE :: k1(:), k2(:), k3(:), k4(:), Values0(:)
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!   Intialize equation solvers for new timestep
!------------------------------------------------------------------------------
    Scanning = &
      ListGetString( CurrentModel % Simulation, 'Simulation Type', Found ) == 'scanning'

    IF ( TransientSimulation ) THEN
       DO k=1,Model % NumberOfSolvers
          Solver => Model % Solvers(k)
          IF ( Solver % PROCEDURE /= 0 ) CALL InitializeTimestep( Solver )
       END DO
    END IF

    IF( TransientSimulation .OR. Scanning ) THEN
       IterV => VariableGet(Model % Solvers(1) % Mesh % Variables, 'coupled iter')
       steadyIt => IterV % Values(1)
    END IF
!------------------------------------------------------------------------------

    DO k=1,Model % NumberOfSolvers
      Solver => Model % Solvers(k)
      IF ( Solver % PROCEDURE==0 ) CYCLE

      when  = ListGetString( Solver % Values, 'Exec Solver', Found )
      IF ( Found ) THEN
        IF ( When == 'before timestep' ) THEN
          CALL SolverActivate( Model,Solver,dt,TransientSimulation )
          CALL ParallelBarrier
        END IF
      ELSE
        IF ( Solver % SolverExecWhen == SOLVER_EXEC_AHEAD_TIME ) THEN
          CALL SolverActivate( Model,Solver,dt,TransientSimulation )
          CALL ParallelBarrier
        END IF
      END IF
    END DO


!------------------------------------------------------------------------------

    ALLOCATE( DoneThis( Model % NumberOfSolvers ), &
         AfterConverged( Model % NumberOfSolvers ) )

    DO i=1,Model % NumberOfSolvers
      Solver => Model % Solvers(i)
      AfterConverged(i) = ListGetLogical( Solver % Values, &
             'Coupled System After Others Converged', Found )
    END DO

    IF ( PrevDT == 0.0d0 ) PrevDT = dt
!------------------------------------------------------------------------------
    DO i=1,CoupledMaxIter
       IF ( TransientSimulation .OR. Scanning ) THEN
         CALL Info( 'SolveEquations', '-------------------------------------', Level=3 )
         WRITE( Message, * ) 'Coupled system iteration: ', i
         CALL Info( 'SolveEquations', Message, Level=3 )
         CALL Info( 'SolveEquations', '-------------------------------------', Level=3 )         
         steadyIt = i
       END IF

       DoneThis = .FALSE.

!      Initialize the mesh output flag to FALSE here, reactivated
!      later for meshes connected to active solvers.
!      ----------------------------------------------------------
       Mesh => Model % Meshes
       DO WHILE( ASSOCIATED( Mesh ) )
          Mesh % OutputActive = .FALSE.
          Mesh => Mesh % Next
       END DO



!------------------------------------------------------------------------------
!      Go trough number of solvers (heat,laminar or turbulent flow, etc...)
!------------------------------------------------------------------------------
       DO k=1,Model % NumberOfSolvers
!------------------------------------------------------------------------------

          Solver => Model % Solvers(k)

          IsCoupledSolver = ListGetLogical( Solver % Values, 'Coupled Solver', Found )
          IsAssemblySolver = ListGetLogical( Solver % Values, 'Assembly Solver', Found )
          IsAssemblySolver = IsAssemblySolver .OR. IsCoupledSolver

          IF ( Solver % PROCEDURE == 0 .AND. .NOT. IsAssemblySolver ) THEN
            CALL Warn('SolveEquations','No routine related to solver!')
            DoneThis(k) = .TRUE.
            CYCLE
          END IF

          When = ListGetString( Solver % Values, 'Exec Solver', Found )
          IF ( Found ) THEN
            IF ( When /= 'always' ) THEN
              DoneThis(k) = .TRUE.
              CYCLE
            END IF
          ELSE
            IF ( Solver % SolverExecWhen /= SOLVER_EXEC_ALWAYS ) THEN
              DoneThis(k) = .TRUE.
              CYCLE
            END IF
          END IF

          IF ( AfterConverged(k) .AND. .NOT. ALL(AfterConverged .OR. DoneThis) ) CYCLE
!------------------------------------------------------------------------------

          RungeKutta = .FALSE.
          IF ( TransientSimulation .AND. Solver % TimeOrder == 1 ) THEN
            RungeKutta = ListGetString( Solver % Values, &
                'Timestepping Method', Found ) == 'runge-kutta'
          END IF
          
          n = 0
          IF ( ASSOCIATED(Solver % Variable) ) THEN
            IF ( ASSOCIATED(Solver % Variable % Values) ) &
                n = SIZE(Solver % Variable % Values)
            Solver % Variable % PrevNorm = Solver % Variable % Norm
          END IF

          ! There are some operations that require that the previous steady state values
          ! are present. Check for these operations.
          !------------------------------------------------------------------------------
          CalculateDerivative = ListGetLogical( Solver % Values, &
                'Calculate Derivative', Stat )

          NeedSol = CalculateDerivative
          IF(.NOT. NeedSol ) THEN
            NeedSol = ( ListGetString( Solver % Values, &
                'Steady State Convergence Measure', Stat ) /= 'norm')  
            NeedSol = NeedSol .AND. Stat
          END IF
          IF(.NOT. NeedSol ) THEN
            Relaxation = ListGetConstReal( Solver % Values, &
                'Steady State Relaxation Factor', Stat )
            NeedSol = Stat .AND. (Relaxation /= 1.0d0)
          END IF

          IF ( NeedSol .AND. n > 0 ) THEN
            Stat = ASSOCIATED(Solver % Variable % SteadyValues)
            IF(Stat .AND. SIZE(Solver % Variable % SteadyValues) /= n) THEN
              DEALLOCATE(Solver % Variable % SteadyValues)
              Stat = .FALSE.
            END IF
            IF(.NOT. Stat) THEN
              ALLOCATE( Solver % Variable % SteadyValues(n), STAT=istat ) 
              IF ( istat /= 0 ) CALL Fatal( 'SolveEquations', 'Memory allocation error.' )
            END IF
            Solver % Variable % SteadyValues(1:n) = Solver % Variable % Values(1:n)
          END IF


          IF ( RungeKutta .AND. n > 0 ) THEN

            SELECT CASE( Solver % Order )
            CASE(2)
              ALLOCATE( k1(n), k2(n) )

              k1 = Solver % Variable % PrevValues(:,1)-Solver % Variable % PrevValues(:,2)
              k1 = dt * k1 / PrevDT
              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k1
              CALL SolverActivate( Model,Solver,dt,TransientSimulation )
              k2 = Solver % Variable % Values - Solver % Variable % PrevValues(:,1)

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + &
                                  ( k1 + k2 ) / 2
              DEALLOCATE( k1, k2 )


            CASE DEFAULT
              ALLOCATE( k1(n), k2(n), k3(n), k4(n) )

              k1 = Solver % Variable % PrevValues(:,1)-Solver % Variable % PrevValues(:,2)
              k1 = dt * k1 / PrevDT
              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k1/2
              CALL SolverActivate( Model,Solver,dt/2,TransientSimulation )
              k2 = 2*(Solver % Variable % Values - Solver % Variable % PrevValues(:,1))

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k2
              CALL SolverActivate( Model,Solver,dt/2,TransientSimulation )
              k3 = 2*(Solver % Variable % Values - Solver % Variable % PrevValues(:,1))

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k3
              CALL SolverActivate( Model,Solver,dt,TransientSimulation )
              k4 = Solver % Variable % Values - Solver % Variable % PrevValues(:,1)

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + &
                                ( k1 + 2*k2 + 2*k3 + k4 ) / 6
              DEALLOCATE( k1, k2, k3, k4 )
            END SELECT
            Solver % Variable % Norm = &
                ComputeNorm(Solver, n, Solver % Variable % Values)
           ELSE
             CALL SolverActivate(Model,Solver,dt,TransientSimulation)
           END IF
!------------------------------------------------------------------------------
!         check for coupled system convergence
!------------------------------------------------------------------------------

           IF ( Scanning ) THEN
             
             TestConvergence = ( i >= CoupledMinIter .AND. i /= CoupledMaxIter )

             IF ( TestConvergence .OR. CalculateDerivative ) THEN
               IF ( ParEnv % PEs>1 ) THEN
                 IF ( ParEnv % Active(ParEnv % MyPE+1) ) &
                     CALL ComputeChange(Solver,.TRUE., n)
               ELSE
                 CALL ComputeChange(Solver,.TRUE.)
                 !                 CALL ComputeChange(Solver,.TRUE.,n)
               END IF

               ! The ComputeChange subroutine sets a flag to zero if not yet converged (otherwise -1/1)
               !----------------------------------------------------------------------
               IF( TestConvergence ) THEN
                 IF( Solver % Variable % SteadyConverged == 0 ) THEN
                   DoneThis(k) = .FALSE.
                 ELSE                   
                   DoneThis(k) = .TRUE.
                 END IF                   
               END IF
             END IF
             
           ELSE IF( TransientSimulation ) THEN
             
             TestConvergence = ( i >= CoupledMinIter .AND. i /= CoupledMaxIter )
             IF ( TestConvergence ) THEN
               IF ( ParEnv % PEs>1 ) THEN
                 IF ( ParEnv % Active(ParEnv % MyPE+1) ) &
                     CALL ComputeChange(Solver,.TRUE., n)
               ELSE
                 CALL ComputeChange(Solver,.TRUE.)
                 !                 CALL ComputeChange(Solver,.TRUE.,n)
               END IF
               IF( Solver % Variable % SteadyConverged == 0 ) THEN
                 DoneThis(k) = .FALSE.
               ELSE                   
                 DoneThis(k) = .TRUE.
               END IF
             END IF

           ELSE    ! Steady-state
             IF ( ParEnv % PEs > 1 ) THEN
               IF ( ParEnv % Active(ParEnv % MyPE+1) ) &
                   CALL ComputeChange(Solver,.TRUE., n)
             ELSE
               CALL ComputeChange(Solver,.TRUE.)
               !                 CALL ComputeChange(Solver,.TRUE.,n)
             END IF             

             IF( Solver % Variable % SteadyConverged == 0 ) THEN
               DoneThis(k) = .FALSE.
             ELSE                   
               DoneThis(k) = .TRUE.
             END IF
           END IF
           
           CALL ParallelAllReduceAnd( DoneThis(k) )
           IF( ALL(DoneThis) ) EXIT
!------------------------------------------------------------------------------
         END DO
!------------------------------------------------------------------------------
       Model % Mesh % Changed = .FALSE.
       IF ( ALL(DoneThis) ) EXIT
    END DO
    PrevDT = dt

    IF ( TransientSimulation .AND. .NOT. ALL(DoneThis) ) THEN
       IF ( ListGetLogical( Model % Simulation,  &
               'Coupled System Abort Not Converged', Found ) ) THEN
          CALL Error( 'SolveEquations', ' ' )
          WRITE( Message, * ) 'Coupled system iteration: ', i
          CALL Error( 'SolveEquations', Message )
          CALL Fatal( 'SolveEquations', ' ' )
       ELSE
!         CALL Error( 'SolveEquations', ' ' )
!         WRITE( Message, * ) 'Coupled system iteration: ', i
!         CALL Error( 'SolveEquations', Message )
!         CALL Error( 'SolveEquations', ' ' )
       END IF
    END IF

!------------------------------------------------------------------------------

    DO k=1,Model % NumberOfSolvers
      Solver => Model % Solvers(k)
      IF ( Solver % PROCEDURE==0 ) CYCLE

      When = ListGetString( Solver % Values, 'Exec Solver', Found )
      IF (  Found ) THEN
         IF ( When == 'after timestep' ) THEN
           CALL SolverActivate( Model,Solver,dt,TransientSimulation )
           CALL ParallelBarrier
         END IF
      ELSE
         IF ( Solver % SolverExecWhen == SOLVER_EXEC_AFTER_TIME ) THEN
           CALL SolverActivate( Model,Solver,dt,TransientSimulation )
           CALL ParallelBarrier
         END IF
      END IF
    END DO

!------------------------------------------------------------------------------
    IF ( .NOT.TransientSimulation ) SteadyStateReached = ALL(DoneThis)
!------------------------------------------------------------------------------
    DEALLOCATE( DoneThis, AfterConverged )
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  END SUBROUTINE SolveEquations
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE CoupledSolver( Model, Solver, dt, Transient )
!------------------------------------------------------------------------------
! Provide assembly loop and solution of linear and nonlinear systems
! This routine uses minimalistic assmebly routines to create the 
! matrices. Often the results to less labour in coding which may be 
! comprimized by less flexibility.
! 
! There are currently two modes
! IsCoupledSolver:  the variable consists of several pieces and the matrix equation
!                   is created within this solver.
! IsAssemblySolver: only one assembly routine is used and the matrix equation may
!                   be formed externally using standard procedures.
!------------------------------------------------------------------------------

! TODO:
! non-nodal elements (internal allocation & right elementtype)
! solution (and perm) vectors could be reused by setting pointers to correct positions
! check the time-dependency
! check for eigenmode analysis
! different lumped functionalities (energy,...)
! bandwidth optimization for coupled system

    
    USE DefUtils
    
    IMPLICIT NONE
!------------------------------------------------------------------------------
    TYPE(Solver_t), TARGET :: Solver
    TYPE(Model_t) :: Model
    REAL(KIND=dp) :: dt
    LOGICAL :: Transient
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
    TYPE(Solver_t), POINTER :: PSolver, PSolver2
    TYPE(Variable_t), POINTER :: Var
    TYPE(Element_t),POINTER :: Element
    INTEGER :: i,j,k,l,t,n,nd,NoIterations,NoTests,iter,istat,tests
    REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), DAMP(:,:), MASS(:,:), FORCE(:)
    CHARACTER(LEN=MAX_NAME_LEN) :: ProcName
    LOGICAL :: GotIt, GotIt2, GotProc, BulkMode, ThisConstraint, &
        IsCoupledSolver, IsAssemblySolver, IsListMatrix
    INTEGER(KIND=AddrInt) :: ProcPntr    
    INTEGER :: Row, Col, ColDofs, RowDofs, ColInd0, RowInd0, MaxDofs, &
         ColVar, RowVar, Nrow, Ncol, NoVar, NoCons, TotSize, ConDofs, OffSet(20), &
         VarSizes(20), VarDofs(20)
    INTEGER :: ElementsFirst, ElementsLast, bf_id, bc_id, body_id, eq_id, solver_id
    INTEGER, POINTER :: VarPerm(:), ColPerm(:), RowPerm(:), ColInds(:), RowInds(:), DirPerm(:)
    REAL(KIND=dp), POINTER :: ConsValues(:), Component(:)
    REAL(KIND=dp) :: NonlinearTol, Norm, PrevNorm, ConsValue, ConsCoeff, ConsVolume, &
        Residual, PrevResidual
    CHARACTER(LEN=max_name_len) :: str, VarName, ColName, RowName, ConsType
    LOGICAL :: Coupling, Equality, AssemblySymmetric, AssemblyAntisymmetric, &
        AllDirFlag, Robust, ErrorReduced
    INTEGER, POINTER :: Rows(:),Cols(:),Diag(:),Indexes(:),AllPerm(:),ActiveVariables(:)
    TYPE(ListMatrix_t), POINTER :: Alist(:) => NULL()
    REAL(KIND=dp), POINTER :: ForceVector(:),AllValues(:)
    LOGICAL, POINTER :: AllDir(:)
    TYPE (Matrix_t), POINTER :: Amat
    INTEGER, POINTER :: VarInds(:)

    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(ValueList_t), POINTER :: SolverParams

    INTERFACE 
      SUBROUTINE ExecLocalAssembly( Proc, Model, Solver, dt, Transient, &
          M, D, S, F, Element, Nrow, Ncol )
        USE Types
        INTEGER(KIND=AddrInt) :: Proc
        TYPE(Model_t)   :: Model
        TYPE(Solver_t)  :: Solver
        REAL(KIND=dp)   :: dt
        LOGICAL :: Transient
        REAL(KIND=dp) :: S(:,:), D(:,:), M(:,:), F(:)
        TYPE(Element_t) :: Element
        INTEGER :: Nrow, Ncol
      END SUBROUTINE ExecLocalAssembly
    END INTERFACE
    

    IsCoupledSolver = ListGetLogical( Solver % Values,'Coupled Solver',GotIt)
    IsAssemblySolver = ListGetLogical( Solver % Values,'Assembly Solver',GotIt)


    CALL Info('CoupledSolver','---------------------------------------',Level=5)
    IF(IsCoupledSolver) THEN
      CALL Info('CoupledSolver','Solving a system of equations',Level=5)
    ELSE IF(IsAssemblySolver) THEN
      CALL Info('CoupledSolver','Solving one equation',Level=5)      
    ELSE
      CALL Fatal('CoupledSolver','You should maybe not be here?')
    END IF
    CALL Info('CoupledSolver','---------------------------------------',Level=5)


    Mesh => GetMesh()
    SolverParams => GetSolverParams()
    PSolver => Solver

    !------------------------------------------------------------------------------
    ! Check out which variables the coupled model includes
    ! and compure size information related to the new coupled dof.
    !------------------------------------------------------------------------------
    Offset = 0
    VarSizes = 0    
    NoVar = 0
    NoCons = 0
    VarDofs = 0


    IF( IsCoupledSolver ) THEN

      solver_id = 0
      DO i = 1, Model % NumberOfSolvers
        PSolver2 => Model % Solvers(i)
        IF( ASSOCIATED( PSolver2, PSolver ) ) THEN
          solver_id = i
          EXIT
        END IF
      END DO
      
      DO i = 1,9
        WRITE (str,'(A,I2)') 'Variable',i
        VarName = ListGetString( SolverParams, TRIM(str), GotIt )
        IF(.NOT. GotIt) EXIT
        Var => VariableGet( Mesh % Variables, TRIM(VarName) )
        
        !-----------------------------------------------------------------------------------
        ! If variable does not exist it will be created. 
        ! Here only normal nodal elements are supported for the moment. 
        ! Then also the creation of permutation vector is straight-forward.
        ! Note that no reordering is currently performed.
        !
        ! There is limitation regarding non-nodal elements which stems partly from the fact
        ! that an elementtype is solver specific while this one solver could have a number of
        ! different elementtypes for different equations.
        !-----------------------------------------------------------------------------------
        IF(.NOT. ASSOCIATED( Var )) THEN
          CALL Info('CoupledSolver','Variable '//TRIM(VarName)//' does not exist, creating')
          n = Solver % Mesh % NumberOfNodes
          NULLIFY( VarPerm )
          ALLOCATE( VarPerm(n) )
          VarPerm = 0

          !------------------------------------------------------------------------------             
          DO t=1,Mesh % NumberOfBulkElements + Mesh % NumberOFBoundaryElements

            Element => Mesh % Elements(t)
            CurrentModel % CurrentElement => Element
            
            body_id = Element % BodyId 
            IF( body_id < 1 ) CYCLE

            eq_id = ListGetInteger( CurrentModel % Bodies(body_id) % Values,'Equation')
            IF( eq_id < 1 ) CYCLE

            WRITE (str,'(A,I1,A)') 'Active Variables[',i,']'

            ActiveVariables => ListGetIntegerArray( CurrentModel % Equations(eq_id) % Values, str)
            IF(.NOT. ASSOCIATED(ActiveVariables)) THEN
              ActiveVariables => ListGetIntegerArray( CurrentModel % Equations(eq_id) % Values, &
                  'Active Variables')
            END IF

            IF(.NOT. ASSOCIATED(ActiveVariables)) CYCLE

            IF( ANY(ActiveVariables == i) )  THEN
              n  = GetElementNOFNodes()
              Indexes => Element % NodeIndexes
              VarPerm( Indexes(1:n) ) = 1
            END IF
          END DO

          j = 0
          DO t = 1, SIZE(VarPerm)
            IF( VarPerm(t) > 0 ) THEN
              j = j + 1
              VarPerm(t) = j
            END IF
          END DO

          IF( j > 0 ) THEN
            WRITE (str,'(A,I2,A)') 'Variable',i,' Dofs'
            ConDofs = ListGetInteger( SolverParams, TRIM(str), GotIt )
            IF(.NOT. GotIt) ConDofs = 1

            ALLOCATE(ConsValues(ConDofs * j))
            ConsValues = 0.0_dp

            CALL VariableAdd( Mesh % Variables, Mesh, Solver, &
                VarName, ConDofs, ConsValues, VarPerm )          
            WRITE( Message,'(A,I2,A)') 'Creating variable '//TRIM(VarName)//' WITH',ConDofs,' dofs'
            CALL Info('CoupledSolver',Message)

            IF( ConDofs > 1 ) THEN
              DO t=1,ConDofs
                Component => ConsValues(t:ConDofs*(j-1)+t:ConDofs)
                WRITE(str,'(A,I2)') TRIM(VarName),t
                CALL VariableAdd( Mesh % Variables, Mesh, Solver, &
                    str, 1, Component, VarPerm )          
                ! PRINT *,'Creating variable ',TRIM(str)
             END DO
            END IF

            Var => VariableGet( Mesh % Variables, VarName )         
            NULLIFY( ConsValues )
          ELSE 
            CALL Fatal('CoupledSolver','Variable '//TRIM(VarName)//' cannot be created')
          END IF
        END IF

        NoVar = NoVar + 1
        VarDofs(NoVar) = Var % Dofs
        VarSizes(NoVar) = SIZE( Var % Values )
        Offset(NoVar+1) = Offset(NoVar) + VarSizes(NoVar)
      END DO

      !------------------------------------------------------------------------------------
      ! Here is a hack for taking constraints into account where dofs are created on-the-fly
      ! might be better to create special solvers somewhere else.
      ! The size of constraint is deduced directly from its type.
      !-------------------------------------------------------------------------------------
      AllDirFlag = .FALSE.
      DO i = 1,9
        WRITE (str,'(A,I2)') 'Constraint',i
        VarName = ListGetString( SolverParams, TRIM(str), GotIt )
        IF(.NOT. GotIt) EXIT
        
        NoCons = NoCons + 1      
        
        WRITE (str,'(A,I2,A)') 'Constraint',i,' Type'
        ConsType = ListGetString( SolverParams,TRIM(str))
        
        SELECT CASE( ConsType )
          
        CASE('integral')
          ConDofs = 1
          
        CASE('floating')
          ConDofs = 1
          AllDirFlag = .TRUE.
          
        CASE('equality')
          ConDofs = 0
          AllDirFlag = .TRUE.
          
        CASE DEFAULT          
          CALL Warn('CoupledSolver','Coupled constraint does not really work yet')
          WRITE (str,'(A,I2,A)') 'Constraint',i,' DOFs'
          ConDofs = ListGetInteger( SolverParams, str)

        END SELECT

        ! Create the constrained variables for possible other use
        !-----------------------------------------------------------
        IF( ConDofs > 0 ) THEN
          Var => VariableGet( Mesh % Variables, VarName )
          IF( .NOT. ASSOCIATED(Var) ) THEN
            CALL Info('CoupledSolver','Constraint '//TRIM(VarName)//' does not exist, creating')
            ALLOCATE(ConsValues(ConDofs))
            CALL VariableAdd( Mesh % Variables, Mesh, Solver, &
                VarName, ConDofs, ConsValues, Output = .FALSE. )          
            Var => VariableGet( Mesh % Variables, VarName )         
          END IF
        END IF
        
        j = NoVar + NoCons
        VarDofs(j) = ConDofs
        VarSizes(j) = 1
        Offset(j+1) = Offset(j) + VarSizes(j)
      END DO

      DO j=1,NoVar+NoCons
        WRITE(Message,'(A,I2,A,T35,I10)') 'Permutation offset',j,': ',OffSet(j)
        CALL Info('CoupledSolver',Message)
      END DO
      
      TotSize = SUM( VarSizes )
      MaxDofs = MAXVAL( VarDofs )
      
      WRITE(Message,'(A,T35,I10)') 'Number of coupled variables: ',NoVar
      CALL Info('CoupledSolver',Message)
      
      WRITE(Message,'(A,T35,I10)') 'Number of constraints: ',NoCons
      CALL Info('CoupledSolver',Message)
      
      WRITE(Message,'(A,T35,I10)') 'Size of coupled system: ',TotSize
      CALL Info('CoupledSolver',Message)
      
      ! For the 1st time the matrix should be a list, later CRS
      !--------------------------------------------------------
      IF(.NOT. ASSOCIATED(Solver % Matrix)) THEN
        Amat => AllocateMatrix()
        Amat % ListMatrix => Alist
        Amat % FORMAT = MATRIX_LIST      
        Solver % Matrix => Amat
      END IF

      ! This actual variable is not saved, so a dummy name suffices
      !------------------------------------------------------------
      VarName = ListGetString( SolverParams,'Variable', GotIt )
      IF(.NOT. GotIt) THEN
        CALL Info('CoupledSolver','New coupled variable added: Alldofs', Level=5)
        VarName = 'alldofs'
      END IF

      ! If the variable hasn't been created do it now
      !----------------------------------------------
      Var => VariableGet(Mesh % Variables, VarName )
      IF(.NOT. ASSOCIATED(Var) ) THEN

        ALLOCATE(AllPerm(TotSize),AllValues(TotSize),ForceVector(TotSize))
        DO i=1,TotSize
          AllPerm(i) = i
          AllValues(i) = 0.0_dp
        END DO
        CALL VariableAdd( Mesh % Variables, Mesh, Solver, &
            VarName,1,AllValues,AllPerm,Output=.FALSE.)        
        Amat % Rhs => ForceVector
        Solver % Variable => VariableGet(Mesh % Variables, VarName )
        Var => Solver % Variable
       
        ! Map the original vectors to the monolithic vector if requested
        !----------------------------------------------------------------------------------
        IF( ListGetLogical( SolverParams,'Coupled Initial Guess',GotIt)) THEN
          CALL SingleToCoupledVector()
        END IF
      END IF
    ELSE
      CALL Info('CoupledSolver','Using existing variable and matrix')
      IF(.NOT. ASSOCIATED(Solver % Matrix)) THEN
        CALL Fatal('CoupledSolver','In Assembly Solver mode the Matrix should exist!')
      END IF
      IF(.NOT. ASSOCIATED(Solver % Variable)) THEN
        CALL Fatal('CoupledSolver','In Assembly Solver mode the Variable should exist!')
      END IF
      NoVar = 1
      Var => Solver % Variable
      VarDofs(1) = Var % Dofs
      VarSizes(1) = SIZE( Var % Values )
      TotSize = VarSizes(1)
      MaxDofs = VarDofs(1)
    END IF
      

!------------------------------------------------------------------------------
! Do some initial stuff common for both modes
!------------------------------------------------------------------------------
  
    N = Mesh % MaxElementDOFs
    
    ALLOCATE( FORCE( MaxDofs*N ),      &
        STIFF( MaxDofs*N, MaxDofs*N ), &
        DAMP( MaxDofs*N, MaxDofs*N ),  &
        MASS(  MaxDofs*N, MaxDofs*N ), &
        ColInds( N ), RowInds( N ),    &
        Indexes( n ), STAT=istat )
    IF ( istat /= 0 ) CALL FATAL('CoupledSolver','Memory allocation error')
    
    NoIterations = GetInteger( SolverParams,'Nonlinear System Max Iterations',GotIt)
    IF(.NOT. GotIt) NoIterations = 1
    NonlinearTol = GetCReal( SolverParams,'Nonlinear System Convergence Tolerance',gotIt)
    Robust = ListGetLogical(Solver % Values,'Nonlinear System Linesearch',GotIt)
    IF( Robust ) THEN
      NoTests = GetInteger( SolverParams,'Nonlinear System Linesearch Iterations',GotIt)
      IF(.NOT. GotIt) NoTests = NoIterations
      CALL ListAddString(Solver % Values,'Nonlinear System Convergence Measure','residual')
      CALL ListAddLogical(Solver % Values,'Skip Compute Nonlinear Change',.TRUE.)
    END IF
       
    Amat => GetMatrix()
    ForceVector => Amat % Rhs
    IF( AllDirFlag ) ALLOCATE( AllDir(TotSize) ) 
   
!------------------------------------------------------------------------------
! Iterate over any nonlinearity of material or source
!------------------------------------------------------------------------------
    CALL Info('CoupledSolver','-------------------------------------------------',Level=5)
    Residual = -1.0_dp
    PrevResidual = -1.0_dp
    IsListMatrix = ( Amat % FORMAT == MATRIX_LIST )
    
    DO iter = 1,NoIterations
      
      WRITE(Message,'(A,T35,I5)') 'Coupled iteration:',iter
      CALL Info('CoupledSolver',Message,Level=5)
   
      tests = 0
100   IF(.NOT. IsListMatrix ) CALL DefaultInitialize()
      IF( AllDirFlag ) AllDir = .FALSE.

!----------------------------------------------------------------
! For clarity the whole assembly process put under one subroutine 
!----------------------------------------------------------------
      CALL CoupledSystemAssembly()
      IF( IsCoupledSolver .AND. NoCons > 0 ) THEN
        CALL CoupledConstraintAssembly()
      END IF

!----------------------------------------------------------------------
! The CRS matrix may be created only when the matrix structure is known
! and some initialization may be done only when the matrix exists
!----------------------------------------------------------------------
      IF( IsListMatrix ) THEN
        CALL List_ToCRSMatrix(Amat)
        IsListMatrix = .FALSE.
        CALL AddEquationSolution(PSolver, Transient )
        GOTO 100  
      END IF
      CALL DefaultFinishAssembly()
      
!------------------------------------------------------------------------------
!    Do the Dirichlet conditions using offset
!------------------------------------------------------------------------------          
      IF( IsCoupledSolver ) THEN
        CALL CoupledSystemDirichlet()
      ELSE      
        CALL DefaultDirichletBCs()
      END IF

!------------------------------------------------------------------------------
!    Check the stepsize of nonlinear iteration using the Armijo-GoldStein 
!    criterion for the stepsize.
!------------------------------------------------------------------------------          
      IF( Robust  ) THEN   
        ErrorReduced = CheckStepSize(Solver,tests==0,PrevResidual,Residual)
        tests = tests + 1
        
        IF( tests >  NoTests ) THEN
          CALL Warn('CoupledSolver','Maximum number of linesearch steps exceeded')
          ErrorReduced = .TRUE.
        END IF
        
        ! Update the reference residual only when new step is accepted
        IF( iter == 1 ) THEN
          PrevResidual = Residual
        ELSE
          IF( ErrorReduced ) THEN 
            PrevResidual = Residual
            IF(Solver % Variable % NonlinChange < NonlinearTol) EXIT
          ELSE
            IF( IsCoupledSolver ) CALL CoupledToSingleVector()
            GOTO 100
          END IF
        END IF
      END IF

!------------------------------------------------------------------------------
!   Finally solve the system
!------------------------------------------------------------------------------          
      Norm = DefaultSolve()     
      CALL Info('CoupledSolver','-------------------------------------------------',Level=5)

      IF( IsCoupledSolver ) CALL CoupledToSingleVector()

      ! The non-robust solver will use one assembly routine less 
      IF(.NOT. Robust) THEN
        IF(Solver % Variable % NonlinChange < NonlinearTol) EXIT
      END IF
    END DO

    
    DEALLOCATE( FORCE, STIFF, DAMP, MASS, ColInds, RowInds, Indexes )
    IF( AllDirFlag ) DEALLOCATE( AllDir ) 
    
    CALL Info('CoupledSolver','All done')
    CALL Info('CoupledSolver','-------------------------------------------------',Level=5)


  CONTAINS 

!------------------------------------------------------------------------------
   SUBROUTINE IntegralConstraint( Mass, Damp, Stiff, Force, Element, n )
!------------------------------------------------------------------------------
! Integration routine for integral type of constraints i.e. body or boundary
! integral of some dof is known a priori.
!------------------------------------------------------------------------------
     
      IMPLICIT NONE
!------------------------------------------------------------------------------
      REAL(KIND=dp) :: Stiff(:,:), Damp(:,:), Mass(:,:), Force(:)
      TYPE(Element_t), POINTER :: Element
      INTEGER :: n
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------
      TYPE(GaussIntegrationPoints_t) :: IntegStuff
      REAL(KIND=dp) :: Basis(n)
      REAL(KIND=dp) :: Weight, DetJ
      INTEGER :: i,j,t,p,q
      LOGICAL :: Found
      
      TYPE(Nodes_t),SAVE :: Nodes
      
      CALL GetElementNodes( Nodes ) 
      IntegStuff = GaussPoints( Element )
      
      DO t=1,IntegStuff % n
        Found = ElementInfo( Element, Nodes, IntegStuff % u(t), &
            IntegStuff % v(t), IntegStuff % w(t), detJ, Basis )     
        Weight = IntegStuff % s(t) * detJ
        DO p=1,n
          STIFF(1,p) = STIFF(1,p) + Weight * Basis(p)
          FORCE(p) = FORCE(p) + ConsValue * Weight * Basis(p)
        END DO
        ConsVolume = ConsVolume + Weight 
      END DO

!------------------------------------------------------------------------------
    END SUBROUTINE IntegralConstraint
!------------------------------------------------------------------------------
 
   
    !------------------------------------------------------------------------------          
    ! Subroutine sets the Dirichlet conditions for the coupled system 
    ! using the single system vector names and sizes.
    !----------------------------------------------------------------------------------
    SUBROUTINE CoupledSystemDirichlet()
      CALL Info( 'CoupledSolver', 'Setting coupled system Dirichlet conditions', Level=4 )
      
      DO i = 1,NoVar
        WRITE (str,'(A,I2)') 'Variable',i
        VarName = ListGetString( SolverParams, TRIM(str), GotIt )
        IF(.NOT. GotIt) EXIT
        
        Var => VariableGet( Mesh % Variables, TRIM(VarName) )
        IF (.NOT. ASSOCIATED(Var)) EXIT 
        
        CALL DefaultDirichletBCs( Ux=Var, UOffset=Offset(i) )
      END DO
 
    END SUBROUTINE CoupledSystemDirichlet


    !------------------------------------------------------------------------------          
    ! Subroutine copies results from the single system vectors to a coupled system
    ! initial guess.
    !----------------------------------------------------------------------------------
    SUBROUTINE SingleToCoupledVector()
      CALL Info('CoupledSolver','Copying an initial guess',Level=5)
      
      DO i = 1,NoVar + NoCons
        IF( VarDofs(i) == 0 ) CYCLE
        
        IF( i <= NoVar ) THEN
          WRITE (str,'(A,I2)') 'Variable',i
        ELSE
          WRITE (str,'(A,I2)') 'Constraint',i-NoVar        
        END IF
        VarName = ListGetString( SolverParams, TRIM(str), GotIt )
        Var => VariableGet( Mesh % Variables, TRIM(VarName) )
        
        ! CALL Info('CoupledSolver','Copying from variable: '//TRIM(VarName),Level=5)
        DO j=1,SIZE(Var % Values)
          Solver % Variable % Values(Offset(i)+j) = Var % Values(j)
        END DO
      END DO

    END SUBROUTINE SingleToCoupledVector


    !------------------------------------------------------------------------------          
    ! Subroutine copies results from the coupled system vector back to the 
    ! original vectors.
    !----------------------------------------------------------------------------------
    SUBROUTINE CoupledToSingleVector()
      CALL Info('CoupledSolver','Copying results into original variables',Level=5)
      DO i = 1,NoVar + NoCons
        IF( VarDofs(i) == 0 ) CYCLE
        
        IF( i <= NoVar ) THEN
          WRITE (str,'(A,I2)') 'Variable',i
        ELSE
          WRITE (str,'(A,I2)') 'Constraint',i-NoVar        
        END IF
        VarName = ListGetString( SolverParams, TRIM(str), GotIt )
        Var => VariableGet( Mesh % Variables, TRIM(VarName) )
        
        ! CALL Info('CoupledSolver','Copying to variable: '//TRIM(VarName),Level=5)
        DO j=1,SIZE(Var % Values)
          Var % Values(j) = Solver % Variable % Values(Offset(i)+j)
        END DO

        CALL InvalidateVariable( Model % Meshes, Solver % Mesh, VarName )
      END DO

    END SUBROUTINE CoupledToSingleVector


    !---------------------------------------------------
    SUBROUTINE CoupledSystemAssembly()
      !---------------------------------------------------
      ! Perform normal assembly for the coupled system linear
      ! system of equations.
      !---------------------------------------------------
      CALL Info('CoupledSolver','Starting coupled system assembly',Level=5)

      BulkMode = .TRUE.

100   IF(BulkMode) THEN
        ! CALL Info('CoupledSolver','Starting bulk assembly',Level=5)
        ElementsFirst = 1
        ElementsLast = Mesh % NumberOFBulkElements
      ELSE
        ! CALL Info('CoupledSolver','Starting boundary assembly',Level=5)
        ElementsFirst = Mesh % NumberOFBulkElements+1
        ElementsLast = Mesh % NumberOfBulkElements + &
               Mesh % NumberOFBoundaryElements
      END IF
      
      ! Variables over rows
      !-------------------------------------------
      DO RowVar = 1,NoVar 

        IF( IsCoupledSolver ) THEN
          WRITE (str,'(A,I2)') 'Variable',RowVar
          RowName = ListGetString( SolverParams, TRIM(str), GotIt )
          Var => VariableGet( Mesh % Variables, TRIM(RowName) ) 
        ELSE
          Var => Solver % Variable
        END IF

        RowDofs = Var % Dofs
        RowPerm => Var % Perm
        RowInd0 = Offset(RowVar)
        
        ! Variables over columns
        !------------------------------------------
        DO ColVar = 1,NoVar          
          IF( IsCoupledSolver ) THEN
            WRITE (str,'(A,I2)') 'Variable',ColVar
            ColName = ListGetString( SolverParams, TRIM(str), GotIt )
            Var => VariableGet( Mesh % Variables, TRIM(ColName) )
          ELSE
            Var => Solver % Variable
          END IF

          ColDofs = Var % Dofs
          ColPerm => Var % Perm
          ColInd0 = Offset(ColVar)

          ! These could be user provided for each block
          !-----------------------------------------
          AssemblySymmetric = .FALSE.
          AssemblyAntiSymmetric = .FALSE.

          ! Load the assembly procudure
          !-----------------------------------------
          IF( BulkMode ) THEN
            WRITE (str,'(A,I1,I1)') 'Bulk Assembly Procedure ',RowVar,ColVar
          ELSE
            WRITE (str,'(A,I1,I1)') 'Boundary Assembly Procedure ',RowVar,ColVar
          END IF
          
          ProcName = ListGetString( SolverParams, TRIM(str), GotProc )
          ! Test if the 11 block is not given with 'ij' indexes
          !--------------------------------------------------------
          IF(.NOT. GotProc .AND. RowVar == 1 .AND. ColVar == 1) THEN
            IF( BulkMode ) THEN
              WRITE (str,'(A)') 'Bulk Assembly Procedure'
            ELSE
              WRITE (str,'(A)') 'Boundary Assembly Procedure'
            END IF
            ProcName = ListGetString( SolverParams, TRIM(str), GotProc )
          END IF

          IF( .NOT. GotProc ) THEN
            IF( BulkMode .AND. RowVar == ColVar) THEN
              CALL Warn('CoupledSolver','Diagonal bulk entries should be assembled!')
            END IF
            CYCLE
          END IF
          
          ProcPntr = GetProcAddr( TRIM(ProcName), abort=.FALSE.,quiet=.FALSE.)
          IF ( ProcPntr == 0 ) THEN
            CALL Fatal('CoupledSolver','Assembly routine not found: '//TRIM(ProcName))
          ELSE
            CALL Info('CoupledSolver','Using assembly routine: '//TRIM(ProcName))
          END IF
          
          ! The assembly loop for a submatrix starts here
          !------------------------------------------------------------------------------             
          DO t=ElementsFirst,ElementsLast
            
            Element => Mesh % Elements(t)
            Model % CurrentElement => Element

            !-----------------------------------------------------------------
            n  = GetElementNOFNodes()
            nd = GetElementDOFs(Indexes)

            Nrow = nd
            RowInds(1:Nrow) = RowPerm(Indexes(1:nd))
            IF(.NOT. ALL(RowInds(1:Nrow) > 0)) CYCLE
            
            Ncol = nd
            ColInds(1:Ncol) = ColPerm(Indexes(1:nd))
            IF(.NOT. ALL(ColInds(1:Ncol) > 0)) CYCLE                 

            ! Here just the matrix structure is set, no values
            !---------------------------------------------------------------
            IF( IsListMatrix ) THEN
              CALL GlueLocalSubMatrix( Amat, &
                  RowInd0,ColInd0,Nrow,Ncol,RowInds,ColInds,&
                  RowDofs,ColDofs,STIFF )
              IF( AssemblySymmetric .OR. AssemblyAntiSymmetric ) THEN
                CALL GlueLocalSubMatrix( Amat, &
                    ColInd0,RowInd0,Ncol,Nrow,ColInds,RowInds,&
                    ColDofs,RowDofs,STIFF )          
              END IF
              CYCLE
            END IF


            ! Do the assembly, now really
            !---------------------------------------------------------------
            STIFF = 0.0_dp
            DAMP = 0.0_dp
            MASS = 0.0_dp
            FORCE = 0.0_dp
            
            CALL ExecLocalAssembly( ProcPntr, CurrentModel, Solver, &
                dt, Transient, MASS, DAMP, STIFF, FORCE, Element, &
                Nrow, Ncol )
            
            IF ( Transient ) THEN
              IF( Solver % TimeOrder == 1 ) THEN
                CALL Default1stOrderTime( MASS,STIFF,FORCE)
              ELSE IF( Solver % TimeOrder == 2) THEN
                CALL Default2ndOrderTime( MASS,DAMP,STIFF,FORCE )
              END IF
            END IF

            IF ( Solver % NOFEigenValues>0 ) THEN
              IF( Solver % TimeOrder == 1 ) THEN
                CALL DefaultUpdateMass(MASS)
              ELSE IF( Solver % TimeOrder == 2) THEN
                CALL DefaultUpdateDamp(DAMP)
                CALL DefaultUpdateMass(MASS)
              END IF
            END IF
            
            IF( IsCoupledSolver ) THEN
              ! Assemble the matrix with offset
              !-----------------------------------------------
              
              CALL GlueLocalSubMatrix( Amat, &
                  RowInd0,ColInd0,Nrow,Ncol,RowInds,ColInds,&
                  RowDofs,ColDofs,STIFF )
              
              ! Assemble the r.h.s with offset
              !-----------------------------------------------
              DO i=1,Nrow
                DO j=1,RowDofs
                  Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
                  ForceVector(Row) = ForceVector(Row) + &
                      FORCE(RowDofs*(i-1)+j)
                END DO
              END DO
                      
              ! For some constraints assemble also the transpose
              !--------------------------------------------------
              IF( AssemblySymmetric ) THEN
                CALL GlueLocalSubMatrix( Amat, &
                    ColInd0,RowInd0,Ncol,Nrow,ColInds,RowInds,&
                    ColDofs,RowDofs,TRANSPOSE(STIFF) )               
              ELSE IF( AssemblyAntisymmetric ) THEN
                CALL GlueLocalSubMatrix( Amat, &
                    ColInd0,RowInd0,Ncol,Nrow,ColInds,RowInds,&
                    ColDofs,RowDofs,-TRANSPOSE(STIFF) )               
              END IF
            ELSE              
              CALL DefaultUpdateEquations( STIFF, FORCE )
            END IF

          END DO
        END DO
      END DO
      
      IF(BulkMode) THEN
        ! CALL Info( 'CoupledSolver', 'Bulk assembly done for blocks', Level=4 )
        BulkMode = .FALSE.
        GOTO 100
      ELSE 
        ! CALL Info( 'CoupledSolver', 'Boundary assembly done for blocks', Level=4 )
      END IF
    END SUBROUTINE CoupledSystemAssembly
    !-----------------------------------------------------------------------------------

    

    !-----------------------------------------------------------------------------------
    SUBROUTINE CoupledConstraintAssembly()
      !-----------------------------------------------------------------------------------
      ! Perform constraints assembly
      ! Some constraints are assembled by integration while others are done by elimination.
      ! It is important that constraints are applied after the normal assembly process. 
      !-----------------------------------------------------------------------------------
      INTEGER :: TargetDof, TmpInds(4) 

      CALL Info('CoupledSolver','Starting constraint assembly',Level=5)
      
      BulkMode = .TRUE.
200   IF(BulkMode) THEN
        ! CALL Info('CoupledSolver','Starting constraing bulk assembly',Level=5)
        ElementsFirst = 1
        ElementsLast = Mesh % NumberOfBulkElements 
      ELSE
        ! CALL Info('CoupledSolver','Starting boundary assembly',Level=5)
        ElementsFirst = Mesh % NumberOfBulkElements + 1
        ElementsLast =  Mesh % NumberOfBulkElements + &
              Mesh % NumberOfBoundaryElements
      END IF
      
      ! Variables over rows
      !-------------------------------------------
      DO RowVar = 1,NoCons        

        RowDofs = VarDofs(NoVar + RowVar) 
        RowInd0 = Offset(NoVar + RowVar)

        AssemblySymmetric = .FALSE.
        AssemblyAntiSymmetric = .FALSE.

        WRITE (str,'(A,I2)') 'Constraint',RowVar
        RowName = ListGetString( Solver % Values, TRIM(str), GotIt )

        WRITE (str,'(A,I2,A)') 'Constraint',RowVar,' Variables'
        VarInds => ListGetIntegerArray( Solver % Values, TRIM(str) )

        IF( ASSOCIATED(VarInds)) THEN
          ColVar =  VarInds(1) 
        ELSE        
          CALL Fatal('CoupledSolver','Cannot continue without pointer to variables')
        END IF
        
        WRITE (str,'(A,I2,A)') 'Constraint',RowVar,' Components'
        TargetDof = ListGetInteger( Solver % Values, TRIM(str), GotIt )
      
        WRITE (str,'(A,I2,A)') 'Constraint',RowVar,' Value'
        ConsValue = GetCReal(Solver % Values,TRIM(str), GotIt)

        WRITE (str,'(A,I2,A)') 'Constraint',RowVar,' Coeff'
        ConsCoeff = GetCReal(Solver % Values,TRIM(str), GotIt)
        IF(.NOT. GotIt) ConsCoeff = 1.0_dp


        IF ( ConsType == 'equality' ) THEN
          WRITE (str,'(A,I2)') 'Variable',VarInds(2)
          VarName = ListGetString( SolverParams, TRIM(str) )
          Var => VariableGet( Mesh % Variables, TRIM(VarName) ) 
          RowPerm => Var % Perm
          RowDofs = VarDofs(VarInds(2))
          RowInd0 = Offset(VarInds(2)) 
        ELSE
          Nrow = 1
          RowInds(1:Nrow) = 1         
          Var => VariableGet( Mesh % Variables, TRIM(RowName) )      
          
          ! Add the diagonal entry expected by some subroutines
          !-------------------------------------------------------          
          DO i=1,Nrow
            DO j=1,RowDofs
              Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
              CALL AddToMatrixElement( Amat, Row, Row, 0.0_dp )
            END DO
          END DO
        END IF
         
        IF( ConsType == 'integral') THEN
          AssemblySymmetric = .TRUE.
          ConsVolume = 0.0_dp
        END IF

        WRITE (str,'(A,I2)') 'Variable',ColVar
        ColName = ListGetString( Solver % Values, TRIM(str), GotIt )
        Var => VariableGet( Mesh % Variables, TRIM(ColName) )
          
        ! Constrain only the target variable
        !-----------------------------------------------
        
        ColPerm => Var % Perm
        ColDofs = Var % Dofs
        ColInd0 = Offset(ColVar)
          
        ! The assembly loop for a submatrix starts here
        !------------------------------------------------------------------------------             
        DO t=ElementsFirst,ElementsLast

          Element => Mesh % Elements(t)
          Model % CurrentElement => Element
          
          ! How to treat non-nodal elements must be rethought 
          ! nd = GetElementNOFDOFs( Element, Solver )                  
          !-----------------------------------------------------------------
          n  = GetElementNOFNodes()
          nd = GetElementDOFs(Indexes)
                        
          ! Set the permutations for equality constraint
          !----------------------------------------------------
          IF( ConsType == 'equality') THEN
            Nrow = nd
            RowInds(1:Nrow) = RowPerm(Indexes)
            IF(.NOT. ALL(RowInds(1:Nrow) > 0)) CYCLE
          END IF
            
          Ncol = nd
          ColInds(1:n) = ColPerm(Indexes)
          IF(.NOT. ALL(ColInds(1:Ncol) > 0)) CYCLE                 

            
          ! Check where constraints are active, both bodies and BCs
          !-------------------------------------------------------------------                         
          Coupling = .FALSE.              
          IF( BulkMode ) THEN
            ! Check coupling to bodies using Body/Equation section
            Coupling = GetLogical( GetBodyForce(), RowName, gotIt)
          ELSE 
            Coupling = GetLogical( GetBC(), RowName, gotIt)
          END IF
          IF( .NOT. Coupling ) CYCLE
              
          ! These two constraints are based on moving already assembled information
          ! rather than assembling new information. If the row is already treated cycle.
          ! The constrainst have been tested only with one-component cases.
          !-----------------------------------------------------------------------------
          IF( ConsType == 'floating' .OR. ConsType == 'equality') THEN

            DO i=1,Ncol                
              DO k=0,ColDofs-1
                
                ! Note that for this type the column is rather also a row
                !--------------------------------------------------------
                Col  = ColInd0 + ColDofs * ColInds(i) - k                  
                IF( AllDir(Col) ) CYCLE
                AllDir(Col) = .TRUE.
                
                IF( ConsType == 'floating') THEN
                  Row = RowInd0 + 1
                ELSE IF( ConsType == 'equality') THEN
                  Row = RowInd0 + RowDofs * RowInds(i) - k
                END IF

                IF( IsListMatrix ) THEN
                  CALL MoveRow( Amat, Col, Row )
                  CALL SetMatrixElement( Amat,Col,Col,0.0_dp )
                  CALL SetMatrixElement( Amat,Col,Row,0.0_dp )
                  CYCLE
                END IF

                CALL MoveRow( Amat, Col, Row, ConsCoeff ) 
                ForceVector(Row) = ForceVector(Row) + ForceVector(Col)
                ForceVector(Col) = 0.0_dp
                
                ForceVector(Row) = ForceVector(Row) + ConsValue
                CALL SetMatrixElement( Amat,Col,Col,1.0_dp )
                CALL SetMatrixElement( Amat,Col,Row,-ConsCoeff)
              END DO
            END DO
            CYCLE
          END IF


          ! Do the assembly, now really (active only for some constraints)
          !----------------------------------------------------------------
            
          STIFF = 0.0_dp
          DAMP = 0.0_dp
          MASS = 0.0_dp
          FORCE = 0.0_dp
          
          CALL IntegralConstraint( MASS, DAMP, STIFF, FORCE, Element, Ncol )
          
          IF ( Transient ) THEN
            IF( Solver % TimeOrder == 1 ) THEN
              CALL Default1stOrderTime( MASS,STIFF,FORCE)
            ELSE IF( Solver % TimeOrder == 2) THEN
              CALL Default2ndOrderTime( MASS,DAMP,STIFF,FORCE )
            END IF
          END IF

           
          ! Assemble the matrix with offset
          ! Because we want to have constraints component-wise
          ! There is somewhat dirty hack for calling the gluematrix
          !---------------------------------------------------------
          DO k=1,ColDofs
            IF( TargetDof /= 0 .AND. TargetDof /= k) CYCLE
            TmpInds(1:Ncol) = ColDofs * (ColInds(1:Ncol)-1) + k

            IF( IsListMatrix ) THEN            
              CALL GlueLocalSubMatrix( Amat, &
                  RowInd0,ColInd0,Nrow,Ncol,RowInds,TmpInds,&
                  RowDofs,1,STIFF )
              IF( AssemblySymmetric .OR. AssemblyAntisymmetric ) THEN
                CALL GlueLocalSubMatrix( Amat, &
                    ColInd0,RowInd0,Ncol,Nrow,TmpInds,RowInds,&
                    1,RowDofs,STIFF )               
              END IF
              CYCLE
            END IF

            CALL GlueLocalSubMatrix( Amat, &
                RowInd0,ColInd0,Nrow,Ncol,RowInds,TmpInds,&
                RowDofs,1,STIFF )

            ! For some constraints assemble also the transpose
            !--------------------------------------------------
            IF( AssemblySymmetric ) THEN
              CALL GlueLocalSubMatrix( Amat, &
                  ColInd0,RowInd0,Ncol,Nrow,TmpInds,RowInds,&
                  1,RowDofs,TRANSPOSE(STIFF) )               
            ELSE IF( AssemblyAntisymmetric ) THEN
              CALL GlueLocalSubMatrix( Amat, &
                  ColInd0,RowInd0,Ncol,Nrow,TmpInds,RowInds,&
                  1,RowDofs,-TRANSPOSE(STIFF) )               
            END IF
            
            ! Assemble the r.h.s with offset
            !-----------------------------------------------
            DO i=1,Nrow
              DO j=1,RowDofs
                Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
                ForceVector(Row) = ForceVector(Row) + &
                    FORCE(RowDofs*(i-1)+j)
              END DO
            END DO
          
          END DO          
        END DO
      
        ! For constraints do some special setting
        !---------------------------------------------------
        IF( ConsType == 'integral' ) THEN
          ! PRINT *,'Integral constraint sum of weights: ',ConsVolume
          DO i=1,Nrow
            DO j=1,RowDofs
              Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
              ForceVector(Row) = ConsValue
            END DO
          END DO
        END IF
      END DO
      
      IF(BulkMode) THEN
        ! CALL Info( 'CoupledSolver', 'Bulk assembly done for constraints', Level=4 )
        BulkMode = .FALSE.
        GOTO 200
      ELSE 
        ! CALL Info( 'CoupledSolver', 'Boundary assembly done for constraints', Level=4 )
      END IF

    END SUBROUTINE CoupledConstraintAssembly

!------------------------------------------------------------------------------
END SUBROUTINE CoupledSolver
!------------------------------------------------------------------------------
 



!------------------------------------------------------------------------------
  SUBROUTINE SingleSolver( Model, Solver, dt, TransientSimulation )
!------------------------------------------------------------------------------
     TYPE(Model_t)  :: Model
     TYPE(Solver_t),POINTER :: Solver
     LOGICAL :: TransientSimulation
     REAL(KIND=dp) :: dt
!------------------------------------------------------------------------------
     LOGICAL :: stat, Found, GB, MeActive
     INTEGER :: i, j, n, SolverAddr, BDOFs, maxdim
     TYPE(Element_t), POINTER :: CurrentElement
     CHARACTER(LEN=MAX_NAME_LEN) :: EquationName, str

     INTEGER, ALLOCATABLE :: memb(:)
     TYPE(Matrix_t), POINTER :: M
     INTEGER :: comm_active, group_active, group_world, ierr

!------------------------------------------------------------------------------
     IF ( Solver % Mesh % Changed .OR. Solver % NumberOfActiveElements <= 0 ) THEN
       Solver % NumberOFActiveElements = 0
       EquationName = ListGetString( Solver % Values, 'Equation', Found)

       IF ( Found ) THEN
          IF (  ASSOCIATED(Solver % ActiveElements)) DEALLOCATE( Solver % ActiveElements )
          ALLOCATE( Solver % ActiveElements( Solver % Mesh % NumberOfBulkElements + &
                       Solver % Mesh % NumberOFBoundaryElements ) )

          Maxdim = 0
          DO i=1,Solver % Mesh % NumberOfBulkElements+Solver % Mesh % NumberOFBoundaryElements
             CurrentElement => Solver % Mesh % Elements(i)
             IF ( CheckElementEquation( Model, CurrentElement, EquationName ) ) THEN
                Solver % NumberOfActiveElements = Solver % NumberOFActiveElements + 1
                Solver % ActiveElements( Solver % NumberOFActiveElements ) = i
                Maxdim = MAX( CurrentElement % TYPE % DIMENSION, Maxdim )
             END IF
          END DO
          CALL ListAddInteger( Solver % Values, 'Active Mesh Dimension', Maxdim )
          IF (ASSOCIATED(Solver % Variable)) CALL CalculateNodalWeights(Solver)
       END IF
     END IF
!------------------------------------------------------------------------------

     MeActive = ASSOCIATED(Solver % Matrix)
     IF ( MeActive ) &
        MeActive = MeActive .AND. (Solver % Matrix % NumberOfRows > 0)
     CALL ParallelActive( MeActive )

     IF ( ParEnv % PEs>1 ) THEN
       DO i=1,ParEnv % PEs
         IF ( ParEnv % Active(i) ) THEN
           EXIT
         END IF
       END DO

       OutputPE = -1
       IF ( i-1==ParEnv % MyPE .OR. i>ParEnv % PEs .AND. ParEnv % myPE==0 ) &
         OutputPE=0

       n = COUNT(ParEnv % Active)
       IF ( n>0 .AND. n<ParEnv % PEs ) THEN
         IF ( ASSOCIATED(Solver % Matrix) ) THEN
           IF ( Solver % Matrix % Comm /= MPI_COMM_WORLD ) &
              CALL MPI_Comm_Free( Solver % Matrix % Comm, ierr )
         END IF

         CALL MPI_Comm_group( MPI_COMM_WORLD, group_world, ierr )
         ALLOCATE(memb(n))
         n = 0
         DO i=1,ParEnv % PEs
           IF ( ParEnv % Active(i) ) THEN
             n=n+1
             memb(n)=i-1
           END IF
         END DO
         CALL MPI_Group_incl( group_world, n, memb, group_active, ierr)
         DEALLOCATE(memb)
         CALL MPI_Comm_create( MPI_COMM_WORLD, group_active, &
                 comm_active, ierr)

         M => Solver % Matrix
         DO WHILE(ASSOCIATED(M))
           M % Comm = comm_active
           M => M % Parent
         END DO
       ELSE
         M => Solver % Matrix
         DO WHILE( ASSOCIATED(M) )
           M % Comm = MPI_COMM_WORLD
           M => M % Parent
         END DO
       END IF
     END IF
     IF ( ASSOCIATED(Solver % Matrix) ) THEN
       ParEnv % ActiveComm = Solver % Matrix % Comm
       IF ( ParEnv % PEs>1 .AND. MeActive ) THEN
         IF ( ASSOCIATED(Solver % Mesh % ParallelInfo % Interface) ) THEN
           IF (.NOT. ASSOCIATED(Solver % Matrix % ParMatrix) ) &
             CALL ParallelInitMatrix(Solver, Solver % Matrix )

           Solver % Matrix % ParMatrix % ParEnv % ActiveComm = &
                    Solver % Matrix % Comm
           ParEnv = Solver % Matrix % ParMatrix % ParEnv
         END IF
       END IF
     END IF
     str = ListGetString( Solver  % Values,'Procedure', Found )

#ifdef SGIn32
     SolverAddr = Solver % PROCEDURE
     CALL ExecSolver( SolverAddr, Model, Solver, dt, TransientSimulation)
#else
     CALL ExecSolver( Solver % PROCEDURE, &
         Model, Solver, dt, TransientSimulation)
#endif

!------------------------------------------------------------------------------
   END SUBROUTINE SingleSolver
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE SolverActivate( Model, Solver, dt, TransientSimulation )
!------------------------------------------------------------------------------
     TYPE(Model_t)  :: Model
     TYPE(Solver_t),POINTER :: Solver
     LOGICAL :: TransientSimulation, UpdateExported
     REAL(KIND=dp) :: dt, OrigDT, DTScal
!------------------------------------------------------------------------------
     LOGICAL :: stat, Found, IsCoupledSolver, IsAssemblySolver,TimeDerivativeActive
     INTEGER :: i, j, n, BDOFs, execi, timestep
     REAL(KIND=dp) :: st, tcond
     TYPE(Variable_t), POINTER :: TimeVar, IterV
     CHARACTER(LEN=MAX_NAME_LEN) :: str

     SAVE TimeVar
!------------------------------------------------------------------------------
     IsCoupledSolver = ListGetLogical( Solver % Values, 'Coupled Solver', Found )
     IsAssemblySolver = ListGetLogical( Solver % Values, 'Assembly Solver', Found )
     IsAssemblySolver = IsAssemblySolver .OR. IsCoupledSolver

     CALL SetCurrentMesh( Model, Solver % Mesh )
     Model % Solver => Solver

     st = ListGetConstReal( Solver % Values, 'Start Time', Found )
     IF ( Found ) THEN
       TimeVar => VariableGet( Model % Variables, 'Time' )
       IF ( TimeVar % Values(1) < st ) RETURN
     END IF

     execi = ListGetInteger( Solver % Values, 'Exec Interval', Found )
     IF ( Found ) THEN
       TimeVar => VariableGet( Model % Variables, 'Timestep' )
       execi = MOD( NINT(Timevar % Values(1))-1, execi )
       IF ( execi /= 0 ) RETURN
     END IF

!------------------------------------------------------------------------------
     Solver % Mesh % OutputActive = .TRUE.
     TimeDerivativeActive = TransientSimulation

     ! This is to avoid resetting of certain info that could be interesting
     ! when saving data.
     IF(.NOT. ListGetLogical( Solver % Values,'Auxiliary Solver',Found)) THEN
       DTScal = ListGetConstReal( Solver % Values, "Timestep Scale", Found )
       IF ( .NOT. Found ) DTScal = 1.0_dp
       Solver % dt = DtScal * dt 

       IF ( TransientSimulation ) THEN
         TimeDerivativeActive = &
           ListGetLogical( Solver % Values, 'Time Derivative Active', Found )

         IF ( .NOT. Found ) THEN
           TimeDerivativeActive = .TRUE.
           tcond = ListGetCReal(Solver % Values,'Time Derivative Condition',Found)
           IF ( Found ) TimeDerivativeActive = TimeDerivativeActive .AND. tcond>0
         END IF
       END IF

       iterV => VariableGet( Solver % Mesh % Variables, 'nonlin iter' )
       iterV % Values(1) = 1

       str = ListGetString( Solver % Values, 'Namespace', Found )
       IF (Found) CALL ListSetNamespace(TRIM(str))
     END IF

     IF( IsAssemblySolver ) THEN
       CALL CoupledSolver( Model, Solver, DTScal * dt, TimeDerivativeActive )
     ELSE 
       CALL SingleSolver( Model, Solver, DTScal * dt, TimeDerivativeActive )
     END IF
   
     CALL ListSetNamespace('')
     Solver % dt = dt

!------------------------------------------------------------------------------
   END SUBROUTINE SolverActivate
!------------------------------------------------------------------------------

END MODULE MainUtils
