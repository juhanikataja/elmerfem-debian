!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Solve for the 1D characteristics equation arising from newtonian flow in an 
! *  elastic tube. The subroutine may be used as the outlet for blood flow simulation.
! *
! ******************************************************************************
! *
! *  Authors: Esko Järvinen, Mikko Lyly, Peter Råback
! *  Email:   Esko.Jarvinen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 20 Nov 2001
! *
! *****************************************************************************/
 
!------------------------------------------------------------------------------
!>  Solve for the 1D characteristics equation arising from newtonian flow in an 
!>  elastic tube. The subroutine may be used as the outlet for blood flow simulation.
!> \ingroup Solvers
!------------------------------------------------------------------------------
SUBROUTINE OutletCompute( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
  USE Types
  USE Lists 
  USE Integration
  USE ElementDescription
  USE SolverUtils
  USE MeshUtils
  USE DefUtils
  USE MaterialModels
  USE ElementUtils
  USE ModelDescription

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Model_t) :: Model
  TYPE(Solver_t):: Solver
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
 
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------
 
  TYPE(Matrix_t),POINTER  :: StiffMatrix
  TYPE(Nodes_t)   :: ElementNodes
  TYPE(Element_t),POINTER :: CurrentElement, Element
  TYPE(ValueList_t), POINTER :: Material
  TYPE(Variable_t), POINTER :: LVar, FlowSol
  
  INTEGER :: t, k,n,m,ie,bf_id,mat_id,prev_mat_id,istat,LocalNodes,i,j, nonliniter, l, &
      bc, joinnode, Connections, SolidConnections, fsstep, fsstepmax, NonlinearIter
  
  INTEGER, POINTER :: NodeIndexes(:), WPerm(:)
  INTEGER, ALLOCATABLE :: LumpedBoundaries(:), SolidEndBoundaries(:)
  
  REAL(KIND=dp) :: Norm, PrevNorm, FlowOut2d
  
  LOGICAL :: GotIt, GotIt2, AllocationsDone = .FALSE. , FirstTime = .TRUE.
  LOGICAL :: CenterPointsComputed = .FALSE.

  CHARACTER(LEN=MAX_NAME_LEN) :: Method, Name
  
  REAL(KIND=dp), POINTER :: Wnodal(:), ForceVector(:), Lnodal(:), Anodal(:), &
      Pnodal(:), Qnodal(:), FlowSolution(:)
  
  REAL(KIND=dp), ALLOCATABLE :: LocalStiffMatrix(:,:),LocalMassMatrix(:,:), &
      Lelem(:), LocalForce(:), Cnodal(:), Unodal(:), Wprev(:), Lprev(:), &
      Aprev(:), FluidicForces(:), FluidicAreas(:), FluidicFluxes(:), SolidEndAreas(:)
  
  REAL(KIND=dp) :: NonlinearTol, Density, PoissonRatio,&
      WallYoungs, ArteryRadius, ArteryWallThickness, BetaCoeff, Aref, W20, &
      WdiffSum, WnodalSum, WprevnodalSum, Werror, fsAlpha, fsTheta, fsdTheta, fsBeta, &
      pres2dout, area2dout, psi, RadiusIn1d, AreaIn1d, BetaCoeff2, &
      dR, Wbcnode, A2, Q2  
  
  SAVE LocalStiffMatrix,LocalMassMatrix,&
      Lelem, LocalForce,ElementNodes, AllocationsDone, &
      Cnodal, Unodal, Wprev, Lprev, Aprev,&
      Lnodal, Anodal, Qnodal, Pnodal, Wnodal, &
      FluidicForces, FluidicAreas, FluidicFluxes, & 
      LumpedBoundaries, SolidEndBoundaries, SolidEndAreas, &
      CenterPointsComputed

!------------------------------------------------------------------------------
!    Get variables needed for solution
!------------------------------------------------------------------------------

  CALL Info('OutletCompute','Starting')

  Wnodal => Solver % Variable % Values
  LocalNodes = SIZE( Wnodal )
  IF(LocalNodes == 0) THEN
    CALL Warn('OutletCompute','No active variables')
    RETURN
  END IF
  WPerm => Solver % Variable % Perm
  StiffMatrix => Solver % Matrix
  IF(.NOT. ASSOCIATED(StiffMatrix)) THEN
    CALL Warn('OutletCompute','StiffMatrix does not exist')
    RETURN
  END IF
  ForceVector => StiffMatrix % RHS
  Norm = Solver % Variable % Norm

!------------------------------------------------------------------------------
!    Allocate some permanent storage, this is done first time only
!------------------------------------------------------------------------------
  IF ( .NOT. AllocationsDone ) THEN
    N = Model % MaxElementNodes
    M = Model % NumberOfBCs
    
    ALLOCATE( ElementNodes % x( N ),   &
        ElementNodes % y( N ),   &
        ElementNodes % z( N ),   &
        LocalForce( N ),         &
        LocalStiffMatrix( N,N ), &
        LocalMassMatrix( N,N ),  &
        Lelem( N ),              &
        LumpedBoundaries( M ),   &
        SolidEndBoundaries( M ),   &
        FluidicAreas( M ),       &
        SolidEndAreas( M ),       &
        FluidicForces( M ),      &
        FluidicFluxes( M ),      &
        STAT=istat )
    
    IF ( istat /= 0 ) THEN
      CALL Fatal('ArteryOnedim','Memory allocation error')
    END IF
    
    LVar => VariableGet( Solver % Mesh % Variables, 'Lnodal' )
    IF ( ASSOCIATED( LVar ) ) THEN
      Lnodal => LVar % Values
    ELSE
      ALLOCATE( Lnodal(LocalNodes))
    END IF
    
    LVar => VariableGet( Solver % Mesh % Variables, 'Anodal' )
    IF ( ASSOCIATED( LVar ) ) THEN
      Anodal => LVar % Values
    ELSE
      ALLOCATE( Anodal(LocalNodes))
    END IF
    
    LVar => VariableGet( Solver % Mesh % Variables, 'Pnodal' )
    IF ( ASSOCIATED( LVar ) ) THEN
      Pnodal => LVar % Values
    ELSE
      ALLOCATE( Pnodal(LocalNodes))
    END IF
    
    LVar => VariableGet( Solver % Mesh % Variables, 'Qnodal' )
    IF ( ASSOCIATED( LVar ) ) THEN
      Qnodal => LVar % Values
    ELSE
      ALLOCATE( Qnodal(LocalNodes))
    END IF
    
    ALLOCATE( Cnodal( LocalNodes ), & 
        Unodal( LocalNodes ), & 
        Wprev( LocalNodes ),  &
        Lprev( LocalNodes ),  &
        Aprev( LocalNOdes ) )
    
    Cnodal = 0
    Unodal = 0
    Wprev = 0
    Lprev = 0
    Aprev = 0
    
    AllocationsDone = .TRUE.
  END IF
  
  !---------------------------------------------------------------------------------------
  ! Compute the lumped values for area, flux and pressure on the corresponding boundaries
  !---------------------------------------------------------------------------------------
  
  ! Check which boundaries should be lumped and mark them with the corresponding 1D dof
  LumpedBoundaries = .0

  DO bc=1,Model % NumberOfBCs       

   ! Coupling with what Boundary Condition nro (j)   
    j = ListGetInteger( Model % BCs(bc) % Values, 'Fluid Coupling With Boundary', GotIt)
    IF(.NOT. GotIt) CYCLE
    
    DO t = Model % NumberOfBulkElements + 1, &
        Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
      
      Element => Model % Elements(t)
      
   ! In which Boundary Condition coupling is given 
      IF ( Element % BoundaryInfo % Constraint /= Model % BCs(bc) % Tag ) CYCLE
      
   ! Boundary Element should be 1 node boundary
      Model % CurrentElement => Element
      n = Element % TYPE % NumberOfNodes
      IF(n /= 1) CYCLE 
      
   ! Element % NodeIndexes(1) is boundary elements node number, k is the node nro of
   ! the 1D model
      k = WPerm(Element % NodeIndexes(1))
      LumpedBoundaries(j) = k

      EXIT
    END DO
  END DO
  
   ! LumpedBoundaries is a vector a_j, a_j = k (1d node nro), if a_i /= 0,
   ! and j is boundary which is coupled with the lumped boundary
 
  CALL LumpedFluidicForce( LumpedBoundaries, FluidicForces, FluidicAreas,FluidicFluxes)
  
  Connections = 0
  DO bc=1,Model % NumberOfBCs  

    IF(LumpedBoundaries(bc) /= 0) THEN
      Connections = Connections + 1
      joinnode = LumpedBoundaries(bc)
      
      WRITE(Message,'(A,I3)') 'Lumping Boundary:',bc
      CALL Info('OutletCompute',Message)
      WRITE(Message,'(A,E10.4)') 'Force: ',FluidicForces(bc)
      CALL Info('OutletCompute',Message)
      WRITE(Message,'(A,E10.4)') 'Area: ',FluidicAreas(bc)
      CALL Info('OutletCompute',Message)
      WRITE(Message,'(A,E10.4)') 'Flux: ',FluidicFluxes(bc)
      CALL Info('OutletCompute',Message)

    END IF
  END DO

!---------------------------------------------------------------------------------------
! Compute the center point coordinates of the solid boundaries
!---------------------------------------------------------------------------------------

  IF ( CurrentCoordinateSystem() == Cartesian ) THEN

  IF ( .NOT. CenterPointsComputed ) THEN
  
  ! Check which boundaries are coupled with a 1D model

  SolidEndBoundaries = .0
  DO bc=1,Model % NumberOfBCs       
    
    j = ListGetInteger( Model % BCs(bc) % Values, 'Structure Coupling With Boundary', GotIt)

    IF(.NOT. GotIt) CYCLE
    
    DO t = Model % NumberOfBulkElements + 1, &
        Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
      
      Element => Model % Elements(t)
      
      IF ( Element % BoundaryInfo % Constraint /= Model % BCs(bc) % Tag ) CYCLE
      
      Model % CurrentElement => Element
      n = Element % TYPE % NumberOfNodes

      IF(n /= 1) CYCLE 
      
      k = WPerm(Element % NodeIndexes(1))
      SolidEndBoundaries(j) = k

      EXIT
    END DO
  END DO

  ! Number of connections of solid boundaries

  SolidConnections = 0
  DO bc=1,Model % NumberOfBCs  

    IF(SolidEndBoundaries(bc) /= 0) THEN
      SolidConnections = SolidConnections + 1
    END IF
  END DO

  CALL SurfaceCenterPoints( SolidEndBoundaries, SolidConnections, SolidEndAreas)
  
  DO bc=1,Model % NumberOfBCs  

    IF(SolidEndBoundaries(bc) /= 0) THEN
      
      WRITE(Message,'(A,I3)') 'Solid End Area Boundary: ',bc
      CALL Info('OutletCompute',Message)
      WRITE(Message,'(A,E10.4)') 'Solid End Area: ',SolidEndAreas(bc)
      CALL Info('OutletCompute',Message)

    END IF
  END DO

CenterPointsComputed = .TRUE.

END IF

ELSE

  IF ( .NOT. CenterPointsComputed ) THEN

    WRITE(Message,'(A)') ' Coordinate System is not Cartesian.'
    CALL Info('OutletCompute',Message)
    WRITE(Message,'(A)') ' No center points of the outlets are computed.'
    CALL Info('OutletCompute',Message)

    CenterPointsComputed = .TRUE.

  END IF

END IF

  !------------------------------------------------------------------------------
  !    Do some additional initialization
  !------------------------------------------------------------------------------
  CALL InitializeToZero( StiffMatrix, ForceVector )
  
  NonlinearTol = ListGetConstReal( Solver % Values, &
      'Nonlinear System Convergence Tolerance',minv=0.0d0 )
  
  NonlinearIter = ListGetInteger( Solver % Values, &
      'Nonlinear System Max Iterations', minv=0 )
  
  Method = ListGetString( Solver % Values, 'Timestepping Method', GotIt )     
  prev_mat_id = -1
  
  !------------------------------------------------------------------------------
  ! Fractional step (optional) initialization 
  !------------------------------------------------------------------------------
  
  IF ( Method == 'fs') THEN 
    fsTheta = ListGetConstReal( CurrentModel % Simulation,'FS Theta', GotIt )
    
    IF(.NOT. GotIt) fsTheta = 1.0 - SQRT(2.0)/2.0
    fsdTheta = 1.0 - 2.0 * fsTheta
    fsAlpha  = fsdTheta / ( 1.0 - fsTheta )
    fsBeta   = 1.0 - fsAlpha        
    fsstepmax = 3
    
    CALL ListAddConstReal( Solver % Values, 'fsTheta', fsTheta )
    CALL ListAddConstReal( Solver % Values, 'fsdTheta', fsdTheta )
    CALL ListAddConstReal( Solver % Values, 'fsAlpha', fsAlpha )
    CALL ListAddConstReal( Solver % Values, 'fsBeta', fsBeta )
  ELSE
    fsstepmax = 1
  END IF
  
  !------------------------------------------------------------------------------
  ! Fractional step loop
  !------------------------------------------------------------------------------
  
  DO fsstep = 1,fsstepmax
    
    IF ( Method == 'fs') THEN 
      CALL InitializeTimeStep(Solver)
      Solver % Variable % PrevValues(:,1) = Solver % Variable % Values 
      CALL ListAddConstReal( Solver % Values, 'fsstep', 1.0d0*fsstep )
      
      WRITE(Message,'(A,I3)') 'Fractional Step:',fsstep
      CALL Info('OutletCompute',Message)
    END IF
    
    !------------------------------------------------------------------------------
    ! Nonlinear iteration
    !------------------------------------------------------------------------------

    prev_mat_id = -1

    DO nonliniter = 1,NonlinearIter
      
      CALL InitializeToZero( StiffMatrix, ForceVector )
      
      WRITE(Message,'(A,I3)') 'Nonlinear iteration: ',nonliniter
      CALL Info('OutletCompute',Message)
      
      !------------------------------------------------------------------------------
      !    Do the assembly
      !------------------------------------------------------------------------------
      
      DO ie = 1, Solver % NumberOfActiveElements 
        
        CurrentElement => Solver % Mesh % Elements( Solver % ActiveElements(ie) )
        n = CurrentElement % TYPE % NumberOfNodes
        
        NodeIndexes => CurrentElement % NodeIndexes
        ElementNodes % x(1:n) = Solver % Mesh % Nodes % x(NodeIndexes)
        ElementNodes % y(1:n) = Solver % Mesh % Nodes % y(NodeIndexes)
        ElementNodes % z(1:n) = Solver % Mesh % Nodes % z(NodeIndexes)
        
        mat_id = ListGetInteger( Model % Bodies( CurrentElement % BodyId ) % Values, 'Material')    
        
        IF(mat_id /= prev_mat_id) THEN
          Material => Model % Materials(mat_id) % Values
          
          Density = ListGetConstReal( Material, 'Density')
          WallYoungs = ListGetConstReal( Material, 'Artery Wall Youngs Modulus')
          ArteryRadius = ListGetConstReal( Material, 'Artery Radius')
          ArteryWallThickness = ListGetConstReal( Material, 'Artery Wall Thickness')
          PoissonRatio = ListGetConstReal( Material, 'Artery Poisson Ratio')
          
          Aref = Pi * ArteryRadius**2
          BetaCoeff = ( 1 / (1 - PoissonRatio**2) ) * &
                    ( SQRT(pi) * ArteryWallThickness  * WallYoungs ) / ( Aref)
          W20 = -4 * SQRT( (BetaCoeff/(2.0*Density) ) * SQRT(Aref) ) 

          prev_mat_id = mat_id

        END IF
        
        IF( FirstTime ) THEN
          Anodal( Wperm(NodeIndexes) ) = Aref
          Unodal( Wperm(NodeIndexes) ) = 0.0 
          Cnodal( Wperm(NodeIndexes) ) = SQRT( (BetaCoeff/(2.0*Density))  * SQRT(Aref) )
          Lnodal( Wperm(NodeIndexes) ) = SQRT( (BetaCoeff/(2.0*Density))  * SQRT(Aref) )
          Pnodal( Wperm(NodeIndexes) ) = 0.0
        END IF
        
        Lelem(1:n) = Lnodal( Wperm(NodeIndexes) )
        
        !------------------------------------------------------------------------------
        !      Get element local matrix, and rhs vector
        !------------------------------------------------------------------------------
        CALL LocalMatrix(  LocalStiffMatrix, LocalMassMatrix, &
            LocalForce, Lelem, CurrentElement, n, ElementNodes)
        
        IF( TransientSimulation ) THEN
          CALL Add1stOrderTime( LocalMassMatrix, LocalStiffMatrix, &
              LocalForce, dt, N, 1, WPerm(NodeIndexes), Solver )
        END IF
        
        !------------------------------------------------------------------------------
        !      Update global matrix and rhs vector from local matrix & vector
        !------------------------------------------------------------------------------
        CALL UpdateGlobalEquations( StiffMatrix, LocalStiffMatrix, &
            ForceVector, LocalForce, n, 1, WPerm(NodeIndexes) )
        
        !------------------------------------------------------------------------------
        
      END DO !Assembly
      
      !------------------------------------------------------------------------------
      !    FinishAssembly must be called after all other assembly steps, but before
      !    Dirichlet boundary settings. Actually no need to call it except for
      !    transient simulations.
      !------------------------------------------------------------------------------
      CALL FinishAssembly( Solver,ForceVector )
      
      FirstTime = .FALSE.
      
      !------------------------------------------------------------------------------
      !    Built-in Dirichlet boundary conditions
      !------------------------------------------------------------------------------
      
      DO bc=1,Model % NumberOfBCs
        
        k = LumpedBoundaries(bc)
        IF(k == 0) CYCLE
        
        psi = FluidicForces(bc) / FluidicAreas(bc)
        A2 = FluidicAreas(bc)
        Q2 = FluidicFluxes(bc)
        
        Wbcnode = (Q2/A2) + 2 * SQRT(2.0/Density) * ( SQRT(psi + BetaCoeff * SQRT(Aref)) )
        
        IF ( StiffMatrix % Format == MATRIX_SBAND ) THEN
          CALL SBand_SetDirichlet( StiffMatrix, ForceVector, k, Wbcnode )
        ELSE IF ( StiffMatrix % Format == MATRIX_CRS .AND. StiffMatrix % Symmetric ) THEN
          CALL CRS_SetSymmDirichlet( StiffMatrix, ForceVector, k, Wbcnode )
        ELSE
          ForceVector(k) = Wbcnode
          CALL ZeroRow( StiffMatrix, k )
          CALL SetMatrixElement( StiffMatrix, k, k, 1.0d0 )
        END IF
        
      END DO
      
      !------------------------------------------------------------------------------
      !    Solve the system and we are done.
      !------------------------------------------------------------------------------
      Wprev = Wnodal
      Lprev = Lnodal
      Aprev = Anodal
      
      CALL SolveSystem( StiffMatrix, ParMatrix, ForceVector, &
          Wnodal, Norm, 1, Solver )
      
      !------------------------------------------------------------------------------
      !  Update the dofs dependent on Wnodal
      !------------------------------------------------------------------------------
      Anodal = ( (Density/BetaCoeff)**2 ) * (Wnodal - W20)**4 / (4**5)
      Unodal = ( Wnodal + W20 ) / 2.0
      Qnodal = Anodal * Unodal
      Cnodal = SQRT( BetaCoeff/(2.0*Density) ) * Anodal**0.25
      Lnodal = Unodal + Cnodal
      Pnodal = BetaCoeff * ( SQRT(Anodal) - SQRT(Aref) )
      
      !------------------------------------------------------------------------------
      !  Check the nonlinear convergence
      !------------------------------------------------------------------------------
      WdiffSum = SUM( ABS(Lnodal - Lprev) )
      WnodalSum = SUM( ABS(Lnodal) )
      WprevnodalSum = SUM( ABS(Lprev) )
      
      IF( WnodalSum + WprevnodalSum > TINY(WnodalSum)) THEN
        Werror = 2 * WdiffSum / (WnodalSum + WprevnodalSum)
      ELSE
        Werror = 0.0d0
      END IF
      
      WRITE(Message,'(A,E10.4)') 'Relative Change: ',Werror
      CALL Info('OutletCompute',Message)
      
      IF ( Werror < NonlinearTol ) EXIT
      
    END DO ! Nonlinear iterations
    !------------------------------------------------------------------------------
    
  END DO ! Fractional-Step
  !------------------------------------------------------------------------------
  
  !------------------------------------------------------------------------------
  !  Save the new pressure and change in radius to be used in the outlet
  !  boundary (2D or 3D) of the Navier-Stokes equation.
  !------------------------------------------------------------------------------
  
  DO bc=1,Model % NumberOfBCs

    IF(LumpedBoundaries(bc) /= 0) THEN
      joinnode = LumpedBoundaries(bc)

      pres2dout = Pnodal(joinnode)
      AreaIn1d = Anodal(joinnode)
      RadiusIn1d = SQRT( AreaIn1d / PI )         
      dR = RadiusIn1d - ArteryRadius
      
      IF(Connections == 1) THEN
        Name = 'res: pout'
      ELSE IF(bc < 10) THEN
        WRITE(Name,'(A,I1)') 'res: pout',bc
      ELSE
        WRITE(Name,'(A,I2)') 'res: pout',bc
      END IF

      CALL ListAddConstReal( Model % Simulation, Name, pres2dout )
      
      IF(Connections == 1) THEN
        Name = 'res: dRout'
      ELSE IF(bc < 10) THEN
        WRITE(Name,'(A,I1)') 'res: dRout',bc
      ELSE
        WRITE(Name,'(A,I2)') 'res: dRout',bc
      END IF

      CALL ListAddConstReal( Model % Simulation, Name, dR )                 

    END IF
  END DO
  
CONTAINS
  
!------------------------------------------------------------------------------
  SUBROUTINE LocalMatrix( StiffMatrix,MassMatrix,&
      Force, Lelem, Element, n, Nodes )
    !------------------------------------------------------------------------------
    REAL(KIND=dp) :: StiffMatrix(:,:), MassMatrix(:,:), &
        Force(:), Lelem(:)
    INTEGER :: n
    TYPE(Nodes_t) :: Nodes
    TYPE(Element_t), POINTER :: Element
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: Basis(n),dBasisdx(n,3),ddBasisddx(n,3,3)
    REAL(KIND=dp) :: SqrtElementMetric,U,V,W,S,Lambda
    LOGICAL :: Stat
    INTEGER :: i,p,q,t,DIM

    TYPE(GaussIntegrationPoints_t) :: IntegStuff
 
!------------------------------------------------------------------------------
    DIM = CoordinateSystemDimension()
    Force = 0.0d0
    StiffMatrix = 0.0d0
    MassMatrix = 0.0d0

!------------------------------------------------------------------------------
!      Numerical integration
!------------------------------------------------------------------------------
    IntegStuff = GaussPoints( Element, n+1 )
    
    DO t=1, IntegStuff % n   ! = integ.pisteiden lkm.
      
      U = IntegStuff % u(t)
      V = IntegStuff % v(t)
      W = IntegStuff % w(t)
      S = IntegStuff % s(t)
!------------------------------------------------------------------------------
!        Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
      stat = ElementInfo( Element,Nodes,U,V,W, SqrtElementMetric, &
          Basis, dBasisdx, ddBasisddx, .FALSE. )
      
      S = S * SqrtElementMetric
      Lambda = SUM( Lelem(1:n) * Basis(1:n) )

!------------------------------------------------------------------------------
!        The Poisson equation
!------------------------------------------------------------------------------
      DO p = 1,N
        Force(p) = Force(p) + L * Basis(p) * S
      END DO
      
      DO p = 1,N
        DO q = 1,N
          MassMatrix(p,q) = MassMatrix(p,q) + Basis(p) * Basis(q)*s
        END DO
      END DO
      
      DO p = 1,N
        DO q = 1,N
          DO i=1,DIM
            StiffMatrix(p,q) = StiffMatrix(p,q) + Lambda * Basis(p) &
                * dBasisdx(q,i) * S
          END DO
        END DO
      END DO
      
!------------------------------------------------------------------------------
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE LocalMatrix


!------------------------------------------------------------------------------
  SUBROUTINE SurfaceCenterPoints( SolidEndBoundaries, SolidConnections, SolidEndAreas)
!------------------------------------------------------------------------------

    IMPLICIT NONE
    
    INTEGER :: SolidEndBoundaries(:)
    REAL(KIND=dp) :: SolidEndAreas(:)
    
    TYPE(Solver_t), POINTER :: FlowSolver
    LOGICAL :: Stat, LocalAllocationDone = .FALSE. 
    INTEGER :: i,j,k,n,pn,t,dim, SolidConnections
    INTEGER, POINTER :: NodeIndexes(:)
    TYPE(Variable_t), POINTER :: Var
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Nodes_t) :: ElementNodes, ParentNodes
    TYPE(Element_t), POINTER   :: Element, Parent
    CHARACTER(LEN=MAX_NAME_LEN) :: VariableName, XName, YName, ZName

    REAL(KIND=dp), ALLOCATABLE :: Basis(:), dBasisdx(:,:), ddBasisddx(:,:,:), &
        ParentBasis(:), ParentdBasisdx(:,:), x(:), y(:), z(:)
    REAL(KIND=dp) :: u, v, w, s, detJ, xpos, ypos, zpos, SumOfWeights, &
        XPosWeighted, YPosWeighted, ZPosWeighted
    REAL(KIND=dp) :: Normal(3)
    
    TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff
    
    SAVE LocalAllocationDone, ElementNodes, Basis, dBasisdx, x, y, z
    
    CALL Info( 'SurfaceCenterPoints', '-------------------------------------',Level=4 )
    CALL Info( 'SurfaceCenterPoints', 'Computing Centerpoints:  ', Level=4 )
    CALL Info( 'SurfaceCenterPoints', '-------------------------------------',Level=4 )
    
    Mesh => Solver % Mesh

    IF(.NOT. LocalAllocationDone) THEN
      n = Mesh % MaxElementNodes
      
      ALLOCATE( ElementNodes % x(n), &
          ElementNodes % y(n),  &
          ElementNodes % z(n), &
          Basis(n), dBasisdx(n,3), &
          x(n), y(n), z(n) ) 
      LocalAllocationDone = .TRUE.         
    END IF
   
    
    DIM = CoordinateSystemDimension()
    
    DO k=1, Model % NumberOfBCs
      IF( SolidEndBoundaries(k) == 0 ) CYCLE

      SolidEndAreas = 0.0d0
      
      DO t = Mesh % NumberOfBulkElements + 1, &
          Mesh % NumberOfBulkElements + &
          Mesh % NumberOfBoundaryElements
        
        Element => Mesh % Elements(t)
        IF ( Element % TYPE % ElementCode == 101 ) CYCLE
        IF ( Model % BCs(k) % Tag /= Element % BoundaryInfo % Constraint ) CYCLE

    
        Model % CurrentElement => Mesh % Elements(t)
        n = Element % TYPE % NumberOfNodes
        NodeIndexes => Element % NodeIndexes
        
        ElementNodes % x(1:n) = Mesh % Nodes % x(NodeIndexes)
        ElementNodes % y(1:n) = Mesh % Nodes % y(NodeIndexes)
        ElementNodes % z(1:n) = Mesh % Nodes % z(NodeIndexes)
        
        IntegStuff = GaussPoints( Element )
        
!------------------------------------------------------------------------------
        DO l=1,IntegStuff % n
!------------------------------------------------------------------------------

          u = IntegStuff % u(l)
          v = IntegStuff % v(l)
          w = IntegStuff % w(l)
          s = IntegStuff % s(l) 

!------------------------------------------------------------------------------
!      Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
          stat = ElementInfo( Element, ElementNodes, u, v, w, &
              detJ, Basis, dBasisdx)

!------------------------------------------------------------------------------
!      Coordinatesystem dependent info
!------------------------------------------------------------------------------
          s = s * detJ
    
          IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
            xpos = SUM( ElementNodes % x(1:n) * Basis(1:n) )
            s = s * 2.0 * PI * xpos
          END IF
          
!------------------------------------------------------------------------------

          xpos = SUM( ElementNodes % x(1:n) * Basis(1:n) )
          ypos = SUM( ElementNodes % y(1:n) * Basis(1:n) )
          zpos = SUM( ElementNodes % z(1:n) * Basis(1:n) )

          XPosWeighted = XPosWeighted + xpos
          YPosWeighted = YPosWeighted + ypos
          ZPosWeighted = ZPosWeighted + zpos

          SumOfWeights = SumOfWeights + s
          SolidEndAreas = SolidEndAreas + s

!------------------------------------------------------------------------------
        END DO ! Integ
        
      END DO ! Boundary elements

!------------------------------------------------------------------------------

! Writing the center points of each solid end boundary to Model % Simulation

      IF(SolidConnections == 1) THEN
        XName = 'res: xcenterpoint'
        YName = 'res: ycenterpoint'
        ZName = 'res: zcenterpoint'
      ELSE IF(bc < 10) THEN
        WRITE(XName,'(A,I1)') 'res: xcenterpoint',k
        WRITE(YName,'(A,I1)') 'res: ycenterpoint',k
        WRITE(ZName,'(A,I1)') 'res: zcenterpoint',k
      ELSE
        WRITE(XName,'(A,I2)') 'res: xcenterpoint',k
        WRITE(YName,'(A,I2)') 'res: ycenterpoint',k
        WRITE(ZName,'(A,I2)') 'res: zcenterpoint',k
      END IF

      CALL ListAddConstReal( Model % Simulation, XName, XPosWeighted )
      CALL ListAddConstReal( Model % Simulation, YName, YPosWeighted )
      CALL ListAddConstReal( Model % Simulation, ZName, ZPosWeighted )
      
      WRITE(Message,'(A)') ' Coordinate System is Cartesian.'
      CALL Info('SurfaceCenterPoints',Message)
      WRITE(Message,'(A,I2)') 'Boundary number ',k 
      CALL Info('SurfaceCenterPoints',Message)
      WRITE(Message,'(A,E10.4)') 'Centerpoint x-coordinate is ',XPosWeighted  
      CALL Info('SurfaceCenterPoints',Message)
      WRITE(Message,'(A,E10.4)') 'Centerpoint y-coordinate is ',YPosWeighted  
      CALL Info('SurfaceCenterPoints',Message)

!------------------------------------------------------------------------------
      
    END DO ! BCs

  END SUBROUTINE SurfaceCenterPoints
  

!---------------------------------------------------------------------------------------------
  SUBROUTINE LumpedFluidicForce( LumpedBoundaries, FluidicForces, FluidicAreas, FluidicFluxes )
!---------------------------------------------------------------------------------------------
    IMPLICIT NONE
    
    INTEGER :: LumpedBoundaries(:)
    REAL(KIND=dp) :: FluidicForces(:), FluidicAreas(:), FluidicFluxes(:)
    
    REAL(KIND=dp), ALLOCATABLE :: Pressure(:), Velocity(:,:), Viscosity(:)
    TYPE(Solver_t), POINTER :: FlowSolver
    LOGICAL :: Stat, ViscousForce, Compressible, LocalAllocationDone = .FALSE. 
    INTEGER :: i,j,k,n,pn,t,dim
    INTEGER, POINTER :: NodeIndexes(:)
    TYPE(Variable_t), POINTER :: Var
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(ValueList_t), POINTER :: Material
    TYPE(Nodes_t) :: ElementNodes, ParentNodes
    TYPE(Element_t), POINTER   :: Element, Parent
    CHARACTER(LEN=MAX_NAME_LEN) :: VariableName
    
    REAL(KIND=dp) :: Force(3), SumNormal(3), Area, LForce(3), Flux, NormalVelo
    
    REAL(KIND=dp), ALLOCATABLE :: Basis(:), dBasisdx(:,:), &
        ParentBasis(:), ParentdBasisdx(:,:), x(:), y(:), z(:)
    REAL(KIND=dp) :: u, v, w, s, detJ, xpos
    REAL(KIND=dp) :: Grad(3,3), Stress(3,3), Normal(3), Div, Visc
    
    TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff
    
    SAVE LocalAllocationDone, ElementNodes, ParentNodes, Basis, dBasisdx, &
     ParentBasis, ParentdBasisdx, x, y, z, Pressure, Viscosity, Velocity
    
    CALL Info( 'LumpedForceCompute', '-------------------------------------',Level=4 )
    CALL Info( 'LumpedForceCompute', 'Computing Lumped Boundary:  ', Level=4 )
    CALL Info( 'LumpedForceCompute', '-------------------------------------',Level=4 )
    
    DO i=1,Model % NumberOfSolvers
      FlowSolver => Model % Solvers(i)
      IF ( ListGetString( FlowSolver % Values, 'Equation' ) == 'navier-stokes' ) EXIT
    END DO
    
    Mesh => Model % Meshes
    DO WHILE( ASSOCIATED(Mesh) )
      IF ( Mesh % OutputActive ) EXIT 
      Mesh => Mesh % Next
    END DO
    CALL SetCurrentMesh( Model, Mesh )
    
    VariableName = GetString( Solver % Values, 'Velocity Field Name', stat )
    IF ( .NOT. stat )  THEN
      Var => VariableGet( Mesh % Variables, 'Flow Solution', .TRUE. )
    ELSE
      Var => VariableGet( Mesh % Variables, VariableName, .TRUE. )
    END IF
    
    IF(.NOT. LocalAllocationDone) THEN
      PRINT *,'Allocating'

      n = Mesh % MaxElementNodes
      
      ALLOCATE( ElementNodes % x(n), &
          ElementNodes % y(n),  &
          ElementNodes % z(n), &
          ParentNodes % x(n), &
          ParentNodes % y(n),  &
          ParentNodes % z(n), &
          Basis(n), dBasisdx(n,3), &
          ParentBasis(n), ParentdBasisdx(n,3), &
          x(n), y(n), z(n), &
          Pressure( n ), &
          Viscosity( n ), &
          Velocity( 3, n ) )
      LocalAllocationDone = .TRUE.         
    END IF
    
    
    DIM = CoordinateSystemDimension()
    
    ViscousForce = ListGetLogical( Solver % Values, 'Consider Viscous Force',stat )
    IF ( .NOT. stat )  ViscousForce = .FALSE.    
    Compressible = ListGetLogical( Solver % Values, 'Consider Compressibility',stat )
        
    DO k=1, Model % NumberOfBCs
      IF( LumpedBoundaries(k) == 0 ) CYCLE
      
      Force = 0.0d0
      SumNormal = 0.0d0
      Area = 0.0d0
      Flux = 0.0d0
      
      DO t = Mesh % NumberOfBulkElements + 1, &
          Mesh % NumberOfBulkElements + &
          Mesh % NumberOfBoundaryElements
        
        Element => Mesh % Elements(t)
        IF ( Element % TYPE % ElementCode == 101 ) CYCLE
        IF ( Model % BCs(k) % Tag /= Element % BoundaryInfo % Constraint ) CYCLE
        
        Model % CurrentElement => Mesh % Elements(t)
        n = Element % TYPE % NumberOfNodes
        NodeIndexes => Element % NodeIndexes
        
        ElementNodes % x(1:n) = Mesh % Nodes % x(NodeIndexes)
        ElementNodes % y(1:n) = Mesh % Nodes % y(NodeIndexes)
        ElementNodes % z(1:n) = Mesh % Nodes % z(NodeIndexes)
        
        Parent => Element % BoundaryInfo % Left
        
        stat = ASSOCIATED( Parent )
        IF ( stat ) stat = stat .AND. ALL(Var % Perm(Parent % NodeIndexes(1:n)) > 0)
        
        IF ( .NOT. stat ) THEN
          Parent => ELement % BoundaryInfo % Right
          
          stat = ASSOCIATED( Parent )
          IF ( stat ) stat = ALL(Var % Perm(Parent % NodeIndexes(1:n)) > 0)
          
          IF ( .NOT. stat )  THEN
            CALL Warn( 'LumpedForceCompute', &
                'No flow solution available for specified boundary' )
            CYCLE
          END IF
        END IF
        
        pn = Parent % TYPE % NumberOfNodes           
        ParentNodes % x(1:pn) = Mesh % Nodes % x(Parent % NodeIndexes)
        ParentNodes % y(1:pn) = Mesh % Nodes % y(Parent % NodeIndexes)
        ParentNodes % z(1:pn) = Mesh % Nodes % z(Parent % NodeIndexes)
        
        j = ListGetInteger( Model % Bodies(Parent % BodyId) % Values, 'Material', &
            minv=1, maxv=Model % NumberOFMaterials )
        Material => Model % Materials(j) % Values
        
        Viscosity(1:pn) = ListGetReal( Material, 'Viscosity', pn, Parent % NodeIndexes )
        
        Velocity = 0.0d0
        DO i=1,pn
          DO j=1,DIM
            Velocity(j,i) = &
                Var % Values(Var % DOFs * (Var % Perm(Parent % NodeIndexes(i))-1)+j)
          END DO
        END DO
        Pressure(1:pn) = Var % Values(Var % DOFs * Var % Perm(Parent % NodeIndexes))
        
        IntegStuff = GaussPoints( Element )
        
!------------------------------------------------------------------------------
        DO l=1,IntegStuff % n
!------------------------------------------------------------------------------

          u = IntegStuff % u(l)
          v = IntegStuff % v(l)
          w = IntegStuff % w(l)
          s = IntegStuff % s(l) 

!------------------------------------------------------------------------------
!      Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------

          stat = ElementInfo( Element, ElementNodes, u, v, w, detJ, Basis, dBasisdx)

!------------------------------------------------------------------------------
!      Coordinatesystem dependent info
!------------------------------------------------------------------------------
          s = s * detJ
          
          IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
            xpos = SUM( ElementNodes % x(1:n) * Basis(1:n) )
            s = s * 2.0 * PI * xpos
          END IF
          
          Normal = Normalvector( Element, ElementNodes, u, v, .TRUE. )
        
          !------------------------------------------------------------------------------
          ! Need parent element basis etc., for computing normal derivatives on boundary.
          !------------------------------------------------------------------------------
          
          DO i = 1,n
            DO j = 1,pn
              IF ( Element % NodeIndexes(i) == Parent % NodeIndexes(j) ) THEN
                x(i) = Parent % TYPE % NodeU(j)
                y(i) = Parent % TYPE % NodeV(j)
                z(i) = Parent % TYPE % NodeW(j)
                EXIT
              END IF
            END DO
          END DO
          
          u = SUM( Basis(1:n) * x(1:n) )
          v = SUM( Basis(1:n) * y(1:n) )
          w = SUM( Basis(1:n) * z(1:n) )
          
          stat = ElementInfo( Parent, ParentNodes, u, v, w, detJ, ParentBasis, ParentdBasisdx )
      
    
!------------------------------------------------------------------------------

          Stress = 0.0d0
          Div = 0.0d0
          
          NormalVelo = 0.0d0
          DO j = 1,DIM
            NormalVelo = NormalVelo + Normal(j) * SUM( ParentBasis(1:pn) * Velocity(j,1:pn) )
          END DO
          
          IF ( ViscousForce ) THEN           
            Grad = MATMUL( Velocity(:,1:pn),ParentdBasisdx )
            Visc = SUM( Viscosity(1:pn) * ParentBasis(1:pn) )
            
            IF ( Compressible ) THEN             
              IF ( CurrentCoordinateSystem() == Cartesian ) THEN
                DO i = 1, DIM
                  Div = Div + Grad(i,i)
                END DO
              ELSE
                Div = SUM( Velocity(1,1:pn) * ParentdBasisdx(1:pn,1) ) + &
                    SUM( Velocity(1,1:pn) * ParentBasis(1:pn) ) / xpos + &
                    SUM( Velocity(2,1:pn) * ParentdBasisdx(1:pn,2) )
              END IF
            END IF
            
            Stress = Visc * ( Grad + TRANSPOSE(Grad) )           
          END IF
          
          DO i=1,DIM
            Stress(i,i) = Stress(i,i) - SUM( Pressure(1:pn) * ParentBasis ) &
                -(2.0d0/3.0d0) * Visc * Div
          END DO
          
          LForce = -MATMUL( Stress, Normal )
          
          Force  = Force  + s * LForce
          Flux = Flux + s * NormalVelo
          SumNormal = SumNormal + s * Normal
          
          Area = Area + s
 
!------------------------------------------------------------------------------
        END DO

      END DO
      
      FluidicAreas(k) = SQRT(SUM(SumNormal * SumNormal))
      FluidicForces(k) = SUM(Force*SumNormal)/FluidicAreas(k)       
      FluidicFluxes(k) = Flux
      
    END DO
    
  END SUBROUTINE LumpedFluidicForce
  

!------------------------------------------------------------------------------
END SUBROUTINE OutletCompute
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!>   Compute the initial guess for the characteristics variable
!> \ingroup UDF
!------------------------------------------------------------------------------
FUNCTION OutletInit( Model,n,t ) RESULT( Winit )
  
  USE Types
  USE Lists
  
  IMPLICIT NONE
  
  TYPE(Model_t) :: Model
  INTEGER :: n,mat_id
  REAL( kind=dp ) :: t, Winit  
  TYPE(ValueList_t), POINTER :: Material
  REAL( kind=dp ) :: Aref, BetaCoeff, W20, rho, Ew, r, hw, nu
  
  mat_id = ListGetInteger( Model % Bodies(  &
      Model % CurrentElement % BodyId ) % Values, 'Material' )
  Material => Model % Materials(mat_id) % Values
  
  rho = ListGetConstReal( Material, 'Density')
  Ew = ListGetConstReal( Material, 'Artery Wall Youngs Modulus')
  R = ListGetConstReal( Material, 'Artery Radius')
  hw = ListGetConstReal( Material, 'Artery Wall Thickness')
  nu = ListGetConstReal( Material, 'Artery Poisson Ratio')
  
  Aref = pi * R**2
  BetaCoeff = ( 1 / (1 - nu**2) ) * ( SQRT(pi) * hw  * Ew ) / ( Aref)

  Winit = 4 * ( SQRT( (BetaCoeff/(2.0*rho)) * SQRT(Aref)) )
  
END FUNCTION OutletInit


!------------------------------------------------------------------------------
!>   Return the change in the radius x-component computed by the 1D model
!> \ingroup UDF
!------------------------------------------------------------------------------
FUNCTION OutletdX( Model,n,t ) RESULT(dx)
  
  USE Types
  USE Lists
  USE MeshUtils
  
  IMPLICIT NONE
  TYPE(Model_t) :: Model  
  INTEGER :: n, bc, bc2
  REAL( kind=dp ) :: t, dRout, xcenterpoint, ycenterpoint, zcenterpoint, &
           x, y, z, x0, y0, dx, dy
  LOGICAL :: GotIt,GotIt1,GotIt2,GotIt3
  CHARACTER(LEN=MAX_NAME_LEN) :: VarName, VarName1, VarName2, VarName3

!------------------------------------------------------------------------------
  ! Getting the center points and displacement dR from Model % Simulation 

  xcenterpoint = ListGetConstReal( Model % Simulation, 'res: xcenterpoint', GotIt1)
  ycenterpoint = ListGetConstReal( Model % Simulation, 'res: ycenterpoint', GotIt2)
  zcenterpoint = ListGetConstReal( Model % Simulation, 'res: zcenterpoint', GotIt3)

  IF(.NOT. (GotIt1 .AND. GotIt2 .AND. GotIt3) ) THEN    
    bc = Model % CurrentElement % BoundaryInfo % Constraint
    bc2 = ListGetInteger( Model % BCs(bc) % Values,'Structure Coupling With Boundary', GotIt)
    IF(GotIt) bc = bc2
    IF(bc < 10) THEN
      WRITE(VarName1,'(A,I1)') 'res: xcenterpoint',bc
      WRITE(VarName2,'(A,I1)') 'res: ycenterpoint',bc
      WRITE(VarName3,'(A,I1)') 'res: zcenterpoint',bc
    ELSE
      WRITE(VarName1,'(A,I2)') 'res: xcenterpoint',bc
      WRITE(VarName2,'(A,I2)') 'res: ycenterpoint',bc
      WRITE(VarName3,'(A,I2)') 'res: zcenterpoint',bc
    END IF
    xcenterpoint= ListGetConstReal( Model % Simulation, VarName1, GotIt)  
    ycenterpoint= ListGetConstReal( Model % Simulation, VarName2, GotIt)  
    zcenterpoint= ListGetConstReal( Model % Simulation, VarName3, GotIt)  
  END IF

  dRout = ListGetConstReal( Model % Simulation, 'res: dRout', GotIt)

  IF(.NOT. GotIt) THEN    
    bc = Model % CurrentElement % BoundaryInfo % Constraint
    bc2 = ListGetInteger( Model % BCs(bc) % Values,'Structure Coupling With Boundary', GotIt)
    IF(GotIt) bc = bc2
    IF(bc < 10) THEN
      WRITE(VarName,'(A,I1)') 'res: dRout',bc
    ELSE
      WRITE(VarName,'(A,I2)') 'res: dRout',bc
    END IF
    dRout = ListGetConstReal( Model % Simulation, VarName, GotIt)  
  END IF

!------------------------------------------------------------------------------


 x = Model % Nodes % x(n) 
 y = Model % Nodes % y(n) 
 z = Model % Nodes % z(n) 

 x0 = x - xcenterpoint
 y0 = y - ycenterpoint

dx = SQRT( 1./(1 + (y0/x0)**2) )* dRout
dy = SQRT( 1./(1 + (x0/y0)**2) )* dRout

IF( x0 <= 0 ) THEN
  dx = -dx
END IF

IF( y0 <= 0 ) THEN
  dy = -dy
END IF

!----!----!----!----!----!----!----!----!----!----!----!
IF ( CurrentCoordinateSystem() /= Cartesian ) dx = dRout
!----!----!----!----!----!----!----!----!----!----!----!
END FUNCTION OutletdX

!------------------------------------------------------------------------------
!>   Return the change in the radius y-component computed by the 1D model
!> \ingroup UDF
!------------------------------------------------------------------------------
FUNCTION OutletdY( Model,n,t ) RESULT(dy)
  
  USE Types
  USE Lists
  USE MeshUtils
  
  IMPLICIT NONE
  TYPE(Model_t) :: Model  
  INTEGER :: n, bc, bc2
  REAL( kind=dp ) :: t, dRout, xcenterpoint, ycenterpoint, zcenterpoint, &
           x, y, z, x0, y0, dx, dy
  LOGICAL :: GotIt,GotIt1,GotIt2,GotIt3
  CHARACTER(LEN=MAX_NAME_LEN) :: VarName, VarName1, VarName2, VarName3

!------------------------------------------------------------------------------
  ! Getting the center points and displacement dR from Model % Simulation 

  xcenterpoint = ListGetConstReal( Model % Simulation, 'res: xcenterpoint', GotIt1)
  ycenterpoint = ListGetConstReal( Model % Simulation, 'res: ycenterpoint', GotIt2)
  zcenterpoint = ListGetConstReal( Model % Simulation, 'res: zcenterpoint', GotIt3)

  IF(.NOT. (GotIt1 .AND. GotIt2 .AND. GotIt3) ) THEN    
    bc = Model % CurrentElement % BoundaryInfo % Constraint
    bc2 = ListGetInteger( Model % BCs(bc) % Values,'Structure Coupling With Boundary', GotIt)
    IF(GotIt) bc = bc2
    IF(bc < 10) THEN
      WRITE(VarName1,'(A,I1)') 'res: xcenterpoint',bc
      WRITE(VarName2,'(A,I1)') 'res: ycenterpoint',bc
      WRITE(VarName3,'(A,I1)') 'res: zcenterpoint',bc
    ELSE
      WRITE(VarName1,'(A,I2)') 'res: xcenterpoint',bc
      WRITE(VarName2,'(A,I2)') 'res: ycenterpoint',bc
      WRITE(VarName3,'(A,I2)') 'res: zcenterpoint',bc
    END IF
    xcenterpoint= ListGetConstReal( Model % Simulation, VarName1, GotIt)  
    ycenterpoint= ListGetConstReal( Model % Simulation, VarName2, GotIt)  
    zcenterpoint= ListGetConstReal( Model % Simulation, VarName3, GotIt)  
  END IF

  dRout = ListGetConstReal( Model % Simulation, 'res: dRout', GotIt)  

  IF(.NOT. GotIt) THEN    
    bc = Model % CurrentElement % BoundaryInfo % Constraint
    bc2 = ListGetInteger( Model % BCs(bc) % Values,'Structure Coupling With Boundary', GotIt)
    IF(GotIt) bc = bc2
    IF(bc < 10) THEN
      WRITE(VarName,'(A,I1)') 'res: dRout',bc
    ELSE
      WRITE(VarName,'(A,I2)') 'res: dRout',bc
    END IF
    dRout = ListGetConstReal( Model % Simulation, VarName, GotIt)  
  END IF

!------------------------------------------------------------------------------

 x = Model % Nodes % x(n) 
 y = Model % Nodes % y(n) 
 z = Model % Nodes % z(n) 

 x0 = x - xcenterpoint
 y0 = y - ycenterpoint

dx = SQRT( 1./(1 + (y0/x0)**2) )* dRout
dy = SQRT( 1./(1 + (x0/y0)**2) )* dRout

IF( x0 <= 0 ) THEN
  dx = -dx
END IF

IF( y0 <= 0 ) THEN
  dy = -dy
END IF

!----!----!----!----!----!----!----!----!----!----!----!
IF ( CurrentCoordinateSystem() /= Cartesian ) dy = dRout
!----!----!----!----!----!----!----!----!----!----!----!

END FUNCTION OutletdY



!------------------------------------------------------------------------------
!>   Return the pressure computed by the characteristics model.
!> \ingroup UDF
!------------------------------------------------------------------------------
FUNCTION OutletPres( Model,n,t ) RESULT(pout)
  
  USE Types
  USE Lists
  
  IMPLICIT NONE
  TYPE(Model_t) :: Model
  INTEGER :: n, bc
  REAL( kind=dp ) :: t, pout
  LOGICAL :: GotIt
  CHARACTER(LEN=MAX_NAME_LEN) :: VarName

  pout = ListGetConstReal( Model % Simulation, 'res: pout', GotIt)  
  IF(.NOT. GotIt) THEN
    bc = Model % CurrentElement % BoundaryInfo % Constraint
    IF(bc < 10) THEN
      WRITE(VarName,'(A,I1)') 'res: pout',bc
    ELSE
      WRITE(VarName,'(A,I2)') 'res: pout',bc
    END IF
    pout = ListGetConstReal( Model % Simulation, VarName, GotIt)  
  END IF

  pout = -pout

END FUNCTION OutletPres

!------------------------------------------------------------------------------
