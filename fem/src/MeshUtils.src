!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Mesh manipulation utilities for *Solver - routines
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen, Peter Råback
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 02 Apr 2001
! *
! *****************************************************************************/

MODULE MeshUtils

    USE ElementUtils
    USE ElementDescription
    USE Interpolation
    USE ParallelUtils
    USE Types

    IMPLICIT NONE

CONTAINS

!------------------------------------------------------------------------------
   FUNCTION AllocateElement() RESULT( Element )
!------------------------------------------------------------------------------
     TYPE(Element_t), POINTER :: Element
!------------------------------------------------------------------------------
    INTEGER :: istat
!------------------------------------------------------------------------------

     ALLOCATE( Element, STAT=istat )
     IF ( istat /= 0 ) &
        CALL Fatal( 'AllocateElement', 'Unable to allocate a few bytes of memory?' )
     Element % BDOFs    =  0
     Element % NDOFs    =  0
     Element % BodyId   = -1
     Element % Splitted =  0
     Element % hK = 0
     Element % ElementIndex = 0
     Element % StabilizationMk = 0
     NULLIFY( Element % TYPE )
     NULLIFY( Element % PDefs )
     NULLIFY( Element % BubbleIndexes )
     NULLIFY( Element % DGIndexes )
     NULLIFY( Element % NodeIndexes )
     NULLIFY( Element % EdgeIndexes )
     NULLIFY( Element % FaceIndexes )
     NULLIFY( Element % BoundaryInfo )
!------------------------------------------------------------------------------
   END FUNCTION AllocateElement
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
   SUBROUTINE AllocatePDefinitions(Element)
!------------------------------------------------------------------------------
     IMPLICIT NONE
     INTEGER :: istat

     TYPE(Element_t) :: Element

     ALLOCATE(Element % PDefs, STAT=istat)
     IF ( istat /= 0) CALL Fatal('AllocatePDefinitions','Unable to allocate memory')

     ! Initialize fields
     Element % PDefs % P = 0 
     Element % PDefs % TetraType = 0
     Element % PDefs % isEdge = .FALSE.
     Element % PDefs % pyramidQuadEdge = .FALSE.
     Element % PDefs % localNumber = 0
     Element % PDefs % GaussPoints = 0

!------------------------------------------------------------------------------
   END SUBROUTINE AllocatePDefinitions
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   FUNCTION AllocateMesh() RESULT(Mesh)
!------------------------------------------------------------------------------
     TYPE(Mesh_t), POINTER :: Mesh
!------------------------------------------------------------------------------
     INTEGER :: istat

     ALLOCATE( Mesh, STAT=istat )
     IF ( istat /= 0 ) &
        CALL Fatal( 'AllocateMesh', 'Unable to allocate a few bytes of memory?' )

!    Nothing computed on this mesh yet!
!    ----------------------------------
     Mesh % SavesDone    = 0
     Mesh % OutputActive = .FALSE.

     Mesh % AdaptiveDepth = 0
     Mesh % Changed   = .FALSE. !  TODO: Change this sometime

     Mesh % Stabilize = .FALSE.

     Mesh % Variables => Null()
     Mesh % Parent => Null()
     Mesh % Child => Null()
     Mesh % Next => Null()
     Mesh % RootQuadrant => Null()
     Mesh % Elements => Null()
     Mesh % Edges => Null()
     Mesh % Faces => Null()
     Mesh % Projector => Null()
     Mesh % NumberOfEdges = 0
     Mesh % NumberOfFaces = 0
     Mesh % NumberOfNodes = 0
     Mesh % NumberOfBulkElements = 0
     Mesh % NumberOfBoundaryElements = 0

     Mesh % MaxFaceDOFs = 0
     Mesh % MaxEdgeDOFs = 0
     Mesh % MaxBDOFs = 0
     Mesh % MaxElementDOFs  = 0
     Mesh % MaxElementNodes = 0

     Mesh % ViewFactors => Null()

     ALLOCATE( Mesh % Nodes, STAT=istat )
     IF ( istat /= 0 ) &
        CALL Fatal( 'AllocateMesh', 'Unable to allocate a few bytes of memory?' )
     NULLIFY( Mesh % Nodes % x )
     NULLIFY( Mesh % Nodes % y )
     NULLIFY( Mesh % Nodes % z )
     Mesh % Nodes % NumberOfNodes = 0

     Mesh % ParallelInfo % NumberOfIfDOFs =  0
     NULLIFY( Mesh % ParallelInfo % GlobalDOFs )
     NULLIFY( Mesh % ParallelInfo % INTERFACE )
     NULLIFY( Mesh % ParallelInfo % NeighbourList )
!------------------------------------------------------------------------------
   END FUNCTION AllocateMesh
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
   SUBROUTINE GetMaxDefs(Model, Mesh, Element, ElementDef, SolverId, BodyId, Def_Dofs)
!------------------------------------------------------------------------------
     CHARACTER(*) :: ElementDef
     TYPE(Model_t) :: Model
     TYPE(MEsh_t) :: Mesh
     TYPE(Element_t) :: Element
     INTEGER :: SolverId, BodyId, Def_Dofs(:)

     TYPE(ValueList_t), POINTER :: Params
     INTEGER :: i, j,k,l, n, slen
     INTEGER, POINTER :: Body_Dofs(:)
     LOGICAL  :: stat
     REAL(KIND=dp) :: x,y,z
     TYPE(Solver_t), POINTER  :: Solver
     CHARACTER(MAX_NAME_LEN) :: str, result

     Solver => Model % Solvers(SolverId)
     Params => Solver % Values

     IF ( .NOT. ALLOCATED(Solver % Def_Dofs) ) THEN
       ALLOCATE(Solver % Def_Dofs(Model % NumberOfBodies,6))
       Solver % Def_Dofs=-1
       Solver % Def_Dofs(:,1)=1
     END IF
     Body_Dofs => Solver % Def_Dofs(BodyId,:)


     j = INDEX( ElementDef, 'n:' )
     IF ( j>0 ) THEN
       READ( ElementDef(j+2:), * ) l
       Body_Dofs(1) = l
       Def_Dofs(1) = MAX(Def_Dofs(1), l)
     END IF
          
      j = INDEX( ElementDef, 'e:' )
      IF ( j>0 ) THEN
        READ( ElementDef(j+2:), * ) l
        Body_Dofs(2) = l
        Def_Dofs(2) = MAX(Def_Dofs(2), l )
      END IF
          
      j = INDEX( ElementDef, 'f:' )
      IF ( j>0 ) THEN
        READ( ElementDef(j+2:), * ) l
        Body_Dofs(3) = l
        Def_Dofs(3) = MAX(Def_Dofs(3), l )
      END IF
          
      j = INDEX( ElementDef, 'd:' )
      IF ( j>0 ) THEN
        READ( ElementDef(j+2:), * ) l
        Body_Dofs(4) = l
        Def_Dofs(4) = MAX(Def_Dofs(4), l )
      ELSE 
        IF ( ListGetLogical( Solver % Values, &
            'Discontinuous Galerkin', stat ) ) THEN
          Body_Dofs(4) = 0
          Def_Dofs(4) = MAX(Def_Dofs(4),0 )
        END IF
      END IF
          
      j = INDEX( ElementDef, 'b:' )
      IF ( j>0 ) THEN
        READ( ElementDef(j+2:), * ) l
        Body_Dofs(5) = l
        Def_Dofs(5) = MAX(Def_Dofs(5), l )
      END IF
          
      j = INDEX( ElementDef, 'p:' )
      IF ( j>0 ) THEN
        IF ( ElementDef(j+2:j+2) == '%' ) THEN
          n = Element % Type % NumberOfNodes
          x = SUM(Mesh % Nodes % x(Element % NodeIndexes))/n
          y = SUM(Mesh % Nodes % y(Element % NodeIndexes))/n
          z = SUM(Mesh % Nodes % z(Element % NodeIndexes))/n
          WRITE( str, * ) 'cx= ',TRIM(i2s(Element % ElementIndex)),x,y,z
          str = TRIM(str) // '; ' // TRIM(ElementDef(j+3:))//'(cx)'
          slen = LEN_TRIM(str)
          CALL matc(str,result,slen)
          READ(result,*) x
          Body_Dofs(6) = 0
          Def_Dofs(6)  = MAX(Def_Dofs(6),NINT(x))
        ELSE
          READ( ElementDef(j+2:), * ) l
          Body_Dofs(6) = l
          Def_Dofs(6) = MAX(Def_Dofs(6), l )
        END IF
      END IF

!------------------------------------------------------------------------------
END SUBROUTINE GetMaxDefs
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
! Function to load mesh from disk
!------------------------------------------------------------------------------
  FUNCTION LoadMesh( Model, MeshDirPar, MeshNamePar,&
    BoundariesOnly, NumProcs,MyPE, Def_Dofs ) RESULT( Mesh )
!------------------------------------------------------------------------------
    USE PElementMaps, ONLY : GetRefPElementNodes

    IMPLICIT NONE

    CHARACTER(LEN=*) :: MeshDirPar,MeshNamePar
    LOGICAL :: BoundariesOnly

    INTEGER, OPTIONAL :: numprocs,mype,Def_Dofs(:)

    TYPE(Mesh_t),  POINTER :: Mesh
    TYPE(Model_t) :: Model
!------------------------------------------------------------------------------

    INTEGER :: eio_info
 
    REAL(KIND=dp), POINTER :: cCoord(:), coord(:,:), Wrk(:,:)
    REAL(KIND=dp) :: CoordScale(3)

    INTEGER :: i,j,k,l,m,code,tag,body,TYPE,nodes(MAX_ELEMENT_NODES), &
             left,right,fields,npart,parts(1024)

    INTEGER :: bodies,body_forces,body_equations,materials, &
      boundary_conditions,initial_conditions, mesh_parameters,bndry, &
       name,n,linsys,procs,CountByType(64),Types(64),TypeCount,partn,id

    LOGICAL :: GotIt, NeedEdges, FoundDG, Found

    INTEGER :: MinIndex,MaxIndex,MinEIndex,MaxEIndex, &
        BDOFs, EDOFs,FDOFs,inDOFs(7), DGIndex, istat, mesh_dim, save_dim
    INTEGER, POINTER :: NodeTags(:),CoordMap(:),BList(:)
    INTEGER, POINTER :: LocalPerm(:),LocalEPerm(:), &
           ElementTags(:), EdgeDOFs(:), FaceDOFs(:)


    LOGICAL, POINTER :: iface(:)
    TYPE(ValueList_t), POINTER :: Vlist

    CHARACTER(MAX_NAME_LEN) :: ElementDef0, ElementDef
    TYPE(Nodes_t) :: ElementNodes
    TYPE(Element_t), POINTER :: Element, Edge, Face, Parent

    TYPE(Matrix_t), POINTER :: Projector

    REAL(KIND=dp) :: pCoord(3)

    TYPE(NeighbourList_t), POINTER :: nlist(:)

    LOGICAL :: parallel
    CHARACTER(LEN=MAX_NAME_LEN) :: MeshDir, MeshName, str
!------------------------------------------------------------------------------
!   call spariterbarrier
    Mesh => AllocateMesh()
    parallel = .FALSE.

    MeshDir(1:LEN_TRIM(MeshDirPar)+1)   = TRIM(MeshDirPar)  // CHAR(0)
    MeshName(1:LEN_TRIM(MeshNamePar)+1) = TRIM(MeshNamePar) // CHAR(0)
!------------------------------------------------------------------------------
    IF ( PRESENT(numprocs) .AND. PRESENT(mype) ) THEN
      IF ( numprocs > 1 ) THEN
        CALL eio_init( eio_info )
#ifdef  EIO_GET_TOTAL
#define EIO_GET_TOTAL
           CALL eio_open_mesh( MeshName,eio_info )
           IF ( eio_info /= 0 ) THEN
              WRITE( Message, * ) 'Unable to load mesh: ', TRIM( MeshNamePar )
              CALL Fatal( 'LoadMesh', Message )
           END IF

           CALL eio_get_mesh_description( Mesh % Nodes % TotalNodes,i,j, &
                    Typecount,Types,CountByType,eio_info )

           CALL eio_close_mesh( eio_info )
!          CALL eio_close_model( eio_info )
        CALL eio_close( eio_info )
#endif
        parallel = .TRUE.
        CALL eio_init_parallel( numprocs,mype+1,eio_info )
      ELSE
        CALL eio_init( eio_info )
      END IF
    ELSE
      CALL eio_init( eio_info )
    END IF

!------------------------------------------------------------------------------
!   Mesh
!------------------------------------------------------------------------------
    CALL eio_open_mesh( MeshName,eio_info )
    IF ( eio_info /= 0 ) THEN
       WRITE( Message, * ) 'Unable to load mesh: ', TRIM(MeshNamePar)
       CALL Fatal( 'LoadMesh', Message )
    END IF

    CALL eio_get_mesh_description( Mesh % NumberOfNodes, &
      Mesh % NumberOfBulkElements,Mesh % NumberOfBoundaryElements, &
             Typecount,Types,CountByType,eio_info )
    IF ( eio_info /= 0 ) THEN
       WRITE( Message, * ) 'Unable to read mesh header from mesh: ', TRIM(MeshNamePar)
       CALL Fatal( 'LoadMesh', Message )
    END IF

    Mesh % Nodes % NumberOfNodes = Mesh % NumberOfNodes

    IF ( BoundariesOnly ) Mesh % NumberOfBulkElements = 0

    Mesh % MaxElementNodes = 0
    Mesh % MaxElementDOFs  = 0
    Mesh % MaxEdgeDOFs     = 0
    Mesh % MaxFaceDOFs     = 0
    Mesh % MaxBDOFs        = 0
    DO i=1,TypeCount
      Mesh % MaxElementNodes = MAX( &
                 Mesh % MaxElementNodes,Types(i)-100*(Types(i)/100) )
    END DO

    CALL AllocateVector( Mesh % Nodes % x, Mesh % NumberOfNodes, 'LoadMesh' )
    CALL AllocateVector( Mesh % Nodes % y, Mesh % NumberOfNodes, 'LoadMesh' )
    CALL AllocateVector( Mesh % Nodes % z, Mesh % NumberOfNodes, 'LoadMesh' )
    CALL AllocateVector( Mesh % Elements, Mesh % NumberOfBulkElements + &
              Mesh % NumberOfBoundaryElements, 'LoadMesh' )
!
!------------------------------------------------------------------------------
!    Mesh nodes
!------------------------------------------------------------------------------
    CALL AllocateVector( cCoord, 3*Mesh % NumberOfNodes, 'LoadMesh' )
    CALL AllocateVector( NodeTags, Mesh % NumberOfNodes, 'LoadMesh' )

    CALL eio_get_mesh_nodes( NodeTags,cCoord,eio_info )

    CoordMap => ListGetIntegerArray( Model % Simulation, &
             'Coordinate Mapping',GotIt )

    IF ( GotIt ) THEN
      IF ( SIZE( CoordMap ) /= 3 ) THEN
         WRITE( Message, * ) 'Inconsistent Coordinate Mapping: ', CoordMap
         CALL Error( 'LoadMesh', Message )
         WRITE( Message, * ) 'Coordinate mapping should be a permutation of 1,2 and 3'
         CALL Fatal( 'LoadMesh', Message )
      END IF

      IF ( MINVAL( CoordMap ) < 1 .OR. MAXVAL( CoordMap ) > 3 ) THEN
         WRITE( Message, * ) 'Inconsistent Coordinate Mapping: ', CoordMap
         CALL Error( 'LoadMesh', Message )
         WRITE( Message, * ) 'Coordinate mapping should be a permutation of 1,2 and 3'
         CALL Fatal( 'LoadMesh', Message )
      END IF

      Mesh % Nodes % x = cCoord(CoordMap(1):3*Mesh % NumberOfNodes:3)
      Mesh % Nodes % y = cCoord(CoordMap(2):3*Mesh % NumberOfNodes:3)
      Mesh % Nodes % z = cCoord(CoordMap(3):3*Mesh % NumberOfNodes:3)
    ELSE
      Mesh % Nodes % x = cCoord(1:3*Mesh % NumberOfNodes:3)
      Mesh % Nodes % y = cCoord(2:3*Mesh % NumberOfNodes:3)
      Mesh % Nodes % z = cCoord(3:3*Mesh % NumberOfNodes:3)
    END IF

    mesh_dim = 0
    IF ( ANY( Mesh % Nodes % x /= Mesh % Nodes % x(1) ) ) mesh_dim = mesh_dim + 1
    IF ( ANY( Mesh % Nodes % y /= Mesh % Nodes % y(1) ) ) mesh_dim = mesh_dim + 1
    IF ( ANY( Mesh % Nodes % z /= Mesh % Nodes % z(1) ) ) mesh_dim = mesh_dim + 1
    Mesh % MeshDim = mesh_dim

    save_dim = Model % DIMENSION
    IF ( Model % DIMENSION <= 0 ) Model % DIMENSION = mesh_dim
 
    DEALLOCATE( cCoord )

    MinIndex = MINVAL( NodeTags )
    MaxIndex = MAXVAL( NodeTags )

    CALL AllocateVector( LocalPerm, MaxIndex-MinIndex+1, 'LoadMesh' )
    LocalPerm = 0
    DO i=1,Mesh % NumberOfNodes
      LocalPerm(NodeTags(i) - MinIndex + 1) = i
    END DO

!-----------------------------------------------------------------------------
! Scaling of coorinates 

    Wrk => ListGetConstRealArray( Model % Simulation,'Coordinate Scaling',GotIt )    
    IF( GotIt ) THEN            
      CoordScale = 1.0_dp
      DO i=1,mesh_dim
        j = MIN( i, SIZE(Wrk,2) )
        CoordScale(i) = Wrk(1,j)
      END DO
      WRITE(Message,'(A,3ES10.3)') 'Scaling coordinates:',CoordScale
      CALL Info('LoadMesh',Message) 
      Mesh % Nodes % x = CoordScale(1) * Mesh % Nodes % x
      IF( mesh_dim > 1) Mesh % Nodes % y = CoordScale(2) * Mesh % Nodes % y
      IF( mesh_dim > 2) Mesh % Nodes % z = CoordScale(3) * Mesh % Nodes % z
    END IF

!-----------------------------------------------------------------------------
!   Mesh elements
!------------------------------------------------------------------------------
    CALL AllocateVector( ElementTags, Mesh % NumberOfBulkElements+1, 'LoadMesh' )

    EdgeDOFs => NULL()
    CALL AllocateVector( EdgeDOFs, Mesh % NumberOfBulkElements, 'LoadMesh' )

    FaceDOFs => NULL()
    CALL AllocateVector( FaceDOFs, Mesh % NumberOfBulkElements, 'LoadMesh' )

    ElementTags = 0
    DGIndex = 0
    NeedEdges = .FALSE.

    DO i=1,Mesh % NumberOfBulkElements+1
       ! Clear indofs
      inDOFs = 0
      CALL eio_get_mesh_element_conns( ElementTags(i),partn,body, &
                  TYPE, inDOFs, nodes, eio_info )
      IF ( eio_info /= 0 ) EXIT

      IF ( PRESENT(Def_Dofs) ) THEN
        DO j=1,6
          IF ( Indofs(j) <= 0 ) inDOFs(j)=Def_Dofs(j)
        END DO
      END IF

      Element => Mesh % Elements(i)
      Element % ElementIndex = i

      Element % PartIndex = partn-1
      IF ( Element % PartIndex < 0 ) Element % PartIndex=mype

      NULLIFY( Element % TYPE )
      NULLIFY( Element % BoundaryInfo )
      Element % TYPE => GetElementType( TYPE )

      IF ( ASSOCIATED(Element % Type) ) THEN
        n = Element % TYPE % NumberOfNodes
        CALL AllocateVector( Element % NodeIndexes, n )
        DO j=1,n
          Element % NodeIndexes(j) = LocalPerm(nodes(j) - MinIndex + 1)
        END DO

        Element % BodyId = body
        DO j=1,Model % NumberOfBodies
          BList => ListGetIntegerArray( Model % Bodies(j) % Values, &
                       'Target Bodies', GotIt ) 
          IF ( Gotit ) THEN
            DO k=1,SIZE(BList)
              IF ( body == Blist(k) ) Element % BodyId = j
            END DO
          END IF
        END DO

        id = Element % BodyId
        Vlist => Model % Bodies(id) % Values
        j = ListGetInteger(Vlist,'Equation',gotIt)
        IF( gotIt ) THEN
          Vlist => Model % Equations(j) % Values
          ElementDef0=ListGetString(Vlist,'Element',Found )
          DO j=1,Model % NumberOfSolvers
            IF (.NOT. Found) ElementDef0=ListGetString(Model % Solvers(j) % Values,'Element',GotIt)
            ElementDef=ListGetString(Vlist,'Element{'//TRIM(i2s(j))//'}',GotIt)
            IF ( GotIt ) THEN
              CALL GetMaxDefs( Model, Mesh, Element, ElementDef, j, id, Indofs )
            ELSE
              CALL GetMaxDefs( Model, Mesh, Element, ElementDef0, j, id, Indofs )
            END IF
          END DO
        END IF

        IF ( inDOFs(1) /= 0 ) THEN
          Element % NDOFs = n
        ELSE
          Element % NDOFs = 0
        END IF

        EdgeDOFs(i) = MAX(0,inDOFs(2))
        FaceDOFs(i) = MAX(0,inDOFs(3))

        IF ( PRESENT(Def_Dofs) ) THEN
          IF ( Def_Dofs(4) == 0 ) inDOFs(4) = n
        END IF

        NULLIFY( Element % DGIndexes )
        IF ( inDOFs(4)>0 ) THEN
          CALL AllocateVector( Element % DGIndexes, inDOFs(4))
          DO j=1,inDOFs(4)
             DGIndex = DGIndex + 1
             Element % DGIndexes(j) = DGIndex
          END DO
        ELSE
          NULLIFY( Element % DGIndexes )
        END IF
        Element % DGDOFs = MAX(0,inDOFs(4))
        NeedEdges = NeedEdges .OR. ANY( inDOFs(2:4)>0 )

        NULLIFY( Element % EdgeIndexes )
        NULLIFY( Element % FaceIndexes )
        NULLIFY( Element % BubbleIndexes )

        ! Check if given element is a p element
        IF (inDOFs(6) > 0) THEN
           CALL AllocatePDefinitions(Element) 

           NeedEdges = .TRUE.
              
           ! Calculate element bubble dofs and set element p
           Element % PDefs % P = inDOFs(6)
           IF ( inDOFs(5) > 0 ) THEN
              Element % BDOFs = inDOFs(5)
           ELSE
              Element % BDOFs = getBubbleDOFs(Element, Element % PDefs % P)
           END IF
              
           ! All elements in actual mesh are not edges
           Element % PDefs % pyramidQuadEdge = .FALSE.
           Element % PDefs % isEdge = .FALSE.

           ! If element is of type tetrahedron and is a p element, 
           ! do the Ainsworth & Coyle trick
           IF (Element % TYPE % ElementCode == 504) CALL ConvertToACTetra( Element )
              CALL GetRefPElementNodes( Element,  Element % TYPE % NodeU, &
                   Element % TYPE % NodeV, Element % TYPE % NodeW )
        ELSE 
           ! Clear P element definitions and set manual bubbles
           Element % PDefs => Null()
           Element % BDOFs = MAX(0,inDOFs(5))
           ! WRITE (*,*) Element % BDOFs
        END IF

        Mesh % MaxElementNodes = MAX( &
                 Mesh % MaxElementNodes,Element % TYPE % NumberOfNodes )

      ELSE
        WRITE( Message, * ) 'Unknown element type ',TYPE,' ignoring element.'
        CALL Warn( 'LoadMesh', Message )
      END IF
    END DO

!------------------------------------------------------------------------------
    MinEIndex = MINVAL( ElementTags(1:Mesh % NumberOfBulkElements) )
    MaxEIndex = MAXVAL( ElementTags(1:Mesh % NumberOfBulkElements) )

    CALL AllocateVector( LocalEPerm, MaxEIndex - MinEIndex + 1, 'LoadMesh' )
    LocalEPerm = 0
    DO i=1,Mesh % NumberOfBulkElements
       LocalEPerm( ElementTags(i) - MinEIndex + 1 ) = i
    END DO

    i = LEN_TRIM(MeshNamePar)
    DO WHILE(MeshNamePar(i:i)==CHAR(0))
      i=i-1
    END DO
    CALL ReadElementPropertyFile( TRIM(MeshNamePar(1:i)) // &
         '/mesh.elements.data', Mesh )

    ALLOCATE( coord(3,Mesh % MaxElementNodes) )
!------------------------------------------------------------------------------
!            Mesh boundary elements
!------------------------------------------------------------------------------
    DO i=Mesh % NumberOfBulkElements + 1, &
      Mesh % NumberOfBulkElements + Mesh % NumberOfBoundaryElements  + 1

      CALL eio_get_mesh_bndry_element( tag, partn, bndry, left, &
            right, TYPE, nodes, coord, eio_info )

      IF ( eio_info /= 0 ) THEN
         Mesh % NumberOfBoundaryElements = &
              i - (Mesh % NumberOfBulkElements + 1)
         EXIT
      END IF

      IF ( Left >= MinEIndex .AND. Left <= MaxEIndex ) THEN
         Left  = LocalEPerm(Left - MinEIndex + 1)
      ELSE IF ( Left > 0 ) THEN
         WRITE( Message, * ) mype,'BOUNDARY PARENT out of range: ', Tag, Left
         CALL Error( 'LoadMesh', Message )
         Left = 0
      END IF

      IF ( Right >= MinEIndex .AND. Right <= MaxEIndex ) THEN
         Right = LocalEPerm(Right - MinEIndex + 1)
      ELSE IF ( Right > 0 ) THEN
         WRITE( Message, * ) mype,'BOUNDARY PARENT out of range: ', Tag,Right
         CALL Error( 'LoadMesh', Message )
         Right = 0
      END IF

      Mesh %  Elements(i) % ElementIndex = i
      NULLIFY(Mesh % Elements(i) % TYPE)
      Mesh % Elements(i) % TYPE => GetElementType( TYPE )

      Mesh % MaxElementNodes = MAX( &
                 Mesh % MaxElementNodes,TYPE-100*(TYPE/100))

      IF ( ASSOCIATED( Mesh % Elements(i) % TYPE ) ) THEN
        n = Mesh % Elements(i) % TYPE % NumberOfNodes

        ALLOCATE( Mesh % Elements(i) % BoundaryInfo, STAT=istat )
        IF ( istat /= 0 ) &
           CALL Fatal( 'LoadMesh', 'Unable to allocate mesh arrays.' )

        Mesh % Elements(i) % BoundaryInfo % Constraint =  0

        DO j=1,Model % NumberOfBoundaries
          IF ( Model % BoundaryId(j) == bndry ) THEN
            Mesh % Elements(i) % BoundaryInfo % Constraint = &
              ListGetInteger( Model % Boundaries(j) % Values, &
                 'Boundary Condition',GotIt, minv=1, maxv=Model % NumberOFBCs )
            EXIT
          END IF
        END DO

        IF ( partn>=1 ) THEN
          Mesh % Elements(i) % PartIndex = partn-1
        ELSE
          Mesh % Elements(i) % PartIndex = mype
        END IF
        Mesh % Elements(i) % BodyId = 0

        DO j=1,Model % NumberOfBCs
          BList => ListGetIntegerArray( Model % BCs(j) % Values, &
                     'Target Boundaries', GotIt ) 
          IF ( GotIt ) THEN
            DO k=1,SIZE(BList)
              IF ( BList(k) == bndry ) THEN
                Mesh % Elements(i) % BoundaryInfo % Constraint = j
                Mesh % Elements(i) % BodyId  = ListGetInteger( &
                  Model % BCs(j) % Values, 'Body Id', Gotit, 1, Model % NumberOfBodies )
                EXIT
              END IF
            END DO
          END IF
        END DO

        j = Mesh % Elements(i) % BoundaryInfo % Constraint
        IF ( j > 0 .AND. j <= Model % NumberOfBCs ) &
          Mesh % Elements(i) % BoundaryInfo % OutBody = &
             ListGetInteger( Model % BCs(j) % Values, &
                'Normal Target Body', GotIt, maxv=Model % NumberOFBodies ) 
!         Mesh % Elements(i) % BoundaryInfo % OutBody => &
!            ListGetIntegerArray( Model % BCs(j) % Values, &
!               'Normal Target Body', GotIt, maxv=Model % NumberOFBodies ) 
!       IF ( .NOT. ASSOCIATED(Mesh % Elements(i) % BoundaryInfo) ) % OutBody ) THEN
!          ALLOCATE( Mesh % Elements(i) % BoundaryInfo) ) % OutBody(1) )
!          Mesh % Elements(i) % BoundaryInfo) ) % OutBody(1) )
!       END IF

        CALL AllocateVector( Mesh % Elements(i) % NodeIndexes, n )

        ! Set local to global mapping for boundary element
        DO j=1,n
          Mesh % Elements(i) % NodeIndexes(j) = LocalPerm(nodes(j) - MinIndex + 1)
        END DO

        Mesh % Elements(i) % EdgeIndexes => Null()
        Mesh % Elements(i) % FaceIndexes => Null()

        Mesh % Elements(i) % BoundaryInfo % Left => Null()
        IF ( Left >= 1 ) &
          Mesh % Elements(i) % BoundaryInfo % Left => Mesh % Elements(left)

        Mesh % Elements(i) % BoundaryInfo % Right => Null()
        IF ( Right >= 1 ) &
          Mesh % Elements(i) % BoundaryInfo % Right => Mesh % Elements(right)

        Mesh % Elements(i) % Boundaryinfo % GebhardtFactors => Null()

        Mesh % Elements(i) % NDOFs  = n
        IF ( ASSOCIATED(Mesh % Elements(i) % BoundaryInfo % Left) ) THEN
           IF( Mesh % Elements(i) % BoundaryInfo % Left % NDOFs == 0 )  &
              Mesh % Elements(i) % NDOFs = 0

           IF ( Mesh % Elements(i) % TYPE % DIMENSION == 1 ) THEN
              Mesh % Elements(i) % BDOFs = &
                 EdgeDOFs(Mesh % Elements(i) % BoundaryInfo % Left % ElementIndex)
           ELSE
              Mesh % Elements(i) % BDOFs = &
                 FaceDOFs(Mesh % Elements(i) % BoundaryInfo % Left % ElementIndex)
           END IF
        END IF

        IF ( ASSOCIATED(Mesh % Elements(i) % BoundaryInfo % Right) ) THEN
           IF ( Mesh % Elements(i) % BoundaryInfo % Right % NDOFs == 0 )  &
              Mesh % Elements(i) % NDOFs = 0

           IF ( Mesh % Elements(i) % TYPE % DIMENSION == 1 ) THEN
              Mesh % Elements(i) % BDOFs = &
                  EdgeDOFs(Mesh % Elements(i) % BoundaryInfo % Right % ElementIndex)
           ELSE
              Mesh % Elements(i) % BDOFs = &
                  FaceDOFs(Mesh % Elements(i) % BoundaryInfo % Right % ElementIndex)
           END IF
        END IF

        Mesh % Elements(i) % DGDOFs = 0
        Mesh % Elements(i) % PDefs => Null()
        Mesh % Elements(i) % DGIndexes => Null()
        Mesh % Elements(i) % EdgeIndexes => Null()
        Mesh % Elements(i) % FaceIndexes => Null()
        Mesh % Elements(i) % BubbleIndexes => Null()
      ELSE
        WRITE( Message, * ) 'Unknown element type ',TYPE,' ignoring element.'
        CALL Warn( 'LoadMesh', Message )
      END IF
    END DO
    IF ( Mesh % MaxElementDOFs <= 0 ) Mesh % MaxElementDOFs=Mesh % MaxElementNodes 

    DEALLOCATE( Coord, LocalEPerm )
    Model % FreeSurfaceNodes => Null()
    Model % BoundaryCurvatures => Null()
!------------------------------------------------------------------------------

    IF ( NeedEdges ) THEN
      CALL FindMeshEdges( Mesh )

      ! Set edge and face polynomial degree and degrees of freedom for
      ! all elements
      DO i=1,Mesh % NumberOFBulkElements
         Element => Mesh % Elements(i)
         
         ! Iterate each edge of element
         DO j = 1,Element % TYPE % NumberOfEdges
            Edge => Mesh % Edges( Element % EdgeIndexes(j) ) 
            
            ! Set attributes of p element edges
            IF ( ASSOCIATED(Element % PDefs) ) THEN   
               ! Set edge polynomial degree and dofs
               Edge % PDefs % P = MAX( Element % PDefs % P, Edge % PDefs % P)
               Edge % BDOFs = MAX(Edge % BDOFs, Edge % PDefs % P - 1)
               Edge % PDefs % isEdge = .TRUE.
               ! Get gauss points for edge. If no dofs 2 gauss points are 
               ! still needed for integration of linear equation!
               Edge % PDefs % GaussPoints = (Edge % BDOFs+2)**Edge % TYPE % DIMENSION  

               IF (ASSOCIATED(Edge % BoundaryInfo % Left) ) THEN
                 CALL AssignLocalNumber(Edge, Edge % BoundaryInfo % Left, Mesh)
               ELSE
                 CALL AssignLocalNumber(Edge, Edge % BoundaryInfo % Right, Mesh)
               END IF
               
            ! Other element types, which need edge dofs
            ELSE
               Edge % BDOFs = MAX(EdgeDOFs(i), Edge % BDOFs)
            END IF

            ! Get maximum dof for edges
            Mesh % MaxEdgeDOFs = MAX(Edge % BDOFs, Mesh % MaxEdgeDOFs)
         END DO

         ! Iterate each face of element
         DO j=1,Element % TYPE % NumberOfFaces
            Face => Mesh % Faces( Element % FaceIndexes(j) )

            ! Set attibutes of p element faces
            IF ( ASSOCIATED(Element % PDefs) ) THEN
               ! Set face polynomial degree and dofs
               Face % PDefs % P = MAX(Element % PDefs % P, Face % PDefs % P)
               ! Get number of face dofs
               Face % BDOFs = MAX( Face % BDOFs, getFaceDOFs(Element, Face % PDefs % P, j) )
               Face % PDefs % isEdge = .TRUE.
               Face % PDefs % GaussPoints = getNumberOfGaussPointsFace( Face, Mesh )
               IF (ASSOCIATED(Face % BoundaryInfo % Left) ) THEN
                 CALL AssignLocalNumber(Face, Face % BoundaryInfo % Left, Mesh)
               ELSE
                 CALL AssignLocalNumber(Face, Face % BoundaryInfo % Right, Mesh)
               END IF
            ELSE
               Face % BDOFs = MAX(FaceDOFs(i), Face % BDOFs)
            END IF
               
            ! Get maximum dof for faces
            Mesh % MaxFaceDOFs = MAX(Face % BDOFs, Mesh % MaxFaceDOFs)
         END DO
      END DO

      ! Set local edges for boundary elements
      DO i=Mesh % NumberOfBulkElements + 1, &
           Mesh % NumberOfBulkElements + Mesh % NumberOfBoundaryElements
         Element => Mesh % Elements(i)

         ! Here set local number and copy attributes to this boundary element for left parent.
         IF (ASSOCIATED(Element % BoundaryInfo % Left)) THEN
            ! Local edges are only assigned for p elements
            IF (ASSOCIATED(Element % BoundaryInfo % Left % PDefs)) THEN

               CALL AllocatePDefinitions(Element)
               Element % PDefs % isEdge = .TRUE.
               CALL AssignLocalNumber(Element, Element % BoundaryInfo % Left, Mesh)
               ! CYCLE
            END IF
         END IF

         ! Here set local number and copy attributes to this boundary element for right parent
         IF (ASSOCIATED(Element % BoundaryInfo % Right)) THEN
            ! Local edges are only assigned for p elements
            IF (ASSOCIATED(Element % BoundaryInfo % Right % PDefs)) THEN
               CALL AllocatePDefinitions(Element)
               Element % PDefs % isEdge = .TRUE.
               CALL AssignLocalNumber(Element, Element % BoundaryInfo % Right, Mesh)
            END IF
         END IF
      END DO
   END IF

   ! Set gauss points for each p element
   DO i=1,Mesh % NumberOfBulkElements
     Element => Mesh % Elements(i)
     IF ( ASSOCIATED(Element % PDefs) ) THEN
        Element % PDefs % GaussPoints = getNumberOfGaussPoints( Element, Mesh )
     END IF

     ! Set max element dofs here (because element size may have changed
     ! when edges and faces have been set). This is the absolute worst case.
     ! Element which has MaxElementDOFs may not even be present as a 
     ! real element
     Mesh % MaxElementDOFs = MAX( Mesh % MaxElementDOFs, &
          Element % TYPE % NumberOfNodes + &
          Element % TYPE % NumberOfEdges * Mesh % MaxEdgeDOFs + &
          Element % TYPE % NumberOfFaces * Mesh % MaxFaceDOFs + &
          Element % BDOFs, &
          Element % DGDOFs )

     Mesh % MaxBDOFs = MAX( Element % BDOFs, Mesh % MaxBDOFs )
   END DO

   DO i=1,Mesh % NumberOFBulkElements
     Element => Mesh % Elements(i)
     IF ( Element % BDOFs > 0 ) THEN
       ALLOCATE( Element % BubbleIndexes(Element % BDOFs) )
       DO j=1,Element % BDOFs
         Element % BubbleIndexes(j) = Mesh % MaxBDOFs*(i-1)+j
       END DO
     END IF
   END DO
   IF ( ASSOCIATED(EdgeDOFs) ) DEALLOCATE(EdgeDOFs, FaceDOFs)

   ! Reallocate coordinate arrays for iso-parametric p-elements:
   ! -----------------------------------------------------------
   n = Mesh % NumberOfNodes + &
       Mesh % MaxEdgeDOFs * Mesh % NumberOFEdges + &
       Mesh % MaxFaceDOFs * Mesh % NumberOFFaces + &
       Mesh % MaxBDOFs    * Mesh % NumberOFBulkElements


   IF ( n>Mesh % NumberOfNodes ) THEN
     cCoord => Mesh % Nodes % x
     ALLOCATE( Mesh % Nodes % x(n) )
     Mesh % Nodes % x = 0.0d0
     Mesh % Nodes % x(1:Mesh % NumberOFNodes) = cCoord
     DEALLOCATE( cCoord )

     cCoord => Mesh % Nodes % y
     ALLOCATE( Mesh % Nodes % y(n) )
     Mesh % Nodes % y = 0.0d0
     Mesh % Nodes % y(1:Mesh % NumberOFNodes) = cCoord
     DEALLOCATE( cCoord )

     cCoord => Mesh % Nodes % z
     ALLOCATE( Mesh % Nodes % z(n) )
     Mesh % Nodes % z = 0.0d0
     Mesh % Nodes % z(1:Mesh % NumberOFNodes) = cCoord
     DEALLOCATE( cCoord )
   END IF

   Mesh % ParallelInfo % NumberOfIfDOFs = 0
   Mesh % ParallelInfo % GlobalDOFs => NodeTags

   IF ( parallel ) THEN
     DO i=1,Mesh % NumberOfBulkElements
       Mesh % Elements(i) % GElementIndex = ElementTags(i)
     END DO

     ALLOCATE( Mesh % ParallelInfo % GlobalDOFs(n) )
     Mesh % ParallelInfo % GlobalDOFs = 0
     Mesh % ParallelInfo % GlobalDOFs(1:Mesh % NumberOfNodes) = NodeTags

     ALLOCATE(Mesh % ParallelInfo % NeighbourList(n), STAT=istat)
     IF (istat /= 0) CALL Fatal('LoadMesh', 'Unable to allocate mesh arrays.')

     DO i=1,n
       NULLIFY( Mesh % ParallelInfo % NeighbourList(i) % Neighbours )
     END DO

     CALL AllocateVector( Mesh % ParallelInfo % INTERFACE, n, 'LoadMesh')
     Mesh % ParallelInfo % INTERFACE = .FALSE.

     CALL eio_get_part_description( fields,eio_info )
     DO i=1,fields
       CALL eio_get_part_node( tag,bndry,pCoord,npart,parts,eio_info )
       IF ( eio_info /= 0 ) &
          CALL Fatal( 'LoadMesh', 'Error in shared nodes definition.' )
       k = LocalPerm( tag-MinIndex+1 )

       Mesh % ParallelInfo % INTERFACE(k) = .TRUE.
       CALL AllocateVector(Mesh % ParallelInfo % NeighbourList(k) % Neighbours,npart)
       Mesh % ParallelInfo % NeighbourList(k) % Neighbours = parts(1:npart) - 1

       IF ( parts(1)-1 /= mype ) Mesh % ParallelInfo % NumberOfIfDOFs = &
                 Mesh % ParallelInfo % NumberOfIfDOFs + 1
     END DO

     DO i=1,n
       IF (.NOT.ASSOCIATED(Mesh % ParallelInfo % NeighbourList(i) % Neighbours)) THEN
          CALL AllocateVector(Mesh % ParallelInfo % NeighbourList(i) % Neighbours,1)
          Mesh % ParallelInfo % NeighbourList(i) % Neighbours(1) = mype
       END IF
     END DO
 
     CALL SParFaceNumbering(Mesh)
     CALL SParEdgeNumbering(Mesh)
   END IF
   DEALLOCATE( LocalPerm, ElementTags )
   CALL eio_close_mesh( eio_info )
   
   CALL eio_close( eio_info )
   !
   ! If periodic BC given, compute boundary mesh projector:
   ! ------------------------------------------------------
   DO i = 1,Model % NumberOfBCs
      NULLIFY( Model % BCs(i) % PMatrix )
   END DO

   DO i = 1,Model % NumberOfBCs
      k = ListGetInteger( Model % BCs(i) % Values, 'Periodic BC', GotIt, &
                    minv=1, maxv=Model % NumberOFBCs )
      Projector =>  PeriodicProjector( Model, Mesh, i, k )
      IF ( ASSOCIATED( Projector ) ) Model % BCs(i) % PMatrix => Projector

!     Projector => PeriodicProjector( Model, Mesh, k, i )
!     IF ( ASSOCIATED( Projector ) ) Model % BCs(k) % PMatrix => Projector
   END DO

   Model % DIMENSION = save_dim
!------------------------------------------------------------------------------
  END FUNCTION LoadMesh
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE ReadElementPropertyFile(FileName,Mesh)
     CHARACTER(LEN=*) :: FileName
     TYPE(Mesh_t) :: Mesh
!------------------------------------------------------------------------------
    INTEGER, PARAMETER :: MAXLEN=1024
    CHARACTER(LEN=MAXLEN) :: str
    INTEGER :: i,j,n
    REAL(KIND=dp) :: x
    TYPE(Element_t), POINTER :: Element
    TYPE(ElementData_t), POINTER :: PD,PD1

    OPEN( Unit=10, File=FileName, STATUS='OLD', ERR=10 )
    DO WHILE( ReadAndTrim(10,str) )
      IF ( str(1:8) == 'element:' ) THEN
        READ( str(9:),*) i
        IF ( i<0 .OR. i>Mesh % NumberOFBulkElements ) THEN
          CALL Fatal( 'ReadElementProperties', 'Element id out of range.' )
        END IF

        Element => Mesh % Elements(i)
        PD => Element % PropertyData

        DO WHILE(ReadAndTrim(10,str))
          IF ( str(1:3) == 'end' ) EXIT

          i = INDEX(str, ':')
          IF ( i<=0 ) CYCLE

          IF ( .NOT.ASSOCIATED(PD)  ) THEN
            ALLOCATE( Element % PropertyData )
            PD => Element % PropertyData
            PD % Name = TRIM(str(1:i-1))
          ELSE
            DO WHILE(ASSOCIATED(PD))
              IF ( PD % Name==TRIM(str(1:i-1)) ) EXIT
              PD1 => PD
              PD => PD % Next
            END DO
            
            IF (.NOT. ASSOCIATED(PD) ) THEN
              ALLOCATE(PD1 % Next)
              PD => PD1 % Next
              PD % Name = TRIM(str(1:i-1))
            END IF
          END IF

          j = i+1
          n = 0
          DO WHILE(j<=LEN_TRIM(str))
            READ( str(j:), *, END=20,ERR=20 ) x
            n = n + 1
            DO WHILE(j<=LEN_TRIM(str) .AND. str(j:j)==' ')
              j = j + 1
            END DO
            DO WHILE(j<=LEN_TRIM(str) .AND. str(j:j)/=' ')
              j = j + 1
            END DO
          END DO
20        CONTINUE
          IF ( n>0 ) THEN
            ALLOCATE(PD % Values(n))
            j = i+1
            n = 1
            DO WHILE(j<=LEN_TRIM(str))
              READ( str(j:), *, END=30,ERR=30 ) PD % Values(n)
              n = n + 1
              DO WHILE(j<=LEN_TRIM(str) .AND. str(j:j)==' ')
                j = j + 1
              END DO
              DO WHILE(j<=LEN_TRIM(str) .AND. str(j:j)/=' ')
                j = j + 1
              END DO
            END DO
30          CONTINUE
          END IF
        END DO
      END IF
    END DO

    CLOSE(10)

10  CONTINUE

!------------------------------------------------------------------------------
  END SUBROUTINE ReadElementPropertyFile
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE MeshStabParams( Mesh )
!------------------------------------------------------------------------------
    TYPE(Mesh_t), POINTER :: Mesh
!------------------------------------------------------------------------------
    TYPE(Solver_t), POINTER :: Solver
    INTEGER :: i,n, istat
    LOGICAL :: stat
    TYPE(Nodes_t) :: Nodes
    TYPE(Element_t), POINTER :: Element
!------------------------------------------------------------------------------

    DO i=1,CurrentModel % NumberOfSolvers
       Solver => CurrentModel % Solvers(i)
       IF ( ASSOCIATED( Mesh, Solver % Mesh ) ) THEN
          Mesh % Stabilize = Mesh % Stabilize .OR. &
             ListGetLogical( Solver % Values, 'Stabilize', Stat )
          Mesh % Stabilize = Mesh % Stabilize .OR. &
             ListGetString( Solver % Values,  &
                     'Stabilization Method', Stat )=='vms'
          Mesh % Stabilize = Mesh % Stabilize .OR. &
             ListGetString( Solver % Values,  &
                     'Stabilization Method', Stat )=='stabilized'
       END IF
    END DO

    CALL AllocateVector( Nodes % x, Mesh % MaxElementNodes )
    CALL AllocateVector( Nodes % y, Mesh % MaxElementNodes )
    CALL AllocateVector( Nodes % z, Mesh % MaxElementNodes )

    DO i=1,Mesh % NumberOfBulkElements
       Element => Mesh % Elements(i)
       n = Element % TYPE % NumberOfNodes
       Nodes % x(1:n) = Mesh % Nodes % x(Element % NodeIndexes)
       Nodes % y(1:n) = Mesh % Nodes % y(Element % NodeIndexes)
       Nodes % z(1:n) = Mesh % Nodes % z(Element % NodeIndexes)
       IF ( Mesh % Stabilize ) THEN
          CALL StabParam( Element, Nodes,n, &
              Element % StabilizationMK, Element % hK )
       ELSE
          Element % hK = ElementDiameter( Element, Nodes )
       END IF
    END DO
 
    DEALLOCATE( Nodes % x, Nodes % y, Nodes % z )
!----------------------------------------------------------------------------
  END SUBROUTINE MeshStabParams
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  FUNCTION PeriodicProjector( Model, Mesh, This, Trgt, cdim ) RESULT(Projector)
!------------------------------------------------------------------------------
!******************************************************************************
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    INTEGER :: This, Trgt
    INTEGER, OPTIONAL :: cdim
    TYPE(Mesh_t) :: Mesh
    TYPE(Matrix_t), POINTER :: Projector
!------------------------------------------------------------------------------

    INTEGER :: i,j,k,l,m,n,n1,n2,k1,k2, Constraint, DIM
    TYPE(Nodes_t) :: Nodes
    TYPE(Element_t), POINTER :: Element, Elements(:)
    LOGICAL :: GotIt, GotRotate
    INTEGER, POINTER :: NodeIndexes(:), Perm1(:), Perm2(:), &
                 InvPerm1(:), InvPerm2(:)
    TYPE(Mesh_t), POINTER ::  BMesh1, BMesh2
    REAL(KIND=dp), POINTER :: PArray(:,:) => NULL()
    REAL(KIND=dp) :: x(4), RotMatrix(4,4),TrsMatrix(4,4),SclMatrix(4,4), &
           TrfMatrix(4,4),Identity(4,4), x1(3), x2(3), Normal(3), dist, alpha

    REAL(KIND=dp) :: scl_x, scl_y, scl_z
    REAL(KIND=dp) :: xmin_1, xmax_1, ymin_1, ymax_1, zmin_1, zmax_1
    REAL(KIND=dp) :: xmin_2, xmax_2, ymin_2, ymax_2, zmin_2, zmax_2

    SAVE Parray
!------------------------------------------------------------------------------

    NULLIFY( Projector )
    IF ( This <= 0 .OR. Trgt <= 0 ) RETURN

    Elements => Mesh % Elements( Mesh % NumberOfBulkElements+1: )

!
!   Search elements in this boundary and its periodic
!   counterpart:
!   --------------------------------------------------
    n1 = 0
    n2 = 0
    DO i=1, Mesh % NumberOfBoundaryElements
       Constraint = Elements(i) % BoundaryInfo % Constraint
       IF ( Model % BCs(This) % Tag == Constraint ) n1 = n1 + 1
       IF ( Model % BCs(Trgt) % Tag == Constraint ) n2 = n2 + 1
    END DO

    IF ( n1 <= 0 .OR. n2 <= 0 ) RETURN
!
!   Initialize mesh structures for boundaries, this
!   is for getting the mesh projector:
!   ------------------------------------------------
    BMesh1 => AllocateMesh()
    BMesh2 => AllocateMesh()

    CALL AllocateVector( BMesh1 % Elements,n1 )
    CALL AllocateVector( BMesh2 % Elements,n2 )
    CALL AllocateVector( Perm1, Mesh % NumberOfNodes )
    CALL AllocateVector( Perm2, Mesh % NumberOfNodes )

!
!   Fill in the mesh element structures with the
!   boundary elements:
!   ---------------------------------------------
    n1 = 0
    n2 = 0
    Perm1 = 0
    Perm2 = 0
    BMesh1 % MaxElementNodes = 0
    BMesh2 % MaxElementNodes = 0
    DO i=1, Mesh % NumberOfBoundaryElements
       Element => Elements(i)
       IF ( Element % TYPE % ElementCode < 200 ) CYCLE

       n = Element % TYPE % NumberOfNodes
       Constraint = Element % BoundaryInfo % Constraint

       IF ( Model % BCs(This) % Tag == Constraint ) THEN
          n1 = n1 + 1
          BMesh1 % MaxElementNodes = MAX( BMesh1 % MaxElementNodes, n )
          BMesh1 % Elements(n1) = Elements(i)
          CALL AllocateVector(BMesh1 % Elements(n1) % NodeIndexes,n )
          BMesh1 % Elements(n1) % NodeIndexes =  Elements(i) % NodeIndexes
          NULLIFY( BMesh1 % Elements(n1) % EdgeIndexes )
          NULLIFY( BMesh1 % Elements(n1) % FaceIndexes )
          Perm1( Elements(i) % NodeIndexes ) = 1
       END IF

       IF ( Model % BCs(Trgt) % Tag == Constraint ) THEN
          n2 = n2 + 1
          BMesh2 % MaxElementNodes = MAX( BMesh2 % MaxElementNodes, n )
          BMesh2 % Elements(n2) = Elements(i)
          CALL AllocateVector(BMesh2 % Elements(n2) % NodeIndexes,n )
          BMesh2 % Elements(n2) % NodeIndexes =  Elements(i) % NodeIndexes
          NULLIFY( BMesh2 % Elements(n2) % EdgeIndexes )
          NULLIFY( BMesh2 % Elements(n2) % FaceIndexes )
          Perm2( Elements(i) % NodeIndexes ) = 1
       END IF
    END DO

    BMesh1 % NumberOfBulkElements = n1
    BMesh2 % NumberOfBulkElements = n2


!   Fill in the mesh node structures with the
!   boundary nodes:
!   -----------------------------------------
    BMesh2 % NumberOfNodes = COUNT( Perm2==1 )
    BMesh1 % NumberOfNodes = COUNT( Perm1==1 )

    IF (BMesh1 % NumberOfNodes==0 .OR. BMesh2 % NumberOfNOdes==0) THEN
      DO i=1,BMesh1 % NumberOfBulkElements
         DEALLOCATE( BMesh1 % Elements(i) % NodeIndexes )
      END DO

      DO i=1,BMesh2 % NumberOfBulkElements
         DEALLOCATE( BMesh2 % Elements(i) % NodeIndexes )
      END DO

      DEALLOCATE( BMesh1 % Elements, BMesh2 % Elements )
      DEALLOCATE( Perm1, Perm2, BMesh1, BMesh2 )
      RETURN
    END IF

    ALLOCATE( BMesh1 % Nodes )
    CALL AllocateVector( BMesh1 % Nodes % x, BMesh1 % NumberOfNodes ) 
    CALL AllocateVector( BMesh1 % Nodes % y, BMesh1 % NumberOfNodes ) 
    CALL AllocateVector( BMesh1 % Nodes % z, BMesh1 % NumberOfNodes )

    ALLOCATE( BMesh2 % Nodes )
    CALL AllocateVector( BMesh2 % Nodes % x, BMesh2 % NumberOfNodes ) 
    CALL AllocateVector( BMesh2 % Nodes % y, BMesh2 % NumberOfNodes ) 
    CALL AllocateVector( BMesh2 % Nodes % z, BMesh2 % NumberOfNodes )

    CALL AllocateVector( InvPerm1, BMesh1 % NumberOfNodes )
    CALL AllocateVector( InvPerm2, BMesh2 % NumberOfNodes )

    xmin_1 =  HUGE(dp); ymin_1 =  HUGE(dp); zmin_1 =  HUGE(dp)
    xmin_2 =  HUGE(dp); ymin_2 =  HUGE(dp); zmin_2 =  HUGE(dp)

    xmax_1 = -HUGE(dp); ymax_1 = -HUGE(dp); zmax_1 = -HUGE(dp)
    xmax_2 = -HUGE(dp); ymax_2 = -HUGE(dp); zmax_2 = -HUGE(dp)


! Initialize the mapping matrices
    x = 0.0d0
    Identity = 0.0d0
    DO i=1,4
       Identity(i,i) = 1.0d0
    END DO

    TrsMatrix = Identity
    RotMatrix = Identity
    SclMatrix = Identity

!   Rotations:
!   These are called first since they are not accounted for in the 
!   automatic scaling and translation.
!   ---------
    Parray => ListGetConstRealArray( Model % BCs(This) % Values, &
                   'Periodic BC Rotate', GotRotate )

    IF ( GotRotate ) THEN

       DO i=1,SIZE(Parray,1)
          Alpha = Parray(i,1) * PI / 180
          IF( ABS(Alpha) < TINY(Alpha) ) CYCLE 
          TrfMatrix = Identity

          SELECT CASE(i)
            CASE(1)
               TrfMatrix(2,2) =  COS(Alpha)
               TrfMatrix(2,3) = -SIN(Alpha) 
               TrfMatrix(3,2) =  SIN(Alpha)
               TrfMatrix(3,3) =  COS(Alpha)
            CASE(2)
               TrfMatrix(1,1) =  COS(Alpha)
               TrfMatrix(1,3) = -SIN(Alpha)
               TrfMatrix(3,1) =  SIN(Alpha)
               TrfMatrix(3,3) =  COS(Alpha)
            CASE(3)
               TrfMatrix(1,1) =  COS(Alpha)
               TrfMatrix(1,2) = -SIN(Alpha)
               TrfMatrix(2,1) =  SIN(Alpha)
               TrfMatrix(2,2) =  COS(Alpha)
           END SELECT
         
           RotMatrix = MATMUL( RotMatrix, TrfMatrix )
       END DO
    END IF

    k1 = 0; k2 = 0
    DO i=1,Mesh % NumberOfNodes
       IF ( Perm1(i) > 0 ) THEN
          k1 = k1 + 1
          Perm1(i) = k1
          InvPerm1(k1) = i
          BMesh1 % Nodes % x(k1)  = Mesh % Nodes % x(i)
          BMesh1 % Nodes % y(k1)  = Mesh % Nodes % y(i)
          BMesh1 % Nodes % z(k1)  = Mesh % Nodes % z(i)

          xmin_1 = MIN( xmin_1, Mesh % Nodes % x(i) )
          ymin_1 = MIN( ymin_1, Mesh % Nodes % y(i) )
          zmin_1 = MIN( zmin_1, Mesh % Nodes % z(i) )

          xmax_1 = MAX( xmax_1, Mesh % Nodes % x(i) )
          ymax_1 = MAX( ymax_1, Mesh % Nodes % y(i) )
          zmax_1 = MAX( zmax_1, Mesh % Nodes % z(i) )
       END IF

       IF ( Perm2(i) > 0 ) THEN
          k2 = k2 + 1
          Perm2(i) = k2
          InvPerm2(k2) = i

          x(1) = Mesh % Nodes % x(i)
          x(2) = Mesh % Nodes % y(i)
          x(3) = Mesh % Nodes % z(i)
 
          IF( GotRotate ) THEN
            x = MATMUL( RotMatrix, x )
          END IF 

          BMesh2 % Nodes % x(k2)  = x(1)
          BMesh2 % Nodes % y(k2)  = x(2)
          BMesh2 % Nodes % z(k2)  = x(3)

          xmin_2 = MIN( xmin_2, x(1) )
          ymin_2 = MIN( ymin_2, x(2) ) 
          zmin_2 = MIN( zmin_2, x(3) )

          xmax_2 = MAX( xmax_2, x(1) )
          ymax_2 = MAX( ymax_2, x(2) )
          zmax_2 = MAX( zmax_2, x(3) )
       END IF
    END DO


    scl_x = xmax_2 - xmin_2
    IF ( ABS(scl_x) > AEPS ) THEN
      scl_x = (xmax_1 - xmin_1) / scl_x
    ELSE
      scl_x = 1.0_dp
    END IF

    scl_y = ymax_2 - ymin_2
    IF ( ABS(scl_y) > AEPS ) THEN
      scl_y = (ymax_1 - ymin_1) / scl_y
    ELSE
      scl_y = 1.0_dp
    END IF

    scl_z = zmax_2 - zmin_2
    IF ( ABS(scl_z) > AEPS ) THEN
      scl_z = (zmax_1 - zmin_1) / scl_z
    ELSE
      scl_z = 1.0_dp
    END IF

!
!   Renumber the element node pointers to use
!   only boundary nodes:
!   -----------------------------------------
    DO i=1,n1
       BMesh1 % Elements(i) % NodeIndexes = &
          Perm1(BMesh1 % Elements(i) % NodeIndexes )
    END DO

    DO i=1,n2
       BMesh2 % Elements(i) % NodeIndexes = &
           Perm2(BMesh2 % Elements(i) % NodeIndexes)
    END DO

!
!   Transform the target boundary on top of this
!   boundary (hopefully):
!   --------------------------------------------

!   NULLIFY( PArray )
!
!   Translations:
!   -------------
    Parray => ListGetConstRealArray( Model % BCs(This) % Values, &
                 'Periodic BC Translate', Gotit )

    IF ( .NOT. gotit ) THEN
      TrsMatrix(4,1) = xmin_1 - scl_x*xmin_2
      TrsMatrix(4,2) = ymin_1 - scl_y*ymin_2
      TrsMatrix(4,3) = zmin_1 - scl_z*zmin_2
      WRITE(Message,'(A,3ES10.3)') 'Translation: ',TrsMatrix(4,1:3)
      CALL Info('PeriodicProjector',Message)
    ELSE
      DO i=1,SIZE(Parray,1)
         TrsMatrix(4,i) = Parray(i,1)
      END DO
    END IF
!
!   Scales:
!   -------
    Parray => ListGetConstRealArray( Model % BCs(This) % Values, &
                   'Periodic BC Scale', Gotit )

    IF ( GotIt ) THEN
      DO i=1,SIZE(Parray,1)
        SclMatrix(i,i) = Parray(i,1)
      END DO
    ELSE
      SclMatrix(1,1) = scl_x
      SclMatrix(2,2) = scl_y
      SclMatrix(3,3) = scl_z
      WRITE(Message,'(A,3ES10.3)') 'Scaling: ',scl_x,scl_y,scl_z
      CALL Info('PeriodicProjector',Message)
    END IF


    TrfMatrix = MATMUL( SClMatrix, TrsMatrix )

!    If whole transf. matrix given, it will override
!    all the other settings:
!    ------------------------------------------------
     Parray => ListGetConstRealArray( Model % BCs(This) % Values, &
                  'Periodic BC Matrix', Gotit )

     IF ( GotIt ) THEN
        DO i=1,SIZE(Parray,1)
           DO j=1,SIZE(Parray,2)
              TrfMatrix(i,j) = Parray(j,i)
           END DO
        END DO
     END IF

!    IF ( ASSOCIATED(Parray) ) DEALLOCATE( Parray )
!
!    Now transform the coordinates:
!    ------------------------------
     DO i=1,BMesh2 % NumberOfNodes
        x(1) = BMesh2 % Nodes % x(i)
        x(2) = BMesh2 % Nodes % y(i)
        x(3) = BMesh2 % Nodes % z(i)
        x(4) = 1.0d0
        x = MATMUL( x, TrfMatrix ) 
        BMesh2 % Nodes % x(i) = x(1) / x(4)
        BMesh2 % Nodes % y(i) = x(2) / x(4) 
        BMesh2 % Nodes % z(i) = x(3) / x(4)
     END DO
!
!    Get the mesh projetor, which now contains
!    weigths between the two boundaries nodes:
!    ------------------------------------------
     Projector => MeshProjector( BMesh2, BMesh1 )

     Projector % InvPerm => InvPerm1
     DO i=1,Projector % NumberOfRows
        DO j=Projector % Rows(i),Projector % Rows(i+1)-1
           k = Projector % Cols(j)    
           IF ( k > 0 ) Projector % Cols(j) = InvPerm2(k)
        END DO
     END DO

!DO i=1,SIZE(Projector % Values)
!IF ( ABS(Projector % Values(i))   < 1.0d-12 ) Projector % Values(i) = 0.0d0
!IF ( ABS(Projector % Values(i)-1) < 1.0d-12 ) Projector % Values(i) = 1.0d0
!END DO
!
!    Deallocate mesh structures:
!    ---------------------------
     DO i=1,BMesh1 % NumberOfBulkElements
        DEALLOCATE( BMesh1 % Elements(i) % NodeIndexes )
     END DO
     DEALLOCATE( BMesh1 % Elements )
     CALL FreeQuadrantTree( BMesh1 % RootQuadrant )

     DO i=1,BMesh2 % NumberOfBulkElements
        DEALLOCATE( BMesh2 % Elements(i) % NodeIndexes )
     END DO
     DEALLOCATE( BMesh2 % Elements )
     CALL FreeQuadrantTree( BMesh2 % RootQuadrant )

     DEALLOCATE( BMesh2 % Nodes % x )
     DEALLOCATE( BMesh2 % Nodes % y )
     DEALLOCATE( BMesh2 % Nodes % z )
     DEALLOCATE( BMesh2 % Nodes )

     DEALLOCATE( BMesh1 % Nodes % x )
     DEALLOCATE( BMesh1 % Nodes % y )
     DEALLOCATE( BMesh1 % Nodes % z )
     DEALLOCATE( BMesh1 % Nodes )

     DEALLOCATE( Perm1, Perm2, InvPerm2, BMesh1, BMesh2 )
!------------------------------------------------------------------------------
  END FUNCTION PeriodicProjector
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE WriteMeshToDisk( NewMesh, Path )
!------------------------------------------------------------------------------
    CHARACTER(LEN=*) :: Path
    TYPE(Mesh_t), POINTER :: NewMesh
!------------------------------------------------------------------------------
    INTEGER :: i,j,k,MaxNodes,ElmCode,Parent1,Parent2
!------------------------------------------------------------------------------

    OPEN( 1,FILE=TRIM(Path) // '/mesh.header',STATUS='UNKNOWN' )
    WRITE( 1,'(3i8)' ) NewMesh % NumberOfNodes, &
         NewMesh % NumberOfBulkElements, NewMesh % NumberOfBoundaryElements
    
    WRITE( 1,* ) 2
    MaxNodes = 0
    ElmCode  = 0
    DO i=1,NewMesh % NumberOfBoundaryElements
       k = i + NewMesh % NumberOfBulkElements
       IF ( NewMesh % Elements(k) % TYPE % NumberOfNodes > MaxNodes ) THEN
          ElmCode  = NewMesh % Elements(k) % TYPE % ElementCode
          MaxNodes = NewMesh % Elements(k) % TYPE % NumberOfNodes
       END IF
    END DO
    WRITE( 1,'(2i8)' ) ElmCode,NewMesh % NumberOfBoundaryElements

    MaxNodes = 0
    ElmCode  = 0
    DO i=1,NewMesh % NumberOfBulkElements
       IF ( NewMesh % Elements(i) % TYPE % NumberOfNodes > MaxNodes ) THEN
          ElmCode  = NewMesh % Elements(i) % TYPE % ElementCode
          MaxNodes = NewMesh % Elements(i) % TYPE % NumberOfNodes
       END IF
    END DO
    WRITE( 1,'(2i8)' ) ElmCode,NewMesh % NumberOfBulkElements
    CLOSE(1)

    OPEN( 1,FILE=TRIM(Path) // '/mesh.nodes', STATUS='UNKNOWN' )
    DO i=1,NewMesh % NumberOfNodes
       WRITE(1,'(i6,a,3e23.15)',ADVANCE='NO') i,' -1 ', &
            NewMesh % Nodes % x(i), &
            NewMesh % Nodes % y(i), NewMesh % Nodes % z(i)
       WRITE( 1,* ) ''
    END DO
    CLOSE(1)

    OPEN( 1,FILE=TRIM(Path) // '/mesh.elements', STATUS='UNKNOWN' )
    DO i=1,NewMesh % NumberOfBulkElements
       WRITE(1,'(3i7)',ADVANCE='NO') i, &
            NewMesh % Elements(i) % BodyId, &
            NewMesh % Elements(i) % TYPE % ElementCode
       DO j=1,NewMesh % Elements(i) % TYPE % NumberOfNodes
          WRITE(1,'(i7)', ADVANCE='NO') &
               NewMesh % Elements(i) % NodeIndexes(j)
       END DO
       WRITE(1,*) ''
    END DO
    CLOSE(1)

    OPEN( 1,FILE=TRIM(Path) // '/mesh.boundary', STATUS='UNKNOWN' )
    DO i=1,NewMesh % NumberOfBoundaryElements
       k = i + NewMesh % NumberOfBulkElements
       parent1 = 0
       IF ( ASSOCIATED( NewMesh % Elements(k) % BoundaryInfo % Left ) ) &
          parent1 = NewMesh % Elements(k) % BoundaryInfo % Left % ElementIndex
       parent2 = 0
       IF ( ASSOCIATED( NewMesh % Elements(k) % BoundaryInfo % Right ) ) &
          parent2 = NewMesh % Elements(k) % BoundaryInfo % Right % ElementIndex
       WRITE(1,'(5i7)',ADVANCE='NO') i, &
            NewMesh % Elements(k) % BoundaryInfo % Constraint, Parent1,Parent2,&
            NewMesh % Elements(k) % TYPE % ElementCode
       DO j=1,NewMesh % Elements(k) % TYPE % NumberOfNodes
          WRITE(1,'(i7)', ADVANCE='NO') &
               NewMesh % Elements(k) % NodeIndexes(j)
       END DO
       WRITE(1,*) ''
    END DO
    CLOSE(1)
!------------------------------------------------------------------------------
  END SUBROUTINE WriteMeshToDisk
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
! Generate element edge (faces in 3D) tables for given mesh.
! Currently only for triangles and tetras. If mesh already
! has edges do nothing.
!------------------------------------------------------------------------------
  SUBROUTINE FindMeshEdges( Mesh, FindEdges)
!------------------------------------------------------------------------------
     TYPE(Mesh_t) :: Mesh
     LOGICAL, OPTIONAL :: FindEdges

     LOGICAL :: FindEdges3D

     IF(PRESENT(FindEdges)) THEN
       FindEdges3D = FindEdges
     ELSE
       FindEdges3D = .TRUE.
     END IF

!------------------------------------------------------------------------------

     SELECT CASE( CoordinateSystemDimension() )
        CASE(2)
          IF ( .NOT.ASSOCIATED( Mesh % Edges ) ) CALL FindMeshEdges2D( Mesh )
        CASE(3)
          IF ( .NOT.ASSOCIATED( Mesh % Faces) ) CALL FindMeshFaces3D( Mesh )
          IF(FindEdges3D) THEN
            IF ( .NOT.ASSOCIATED( Mesh % Edges) ) CALL FindMeshEdges3D( Mesh )
          END IF
     END SELECT

     CALL AssignConstraints()

CONTAINS

    SUBROUTINE AssignConstraints()

      INTEGER, POINTER :: FaceInd(:)
      INTEGER :: i,j,k,l,n,nfound
      TYPE(Element_t), POINTER :: Element, Boundary, Face, Faces(:)

      DO i=1,Mesh % NumberOfBoundaryElements
        Boundary => Mesh % Elements(Mesh % NumberOfBulkElements+i)

        Element  => Boundary % BoundaryInfo % Left
        IF (.NOT.ASSOCIATED(Element) ) &
          Element  => Boundary % BoundaryInfo % Right
        IF (.NOT.ASSOCIATED(Element) ) CYCLE

        SELECT CASE(Boundary % Type % Dimension)
        CASE(1)
          Faces   => Mesh % Edges
          FaceInd => Element % EdgeIndexes
        CASE(2)
          Faces   => Mesh % Faces
          FaceInd => Element % FaceIndexes
        CASE DEFAULT
          Faces => Null()
          FaceInd => Null()
        END SELECT

        IF ( .NOT. ASSOCIATED(Faces) .OR. .NOT. ASSOCIATED(FaceInd) ) CYCLE

        DO j=1,SIZE(FaceInd)
          Face => Faces(FaceInd(j))
          IF ( .NOT.ASSOCIATED(Face % Type,Boundary % Type) ) CYCLE

          n = Boundary % Type % NumberOfNodes
          nfound = 0
          DO k=1,n
            DO l=1,n
              IF ( Boundary % NodeIndexes(k)==Face % NodeIndexes(l) ) &
                nfound = nfound+1
            END DO
          END DO
          IF ( nfound==n ) THEN
            Face % BoundaryInfo = Boundary % BoundaryInfo; EXIT
          END IF
        END DO
      END DO
    END SUBROUTINE AssignConstraints
!------------------------------------------------------------------------------
  END SUBROUTINE FindMeshEdges
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
! 2D mesh edges.
!------------------------------------------------------------------------------
  SUBROUTINE FindMeshEdges2D( Mesh )
!------------------------------------------------------------------------------
    TYPE(Mesh_t) :: Mesh
!------------------------------------------------------------------------------
    TYPE HashEntry_t
       INTEGER :: Node,Edge
       TYPE(HashEntry_t), POINTER :: Next
    END TYPE HashEntry_t

    TYPE HashTable_t
       TYPE(HashEntry_t), POINTER :: Head
    END TYPE HashTable_t
     
    TYPE(HashTable_t), ALLOCATABLE :: HashTable(:)
    TYPE(HashEntry_t), POINTER :: HashPtr, HashPtr1

    TYPE(Element_t), POINTER :: Element, Edges(:)

    LOGICAL :: Found
    INTEGER :: i,j,k,n,NofEdges,Edge,Swap,Node1,Node2,istat,Degree
!------------------------------------------------------------------------------
!
!   Initialize:
!   -----------
    CALL AllocateVector( Mesh % Edges, 4*Mesh % NumberOfBulkElements )
    Edges => Mesh % Edges

    DO i=1,Mesh % NumberOfBulkElements
       Element => Mesh % Elements(i)

       SELECT CASE( Element % TYPE % ElementCode / 100 )
         CASE(3)
            n = 3
         CASE(4)
            n = 4
       END SELECT

       IF ( .NOT. ASSOCIATED( Element % EdgeIndexes ) ) &
          CALL AllocateVector( Element % EdgeIndexes, n )
       Element % EdgeIndexes = 0
    END DO

    ALLOCATE( HashTable( Mesh % NumberOfNodes ) )
    DO i=1,Mesh % NumberOfNodes
       NULLIFY( HashTable(i) % Head )
    END DO
!------------------------------------------------------------------------------

!   Loop over elements:
!   -------------------
    NofEdges = 0
    DO i=1,Mesh % NumberOfBulkElements
       Element => Mesh % Elements(i)

       SELECT CASE( Element % TYPE % ElementCode / 100 )
         CASE(3)
            n = 3
         CASE(4)
            n = 4
       END SELECT

!      Loop over every edge of every element:
!      --------------------------------------
       DO k=1,n
!         We use MIN(Node1,Node2) as the hash table key:
!         ----------------------------------------------
          Node1 = Element % NodeIndexes(k)
          IF ( k<n ) THEN
             Node2 = Element % NodeIndexes(k+1)
          ELSE
             Node2 = Element % NodeIndexes(1)
          END IF

          IF ( Node2 < Node1 ) THEN
             Swap  = Node1
             Node1 = Node2
             Node2 = Swap
          END IF

!         Look the edge from the hash table:
!         ----------------------------------
          HashPtr => HashTable(Node1) % Head
          Found = .FALSE.         
          DO WHILE( ASSOCIATED( HashPtr ) )
             IF ( HashPtr % Node == Node2 ) THEN
                Found = .TRUE.
                Edge = HashPtr % Edge
                EXIT
             END IF
             HashPtr => HashPtr % Next
          END DO

!         Exisiting edge, update structures:
!         ----------------------------------
          IF ( Found ) THEN
             Element % EdgeIndexes(k) = Edge
             Edges(Edge) % BoundaryInfo % Right => Element
          ELSE

!            Edge not yet there, create:
!            ---------------------------
             NofEdges = NofEdges + 1
             Edge = NofEdges

             Degree = Element % TYPE % BasisFunctionDegree

             Edges(Edge) % ElementIndex = Edge
             CALL AllocateVector( Edges(Edge) % NodeIndexes, Degree+1)
             ALLOCATE( Edges(Edge) % BoundaryInfo )
             Edges(Edge) % TYPE => GetElementType( 201+Degree, .FALSE. )

             Edges(Edge) % NodeIndexes(1) = Element % NodeIndexes(k)
             IF ( k < n ) THEN
                Edges(Edge) % NodeIndexes(2) = Element % NodeIndexes(k+1)
             ELSE
                Edges(Edge) % NodeIndexes(2) = Element % NodeIndexes(1)
             END IF

             DO j=2,Degree
                Edges(Edge) % NodeIndexes(j+1) = Element % NodeIndexes(k+n+j-2)
             END DO
             
             ! Create P element definitions if needed
             IF ( ASSOCIATED( Element % PDefs ) ) THEN
               CALL AllocatePDefinitions(Edges(Edge))
               Edges(Edge) % PDefs % P = 0
             ELSE
               NULLIFY( Edges(Edge) % PDefs )
             END IF

             Edges(Edge) % NDofs = 0
             IF (Element % NDOFs /= 0 ) &
                Edges(Edge) % NDOFs  = Edges(Edge) % TYPE % NumberOfNodes
             Edges(Edge) % BDOFs  = 0
             Edges(Edge) % DGDOFs = 0
             NULLIFY( Edges(Edge) % EdgeIndexes )
             NULLIFY( Edges(Edge) % FaceIndexes )

             Element % EdgeIndexes(k) = Edge

             Edges(Edge) % BoundaryInfo % Left => Element
             NULLIFY( Edges(Edge) % BoundaryInfo % Right )
              
!            Update the hash table:
!            ----------------------
             ALLOCATE( HashPtr )
             HashPtr % Edge = Edge
             HashPtr % Node = Node2
             HashPtr % Next => HashTable(Node1) % Head
             HashTable(Node1) % Head => HashPtr
          END IF
       END DO
    END DO

    Mesh % NumberOfEdges = NofEdges

!   Delete the hash table:
!   ----------------------
    DO i=1,Mesh % NumberOfNodes
       HashPtr => HashTable(i) % Head
       DO WHILE( ASSOCIATED(HashPtr) )
          HashPtr1 => HashPtr % Next
          DEALLOCATE( HashPtr )
          HashPtr  => HashPtr1
       END DO
    END DO
    DEALLOCATE( HashTable )
!------------------------------------------------------------------------------
  END SUBROUTINE FindMeshEdges2D
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
! 3D mesh faces.
!------------------------------------------------------------------------------
  SUBROUTINE FindMeshFaces3D( Mesh )
    USE PElementMaps, ONLY : GetElementFaceMap
    USE PElementBase, ONLY : isPTetra

    IMPLICIT NONE
!------------------------------------------------------------------------------
    TYPE(Mesh_t) :: Mesh
!------------------------------------------------------------------------------
    TYPE HashEntry_t
       INTEGER :: Node1,Node2,Face
       TYPE(HashEntry_t), POINTER :: Next
    END TYPE HashEntry_t

    TYPE HashTable_t
       TYPE(HashEntry_t), POINTER :: Head
    END TYPE HashTable_t
    
    TYPE(HashTable_t), ALLOCATABLE :: HashTable(:)
    TYPE(HashEntry_t), POINTER :: HashPtr, HashPtr1

    LOGICAL :: Found
    INTEGER :: n1,n2,n3,n4
    INTEGER :: i,j,k,n,NofFaces,Face,Swap,Node1,Node2,Node3,istat,Degree
     
    TYPE(Element_t), POINTER :: Element, Faces(:)

    INTEGER, POINTER :: FaceMap(:,:)
    INTEGER, TARGET  :: TetraFaceMap(4,6), BrickFaceMap(6,9), &
         WedgeFaceMap(5,4), PyramidFaceMap(5,8)
    
    INTEGER :: nf(4)
!------------------------------------------------------------------------------
    
    TetraFaceMap(1,:) = (/ 1, 2, 3, 5, 6, 7 /)
    TetraFaceMap(2,:) = (/ 1, 2, 4, 5, 9, 8 /)
    TetraFaceMap(3,:) = (/ 2, 3, 4, 6,10, 9 /)
    TetraFaceMap(4,:) = (/ 3, 1, 4, 7, 8,10 /)

    WedgeFaceMap(1,:) = (/ 1, 2, 3,-1 /)
    WedgeFaceMap(2,:) = (/ 4, 5, 6,-1 /)
    WedgeFaceMap(3,:) = (/ 1, 2, 5, 4 /)
    WedgeFaceMap(4,:) = (/ 3, 2, 5, 6 /)
    WedgeFaceMap(5,:) = (/ 3, 1, 4, 6 /)

    PyramidFaceMap(1,:) = (/ 1, 2, 3, 4,  6,  7,  8,  9 /)
    PyramidFaceMap(2,:) = (/ 1, 2, 5, 6, 11, 10, -1, -1 /)
    PyramidFaceMap(3,:) = (/ 2, 3, 5, 7, 12, 11, -1, -1 /)
    PyramidFaceMap(4,:) = (/ 3, 4, 5, 8, 13, 12, -1, -1 /)
    PyramidFaceMap(5,:) = (/ 4, 1, 5, 9, 10, 13, -1, -1 /)

    BrickFaceMap(1,:) = (/ 1, 2, 3, 4,  9, 10, 11, 12, 25 /)
    BrickFaceMap(2,:) = (/ 5, 6, 7, 8, 17, 18, 19, 20, 26 /)
    BrickFaceMap(3,:) = (/ 1, 2, 6, 5,  9, 14, 17, 13, 21 /)
    BrickFaceMap(4,:) = (/ 2, 3, 7, 6, 10, 15, 17, 14, 22 /)
    BrickFaceMap(5,:) = (/ 3, 4, 8, 7, 11, 16, 19, 15, 23 /)
    BrickFaceMap(6,:) = (/ 4, 1, 5, 8, 12, 13, 20, 16, 24 /)

!
!   Initialize:
!   -----------
    CALL AllocateVector( Mesh % Faces, 6*Mesh % NumberOfBulkElements, 'FindMeshFaces3D' )
    Faces => Mesh % Faces

    DO i=1,Mesh % NumberOfBulkElements
       Element => Mesh % Elements(i)
       IF ( .NOT. ASSOCIATED( Element % FaceIndexes ) ) &
          CALL AllocateVector(Element % FaceIndexes, 6)
       Element % FaceIndexes = 0
    END DO

    ALLOCATE( HashTable( Mesh % NumberOfNodes ) )
    DO i=1,Mesh % NumberOfNodes
       NULLIFY( HashTable(i) % Head )
    END DO
!------------------------------------------------------------------------------

!   Loop over elements:
!   -------------------
    NofFaces = 0
    DO i=1,Mesh % NumberOfBulkElements
       Element => Mesh % Elements(i)

       ! For P elements mappings are different
       IF ( ASSOCIATED(Element % PDefs) ) THEN
          CALL GetElementFaceMap(Element, FaceMap)
          n = Element % TYPE % NumberOfFaces
       ELSE
          SELECT CASE( Element % TYPE % ElementCode / 100 )
          CASE(5)
             n = 4
             FaceMap => TetraFaceMap
          CASE(6)
             n = 5
             FaceMap => PyramidFaceMap
          CASE(7)
             n = 5 
             FaceMap => WedgeFaceMap
          CASE(8)
             n = 6
             FaceMap => BrickFaceMap
          CASE DEFAULT
             CYCLE
             ! WRITE(Message,*) 'Element type',Element % Type % ElementCode,'not implemented.' 
             ! CALL Fatal('FindMeshFaces',Message)
          END SELECT
       END IF
 
!      Loop over every face of every element:
!      --------------------------------------
       DO k=1,n
          
          
!         We use MIN(Node1,Node2,Node3) as the hash table key:
!         ---------------------------------------------------
          SELECT CASE( Element % TYPE % ElementCode / 100 )
             CASE(5)
!
!               Tetras:
!               =======
                nf(1:3) = Element % NodeIndexes(FaceMap(k,1:3))
                CALL sort( 3, nf )

             CASE(6)
!
!               Pyramids:
!               =========
                IF ( k == 1 ) THEN
                   nf(1:4) = Element % NodeIndexes(FaceMap(k,1:4))
                   CALL sort( 4, nf )
                ELSE
                   nf(1:3) = Element % NodeIndexes(FaceMap(k,1:3))
                   CALL sort( 3, nf )
                END IF

             CASE(7)
!
!               Wedges:
!               =======
                IF ( k <= 2 ) THEN
                   nf(1:3) = Element % NodeIndexes(FaceMap(k,1:3))
                   CALL sort( 3, nf )
                ELSE
                   nf(1:4) = Element % NodeIndexes(FaceMap(k,1:4))
                   CALL sort( 4, nf )
                END IF
                
             CASE(8)
!
!               Bricks:
!               =======
                nf(1:4) = Element % NodeIndexes(FaceMap(k,1:4))
                CALL sort( 4, nf )

             CASE DEFAULT
                WRITE(Message,*) 'Element type',Element % TYPE % ElementCode,'not implemented.' 
                CALL Fatal('FindMeshFaces',Message)
          END SELECT

          Node1 = nf(1)
          Node2 = nf(2)
          Node3 = nf(3)
          
!         Look the face from the hash table:
!         ----------------------------------
          HashPtr => HashTable(Node1) % Head
          Found = .FALSE.
          DO WHILE( ASSOCIATED( HashPtr ) )
             IF ( HashPtr % Node1 == Node2 .AND. HashPtr % Node2 == Node3) THEN
                Found = .TRUE.
                Face = HashPtr % Face
                EXIT
             END IF
             HashPtr => HashPtr % Next
          END DO

!         Exisiting face, update structures:
!         ----------------------------------
          IF ( Found ) THEN       
             Element % FaceIndexes(k) = Face
             Faces(Face) % BoundaryInfo % Right => Element
          ELSE

!            Face not yet there, create:
!            ---------------------------
             NofFaces = NofFaces + 1
             Face = NofFaces
             Faces(Face) % ElementIndex = Face

             Degree = Element % TYPE % BasisFunctionDegree
             SELECT CASE( Element % TYPE % ElementCode / 100 )
                CASE(5)
!
!               for tetras:
!               -----------
                SELECT CASE( Degree ) 
                   CASE(1)
                   n1 = 3
                   CASE(2)
                   n1 = 6
                   CASE(3)
                   n1 = 10
                END SELECT
                n1 = 3
                
                Faces(Face) % TYPE => GetElementType( 300+n1, .FALSE. )

                CASE(6)

!               Pyramids ( only 605 supported )
!               -------------------------------
                IF ( k == 1 ) THEN
                   n1 = 4
                   Faces(Face) % TYPE => GetElementType( 400+n1, .FALSE. )
                ELSE
                   n1 = 3
                   Faces(Face) % TYPE => GetElementType( 300+n1, .FALSE. )
                END IF
                
                CASE(7)

!               for wedges, only 706 supported:
!               -------------------------------
                IF ( k <= 2 ) THEN
                   n1 = 3
                   Faces(Face) % TYPE => GetElementType( 303, .FALSE. )
                ELSE
                   n1 = 4
                   Faces(Face) % TYPE => GetElementType( 404, .FALSE. )
                END IF

            
                CASE(8)
!
!               for bricks:
!               -----------
                SELECT CASE( Element % TYPE % NumberOfNodes ) 
                   CASE(8)
                   n1 = 4
                   CASE(20)
                   n1 = 8
                   CASE(27)
                   n1 = 9
                END SELECT

                Faces(Face) % TYPE => GetElementType( 400+n1, .FALSE.)

                CASE DEFAULT
                   WRITE(Message,*) 'Element type',Element % TYPE % ElementCode,'not implemented.' 
                   CALL Fatal('FindMeshFaces',Message)

             END SELECT

             ! Allocate p structures for p elements
             IF ( ASSOCIATED( Element % PDefs ) ) THEN
                CALL AllocatePDefinitions(Faces(Face))
                Faces(Face) % PDefs % P = 0
             ELSE
               NULLIFY( Faces(Face) % PDefs )
             END IF
             
             Faces(Face) % NDOFs  = 0
             IF (Element % NDOFs /= 0 ) &
                Faces(Face) % NDOFs  = Faces(Face) % TYPE % NumberOfNodes
             Faces(Face) % BDOFs  = 0
             Faces(Face) % DGDOFs = 0
             Faces(Face) % EdgeIndexes => Null()
             Faces(Face) % FaceIndexes => Null()

             CALL AllocateVector( Faces(Face) % NodeIndexes,n1 )
             DO n2=1,n1
                Faces(Face) % NodeIndexes(n2) = &
                         Element % NodeIndexes(FaceMap(k,n2)) 
             END DO

             Element % FaceIndexes(k) = Face

             ALLOCATE( Faces(Face) % BoundaryInfo )
             Faces(Face) % BoundaryInfo % Left => Element
             NULLIFY( Faces(Face) % BoundaryInfo % Right )
              
!            Update the hash table:
!            ----------------------
             ALLOCATE( HashPtr )
             HashPtr % Face = Face
             HashPtr % Node1 = Node2
             HashPtr % Node2 = Node3
             HashPtr % Next => HashTable(Node1) % Head
             HashTable(Node1) % Head => HashPtr
          END IF
       END DO
    END DO

    Mesh % NumberOfFaces = NofFaces

!   Delete the hash table:
!   ----------------------
    DO i=1,Mesh % NumberOfNodes
       HashPtr => HashTable(i) % Head
       DO WHILE( ASSOCIATED(HashPtr) )
          HashPtr1 => HashPtr % Next
          DEALLOCATE( HashPtr )
          HashPtr  => HashPtr1
       END DO
    END DO
    DEALLOCATE( HashTable )
!------------------------------------------------------------------------------
  END SUBROUTINE FindMeshFaces3D
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
! 3D mesh edges.
!------------------------------------------------------------------------------
  SUBROUTINE FindMeshEdges3D( Mesh )
    USE PElementMaps, ONLY : GetElementEdgeMap, GetElementFaceEdgeMap
    USE PElementBase, ONLY : isPPyramid

    IMPLICIT NONE
!------------------------------------------------------------------------------
    TYPE(Mesh_t) :: Mesh
!------------------------------------------------------------------------------
    TYPE HashEntry_t
       INTEGER :: Node1,Edge
       TYPE(HashEntry_t), POINTER :: Next
    END TYPE HashEntry_t

    TYPE HashTable_t
       TYPE(HashEntry_t), POINTER :: Head
    END TYPE HashTable_t
    
    TYPE(HashTable_t), ALLOCATABLE :: HashTable(:)
    TYPE(HashEntry_t), POINTER :: HashPtr, HashPtr1

    LOGICAL :: Found
    INTEGER :: n1,n2
    INTEGER :: i,j,k,n,NofEdges,Edge,Node1,Node2,istat,Degree,ii,jj
     
    TYPE(Element_t), POINTER :: Element, Edges(:), Face

    INTEGER, POINTER :: EdgeMap(:,:), FaceEdgeMap(:,:)
    INTEGER, TARGET  :: TetraEdgeMap(6,3), BrickEdgeMap(12,3), TetraFaceMap(4,6), &
      WedgeEdgeMap(9,3), PyramidEdgeMap(8,3), TetraFaceEdgeMap(4,3), &
      BrickFaceEdgeMap(8,4), WedgeFaceEdgeMap(6,4), PyramidFaceEdgeMap(5,4)
!------------------------------------------------------------------------------
    TetraFaceMap(1,:) = (/ 1, 2, 3, 5, 6, 7 /)
    TetraFaceMap(2,:) = (/ 1, 2, 4, 5, 9, 8 /)
    TetraFaceMap(3,:) = (/ 2, 3, 4, 6,10, 9 /)
    TetraFaceMap(4,:) = (/ 3, 1, 4, 7, 8,10 /)

    TetraFaceEdgeMap(1,:) = (/ 1,2,3 /)
    TetraFaceEdgeMap(2,:) = (/ 1,5,4 /)
    TetraFaceEdgeMap(3,:) = (/ 2,6,5 /)
    TetraFaceEdgeMap(4,:) = (/ 3,4,6 /)

    TetraEdgeMap(1,:) = (/ 1,2,5 /)
    TetraEdgeMap(2,:) = (/ 2,3,6 /)
    TetraEdgeMap(3,:) = (/ 3,1,7 /)
    TetraEdgeMap(4,:) = (/ 1,4,8 /)
    TetraEdgeMap(5,:) = (/ 2,4,9 /)
    TetraEdgeMap(6,:) = (/ 3,4,10 /)

    PyramidEdgeMap(1,:) = (/ 1,2,1 /)
    PyramidEdgeMap(2,:) = (/ 2,3,1 /)
    PyramidEdgeMap(3,:) = (/ 3,4,1 /)
    PyramidEdgeMap(4,:) = (/ 4,1,1 /)
    PyramidEdgeMap(5,:) = (/ 1,5,1 /)
    PyramidEdgeMap(6,:) = (/ 2,5,1 /)
    PyramidEdgeMap(7,:) = (/ 3,5,1 /)
    PyramidEdgeMap(8,:) = (/ 4,5,1 /)

    PyramidFaceEdgeMap(1,:) = (/ 1,2,3,4 /)
    PyramidFaceEdgeMap(2,:) = (/ 1,6,5,0 /)
    PyramidFaceEdgeMap(3,:) = (/ 2,7,6,0 /)
    PyramidFaceEdgeMap(4,:) = (/ 3,8,7,0 /)
    PyramidFaceEdgeMap(5,:) = (/ 4,5,8,0 /)

    WedgeEdgeMap(1,:) = (/ 1, 2,1 /)
    WedgeEdgeMap(2,:) = (/ 2, 3,1 /)
    WedgeEdgeMap(3,:) = (/ 1, 3,1 /)
    WedgeEdgeMap(4,:) = (/ 4, 5,1 /)
    WedgeEdgeMap(5,:) = (/ 5, 6,1 /)
    WedgeEdgeMap(6,:) = (/ 6, 4,1 /)
    WedgeEdgeMap(7,:) = (/ 1, 4,1 /)
    WedgeEdgeMap(8,:) = (/ 2, 5,1 /)
    WedgeEdgeMap(9,:) = (/ 3, 6,1 /)

    WedgeFaceEdgeMap(1,:) = (/ 1,2,3,0 /)
    WedgeFaceEdgeMap(2,:) = (/ 4,5,6,0 /)
    WedgeFaceEdgeMap(3,:) = (/ 1,8,4,7 /)
    WedgeFaceEdgeMap(4,:) = (/ 2,9,5,8 /)
    WedgeFaceEdgeMap(5,:) = (/ 3,7,6,9 /)

    BrickEdgeMap(1,:) = (/ 1, 2,  9 /)
    BrickEdgeMap(2,:) = (/ 2, 3,  10 /)
    BrickEdgeMap(3,:) = (/ 4, 3,  11 /)
    BrickEdgeMap(4,:) = (/ 1, 4,  12 /)
    BrickEdgeMap(5,:) = (/ 5, 6,  13 /)
    BrickEdgeMap(6,:) = (/ 6, 7,  14 /)
    BrickEdgeMap(7,:) = (/ 8, 7,  15 /)
    BrickEdgeMap(8,:) = (/ 5, 8,  16 /)
    BrickEdgeMap(9,:) = (/ 1, 5,  17 /)
    BrickEdgeMap(10,:) = (/ 2, 6, 18 /)
    BrickEdgeMap(11,:) = (/ 3, 7, 19 /)
    BrickEdgeMap(12,:) = (/ 4, 8, 20 /)

    BrickFaceEdgeMap(1,:) = (/ 1,2,3,4   /)
    BrickFaceEdgeMap(2,:) = (/ 5,6,7,8   /)    
    BrickFaceEdgeMap(3,:) = (/ 1,10,5,9  /)
    BrickFaceEdgeMap(4,:) = (/ 2,11,6,10 /)
    BrickFaceEdgeMap(5,:) = (/ 3,12,7,11 /)
    BrickFaceEdgeMap(6,:) = (/ 4,9,8,12  /)

!
!   Initialize:
!   -----------
    CALL AllocateVector( Mesh % Edges, 12*Mesh % NumberOfBulkElements )
    Edges => Mesh % Edges

    DO i=1,Mesh % NumberOfBulkElements
       Element => Mesh % Elements(i)
       IF ( .NOT. ASSOCIATED( Element % EdgeIndexes ) ) &
          CALL AllocateVector(Element % EdgeIndexes, 12 )
       Element % EdgeIndexes = 0
    END DO

    ALLOCATE( HashTable( Mesh % NumberOfNodes ) )
    DO i=1,Mesh % NumberOfNodes
       NULLIFY( HashTable(i) % Head )
    END DO
!------------------------------------------------------------------------------

!   Loop over elements:
!   -------------------
    NofEdges = 0
    DO i=1,Mesh % NumberOfBulkElements
       Element => Mesh % Elements(i)

       ! For P elements mappings are different
       IF ( ASSOCIATED(Element % PDefs) ) THEN
          CALL GetElementEdgeMap( Element, EdgeMap )
          CALL GetElementFaceEdgeMap( Element, FaceEdgeMap ) 
          n = Element % TYPE % NumberOfEdges
       ELSE 
          SELECT CASE( Element % TYPE % ElementCode / 100 )
          CASE(5)
             n = 6
             EdgeMap => TetraEdgeMap
             FaceEdgeMap => TetraFaceEdgeMap
          CASE(6)
             n = 8
             EdgeMap => PyramidEdgeMap
             FaceEdgeMap => PyramidFaceEdgeMap
          CASE(7)
             n = 9
             EdgeMap => WedgeEdgeMap
             FaceEdgeMap => WedgeFaceEdgeMap
          CASE(8)
             n = 12
             EdgeMap => BrickEdgeMap
             FaceEdgeMap => BrickFaceEdgeMap
          CASE DEFAULT
             CYCLE
             WRITE(Message,*) 'Element type',Element % TYPE % ElementCode,'not implemented.' 
             CALL Fatal('FindMeshEdges',Message)
          END SELECT
       END IF

!      Loop over every edge of every element:
!      --------------------------------------
       DO k=1,n

!         Use MIN(Node1,Node2) as key to hash table:
!         ------------------------------------------
          n1 = Element % NodeIndexes(EdgeMap(k,1))
          n2 = Element % NodeIndexes(EdgeMap(k,2))
          IF ( n1 < n2 ) THEN
             Node1 = n1
             Node2 = n2
          ELSE
             Node1 = n2
             Node2 = n1
          END IF
!
!         Look the edge from the hash table:
!         ----------------------------------
          HashPtr => HashTable(Node1) % Head
          Found = .FALSE.
          DO WHILE( ASSOCIATED( HashPtr ) )
             IF ( HashPtr % Node1 == Node2 ) THEN
                Found = .TRUE.
                Edge = HashPtr % Edge
                EXIT
             END IF
             HashPtr => HashPtr % Next
          END DO
!
!         Existing edge, update structures:
!         ---------------------------------
          IF ( Found ) THEN
             Element % EdgeIndexes(k) = Edge

             ! Mark edge as an edge of pydamid square face 
             IF (isPPyramid(Element) .AND. k < 5) THEN
                Edges(Edge) % PDefs % pyramidQuadEdge = .TRUE.
             END IF

             IF ( ASSOCIATED(Mesh % Faces) ) THEN
               DO ii=1,Element % TYPE % NumberOfFaces
                 Face => Mesh % Faces(Element % FaceIndexes(ii))
                 IF ( .NOT. ASSOCIATED(Face % EdgeIndexes) ) THEN
                   ALLOCATE(Face % EdgeIndexes(Face % TYPE % NumberOfEdges))
                   Face % EdgeIndexes = 0
                 END IF
                 DO jj=1,Face % TYPE % NumberOfEdges
                    IF (FaceEdgeMap(ii,jj) == k) THEN
                       Face % EdgeIndexes(jj) = Edge
                       IF ( .NOT. ASSOCIATED(Edges(Edge) % BoundaryInfo % Left)) THEN
                          Edges(Edge) % BoundaryInfo % Left => Face
                       ELSE
                          Edges(Edge) % BoundaryInfo % Right => Face
                       END IF
                       EXIT
                    END IF
                 END DO
               END DO
             END IF
          ELSE

!            Edge not yet there, create:
!            ---------------------------
             NofEdges = NofEdges + 1
             Edge = NofEdges
             Edges(Edge) % ElementIndex = Edge
             Degree = Element % TYPE % BasisFunctionDegree

!            Edge is always a line segment with deg+1 nodes:
!            -----------------------------------------------
             Edges(Edge) % TYPE => GetElementType( 201 + degree, .FALSE.)

             Edges(Edge) % NDOFs  = 0
             IF (Element % NDOFs /= 0 ) &
                Edges(Edge) % NDOFs  = Edges(Edge) % TYPE % NumberOfNodes
             Edges(Edge) % BDOFs  = 0
             Edges(Edge) % DGDOFs = 0
             Edges(Edge) % EdgeIndexes => Null()
             Edges(Edge) % FaceIndexes => Null()

             CALL AllocateVector( Edges(Edge) % NodeIndexes, degree + 1 )
             DO n2=1,degree+1
               Edges(Edge) % NodeIndexes(n2) = &
                    Element % NodeIndexes(EdgeMap(k,n2))
             END DO

             Element % EdgeIndexes(k) = Edge
             ALLOCATE( Edges(Edge) % BoundaryInfo )
             Edges(Edge) % BoundaryInfo % Left  => Null()
             Edges(Edge) % BoundaryInfo % Right => Null()

             ! Allocate P element definitions 
             IF ( ASSOCIATED( Element % PDefs ) ) THEN
                CALL AllocatePDefinitions(Edges(Edge))
             
                Edges(Edge) % PDefs % P = 0
                Edges(Edge) % PDefs % pyramidQuadEdge = .FALSE.
                ! Here mark edge as edge of pyramid if needed (or set as not)
                IF (isPPyramid(Element) .AND. k < 5) THEN
                   Edges(Edge) % PDefs % pyramidQuadEdge = .TRUE.
                END IF
             ELSE
                NULLIFY( Edges(Edge) % PDefs )
             END IF

             IF ( ASSOCIATED(Mesh % Faces) ) THEN
               DO ii=1,Element % TYPE % NumberOfFaces
                 Face => Mesh % Faces( Element % FaceIndexes(ii) )
                 IF ( .NOT. ASSOCIATED(Face % EdgeIndexes) ) THEN
                    ALLOCATE( Face % EdgeIndexes( Face % TYPE % NumberOfEdges ) )
                    Face % EdgeIndexes = 0
                 END IF
                 DO jj=1,Face % TYPE % NumberOfEdges
                    IF ( FaceEdgeMap(ii,jj) == k ) THEN
                       Face % EdgeIndexes(jj) = Edge
                       IF (.NOT.ASSOCIATED( Edges(Edge) % BoundaryInfo % Left)) THEN
                          Edges(Edge) % BoundaryInfo % Left => Face
                       ELSE
                          Edges(Edge) % BoundaryInfo % Right => Face
                       END IF
                    END IF
                 END DO
               END DO
             END IF

!            Update the hash table:
!            ----------------------
             ALLOCATE( HashPtr )
             HashPtr % Edge = Edge
             HashPtr % Node1 = Node2
             HashPtr % Next => HashTable(Node1) % Head
             HashTable(Node1) % Head => HashPtr
          END IF
       END DO
    END DO

    Mesh % NumberOfEdges = NofEdges

!   Delete the hash table:
!   ----------------------
    DO i=1,Mesh % NumberOfNodes
       HashPtr => HashTable(i) % Head
       DO WHILE( ASSOCIATED(HashPtr) )
          HashPtr1 => HashPtr % Next
          DEALLOCATE( HashPtr )
          HashPtr  => HashPtr1
       END DO
    END DO
    DEALLOCATE( HashTable )

    IF (ASSOCIATED(Mesh % Faces)) CALL FixFaceEdges()

CONTAINS 

    SUBROUTINE FixFaceEdges()

      INTEGER :: i,j,k,n,swap,edgeind(4),i1(2),i2(2)

      DO i=1,Mesh % NumberOfFaces
        Face => Mesh % Faces(i)
        n = Face % TYPE % NumberOfEdges
        Edgeind(1:n) = Face % EdgeIndexes(1:n)
        DO j=1,n
          i1 = Mesh % Edges(Edgeind(j)) % NodeIndexes(1:2)
          IF ( i1(1)>i1(2) ) THEN
            swap=i1(1)
            i1(1)=i1(2)
            i1(2)=swap
          END IF
          DO k=1,n
            i2(1) = k
            i2(2) = k+1
            IF ( i2(2)>n ) i2(2)=1
            i2 = Face % NodeIndexes(i2)
            IF ( i2(1)>i2(2) ) THEN
              swap=i2(1)
              i2(1)=i2(2)
              i2(2)=swap
            END IF
            IF ( ALL(i1 == i2) ) THEN
              Face % EdgeIndexes(k) = edgeind(j)
              EXIT
            END IF
          END DO
        END DO
      END DO
    END SUBROUTINE FixFaceEdges
!------------------------------------------------------------------------------
  END SUBROUTINE FindMeshEdges3D
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE FindNeighbourNodes( Mesh,Direction,Neighbours,EndNeighbours)
!------------------------------------------------------------------------------
! Finds neigbours of the nodes in given direction.
! The algorithm finds the neighbour that within 45 degrees of the 
! given direction has the smallest distance.
!------------------------------------------------------------------------------

  TYPE(Mesh_t) , POINTER :: Mesh 
  REAL(KIND=dp) :: Direction(:)
  INTEGER :: Neighbours(:)
  INTEGER, OPTIONAL :: EndNeighbours(:)

  TYPE(Nodes_t) :: ElementNodes
  TYPE(Element_t),POINTER :: CurrentElement
  REAL(KIND=dp), POINTER :: Distances(:)
  REAL(KIND=dp) :: rn(3), rs(3), ss, sn
  INTEGER, POINTER :: NodeIndexes(:)
  INTEGER :: i,j,k,n,t,DIM,istat

  IF(SIZE(Neighbours) < Mesh % NumberOfNodes) THEN
    CALL Warn('FindNeigbourNodes','SIZE of Neigbours should equal Number of Nodes!')
    RETURN
  END IF


  IF(PRESENT(EndNeighbours)) THEN
    IF(SIZE(EndNeighbours) < Mesh % NumberOfNodes) THEN
      CALL Warn('FindNeigbourNodes','SIZE of EndNeigbours should equal Number of Nodes!')
      RETURN
    END IF
  END IF


  DIM = CoordinateSystemDimension()
  N = Mesh % MaxElementNodes

  CALL AllocateVector( ElementNodes % x, n )
  CALL AllocateVector( ElementNodes % y, n )
  CALL AllocateVector( ElementNodes % z, n )
  CALL AllocateVector( Distances, Mesh % NumberOfNodes )

  Neighbours = 0
  Distances = HUGE(Distances)
 
  rn(1:DIM) = Direction(1:DIM)
  ss = SQRT(SUM(rn(1:DIM)**2))
  rn = rn / ss

  DO t=1,Mesh % NumberOfBulkElements

    CurrentElement => Mesh % Elements(t)
    n = CurrentElement % TYPE % NumberOfNodes
    NodeIndexes => CurrentElement % NodeIndexes
  
    ElementNodes % x(1:n) = Mesh % Nodes % x(NodeIndexes(1:n))
    ElementNodes % y(1:n) = Mesh % Nodes % y(NodeIndexes(1:n))
    IF(DIM == 3) THEN
      ElementNodes % z(1:n) = Mesh % Nodes % z(NodeIndexes(1:n))
    END IF


    DO i=1,n
      DO j=i+1,n
        rs(1) = ElementNodes % x(j) - ElementNodes % x(i)
        rs(2) = ElementNodes % y(j) - ElementNodes % y(i)
        IF (DIM == 3) THEN
          rs(3) = ElementNodes % z(j) - ElementNodes % z(i)
        END IF
        
        ss = SQRT(SUM(rs(1:DIM)**2))
        sn = SUM(rs(1:DIM)*rn(1:DIM))

        IF(ss < SQRT(2.0) * ABS(sn)) THEN
          IF(sn > 0) THEN
            IF(ss < Distances(NodeIndexes(i))) THEN
              Distances(NodeIndexes(i)) = ss
              Neighbours(NodeIndexes(i)) = NodeIndexes(j)
            END IF
          ELSE
            IF(ss < Distances(NodeIndexes(j))) THEN
              Distances(NodeIndexes(j)) = ss
              Neighbours(NodeIndexes(j)) = NodeIndexes(i)
            END IF
          END IF
        END IF
      END DO
    END DO
  END DO

  ! This loop finds the final neighbour in the end of the chain 
  IF(PRESENT(EndNeighbours)) THEN
    EndNeighbours = Neighbours

    DO t=1,Mesh%NumberOfNodes
      j = Neighbours(t)
      DO WHILE(j /= 0)
        EndNeighbours(t) = j
        j = Neighbours(j)
      END DO
    END DO
  END IF
  DEALLOCATE(ElementNodes % x, ElementNodes % y, ElementNodes % z, Distances)
!------------------------------------------------------------------------------
END SUBROUTINE FindNeighbourNodes
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE UpdateSolverMesh( Solver, Mesh )
!------------------------------------------------------------------------------
     TYPE( Mesh_t ), POINTER :: Mesh
     TYPE( Solver_t ), TARGET :: Solver
!------------------------------------------------------------------------------
     INTEGER :: i,j,k,n,n1,n2,DOFs
     LOGICAL :: Found, OptimizeBandwidth
     TYPE(Matrix_t), POINTER   :: Matrix
     REAL(KIND=dp), POINTER :: Work(:)
     INTEGER, POINTER :: Permutation(:)
     TYPE(Variable_t), POINTER :: TimeVar, SaveVar
!------------------------------------------------------------------------------
     SaveVar => Solver % Variable
     DOFs = SaveVar % DOFs

     Solver % Mesh => Mesh
     CALL SetCurrentMesh( CurrentModel, Mesh )
!
!    Create matrix and variable structures for
!    current equation on the new mesh:
!    -----------------------------------------
     Solver % Variable => VariableGet( Mesh % Variables, &
        Solver % Variable % Name, ThisOnly = .FALSE. )

     CALL AllocateVector( Permutation, SIZE(Solver % Variable % Perm) )

     OptimizeBandwidth = ListGetLogical( Solver % Values, 'Optimize Bandwidth', Found )
     IF ( .NOT. Found ) OptimizeBandwidth = .TRUE.

     Matrix => CreateMatrix( CurrentModel, Solver, &
        Mesh, Permutation, DOFs, MATRIX_CRS, OptimizeBandwidth, &
        ListGetString( Solver % Values, 'Equation' ) )

     Matrix % Symmetric = ListGetLogical( Solver % Values, &
             'Linear System Symmetric', Found )

     Matrix % Lumped = ListGetLogical( Solver % Values, &
             'Lumped Mass Matrix', Found )

     ALLOCATE( Work(SIZE(Solver % Variable % Values)) )
     Work = Solver % Variable % Values
     DO k=0,DOFs-1
        DO i=1,SIZE(Permutation)
           IF ( Permutation(i) > 0 ) THEN
              Solver % Variable % Values( DOFs*Permutation(i)-k ) = &
                 Work( DOFs*Solver % Variable % Perm(i)-k )
           END IF
        END DO
     END DO

     IF ( ASSOCIATED( Solver % Variable % PrevValues ) ) THEN
        DO j=1,SIZE(Solver % Variable % PrevValues,2)
           Work = Solver % Variable % PrevValues(:,j)
           DO k=0,DOFs-1
              DO i=1,SIZE(Permutation)
                 IF ( Permutation(i) > 0 ) THEN
                    Solver % Variable % PrevValues( DOFs*Permutation(i) - k,j ) =  &
                        Work( DOFs * Solver % Variable % Perm(i) - k )
                  END IF
              END DO
           END DO
        END DO
     END IF
     DEALLOCATE( Work )

     Solver % Variable % Perm = Permutation
     Solver % Variable % Solver => Solver

     DEALLOCATE( Permutation )
     CALL AllocateVector( Matrix % RHS, Matrix % NumberOfRows )

     IF ( ASSOCIATED(SaveVar % EigenValues) ) THEN
        n = SIZE(SaveVar % EigenValues)

        IF ( n > 0 ) THEN
           Solver % NOFEigenValues = n
           CALL AllocateVector( Solver % Variable % EigenValues,n )
           CALL AllocateArray( Solver % Variable % EigenVectors, n, &
                    SIZE(Solver % Variable % Values) ) 

           Solver % Variable % EigenValues  = 0.0d0
           Solver % Variable % EigenVectors = 0.0d0

           CALL AllocateVector( Matrix % MassValues, SIZE(Matrix % Values) )
           Matrix % MassValues = 0.0d0
        END IF
     ELSE IF ( ASSOCIATED( Solver % Matrix % Force ) ) THEN
        n1 = Matrix % NumberOFRows
        n2 = SIZE(Solver % Matrix % Force,2)
        ALLOCATE(Matrix % Force(n1,n2))
        Matrix % Force = 0.0d0
     END IF

     Solver % Matrix => Matrix
     Solver % Mesh % Changed = .TRUE.

!------------------------------------------------------------------------------
  END SUBROUTINE UpdateSolverMesh
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  FUNCTION SplitMeshEqual( Mesh,h ) RESULT( NewMesh )
!------------------------------------------------------------------------------
!   h/2 split of  given mesh, currently works only
!   for linear and bilinear elements
!------------------------------------------------------------------------------
    REAL(KIND=dp), OPTIONAL :: h(:)
    TYPE(Mesh_t), POINTER :: Mesh, NewMesh
!------------------------------------------------------------------------------
    REAL(KIND=dp), POINTER :: u(:),v(:),w(:),x(:),y(:),z(:),xh(:)
    INTEGER :: i, j, k, n, NewElCnt, NodeCnt, EdgeCnt, Node, ParentId, Diag
    LOGICAL :: Found
    TYPE(Element_t), POINTER :: Enew,Eold,Edge,Eptr,Eparent,Face,Faces(:)
    INTEGER, POINTER :: Child(:,:)
    INTEGER :: n1,n2,n3,EoldNodes(4),FaceNodes(4),EdgeNodes(2) ! Only linears so far
    INTEGER :: FaceNumber,Edge1,Edge2,Edge3,Edge4,Node12,Node23,Node34,Node41,Node31
    REAL(KIND=dp) :: dxyz(3,3),Dist(3),r,s,t,h1,h2
!------------------------------------------------------------------------------
    IF ( .NOT. ASSOCIATED( Mesh ) ) RETURN

    NewMesh => AllocateMesh()

    CALL FindMeshEdges( Mesh )

    CALL ResetTimer('SplitMeshEqual')

    CALL Info( 'SplitMeshEqual', '******** Old mesh ********', Level = 6 )
    WRITE( Message, * ) 'Nodes             : ',Mesh % NumberOfNodes
    CALL info( 'SplitMeshEqual', Message, Level=6 )
    WRITE( Message, * ) 'Bulk elements     : ',Mesh % NumberOfBulkElements
    CALL info( 'SplitMeshEqual', Message, Level=6 )
    WRITE( Message, * ) 'Boundary elements : ',Mesh % NumberOfBoundaryElements
    CALL info( 'SplitMeshEqual', Message, Level=6 )
    WRITE( Message, * ) 'Edges             : ',Mesh % NumberOfEdges
    CALL info( 'SplitMeshEqual', Message, Level=6 )
    WRITE( Message, * ) 'Faces             : ',Mesh % NumberOfFaces
    CALL info( 'SplitMeshEqual', Message, Level=6 )
!
!   Update nodal coordinates:
!   -------------------------
    NodeCnt = Mesh % NumberOfNodes + Mesh % NumberOfEdges
!
!   For bricks, count faces:
!   ------------------------
    DO i = 1, Mesh % NumberOfFaces
       Face => Mesh % Faces(i)
       IF( Face % TYPE % NumberOfNodes == 4 ) NodeCnt = NodeCnt+1
    END DO
!
!   For quads and bricks, count centerpoints:
!   -----------------------------------------
    DO i=1,Mesh % NumberOfBulkElements
       Eold => Mesh % Elements(i)
       SELECT CASE( Eold % TYPE % ElementCode / 100 )
       CASE(4,8)
          NodeCnt = NodeCnt + 1
       END SELECT
    END DO
!
!   new mesh nodecoordinate arrays:
!   -------------------------------
    CALL AllocateVector( NewMesh % Nodes % x, NodeCnt )
    CALL AllocateVector( NewMesh % Nodes % y, NodeCnt )
    CALL AllocateVector( NewMesh % Nodes % z, NodeCnt )

!   shortcuts (u,v,w) old mesh  nodes,
!   (x,y,z) new mesh nodes:
!   ----------------------------------
    u => Mesh % Nodes % x
    v => Mesh % Nodes % y
    w => Mesh % Nodes % z

    x => NewMesh % Nodes % x
    y => NewMesh % Nodes % y
    z => NewMesh % Nodes % z
!
!   new mesh includes old mesh nodes:
!   ----------------------------------
    x(1:Mesh % NumberOfNodes) = u
    y(1:Mesh % NumberOfNodes) = v
    z(1:Mesh % NumberOfNodes) = w

    IF (PRESENT(h)) THEN
      ALLOCATE(xh(SIZE(x)))
      xh(1:SIZE(h)) = h
    END IF
!
!   add edge centers:
!   -----------------
    DO i=1,Mesh % NumberOfEdges
       Edge => Mesh % Edges(i)
       k = Edge % TYPE % NumberOfNodes
       j = i + Mesh % NumberOfNodes
       IF (PRESENT(h)) THEN
         h1=h(Edge % NodeIndexes(1))
         h2=h(Edge % NodeIndexes(2))
         r=1._dp/(1+h1/h2)
         x(j) = r*u(Edge%NodeIndexes(1))+(1-r)*u(Edge%NodeIndexes(2))
         y(j) = r*v(Edge%NodeIndexes(1))+(1-r)*v(Edge%NodeIndexes(2))
         z(j) = r*w(Edge%NodeIndexes(1))+(1-r)*w(Edge%NodeIndexes(2))
         xh(j)=r*h1+(1-r)*h2
       ELSE
         x(j) = SUM(u(Edge % NodeIndexes))/k
         y(j) = SUM(v(Edge % NodeIndexes))/k
         z(j) = SUM(w(Edge % NodeIndexes))/k
       END IF
    END DO
!
!   add face centers for bricks:
!   ----------------------------
    DO i=1,Mesh % NumberOfFaces
       Face => Mesh % Faces(i)
       k = Face % TYPE % NumberOfNodes
       IF( k == 4 ) THEN
          j = i + Mesh % NumberOfNodes + Mesh % NumberOfEdges
          IF (PRESENT(h)) THEN
            n=Mesh % NumberOfNodes
            h1=xh(n+Face % EdgeIndexes(2))
            h2=xh(n+Face % EdgeIndexes(4))
            r=2._dp/(1+h1/h2)-1
            h1=xh(n+Face % EdgeIndexes(3))
            h2=xh(n+Face % EdgeIndexes(1))
            s=2._dp/(1+h1/h2)-1
            x(j) = InterpolateInElement2D(Face,u(Face % NodeIndexes),r,s)
            y(j) = InterpolateInElement2D(Face,v(Face % NodeIndexes),r,s)
            z(j) = InterpolateInElement2D(Face,w(Face % NodeIndexes),r,s)
            xh(j) = InterpolateInElement2D(Face,h(Face % NodeIndexes),r,s)
          ELSE
            x(j) = SUM(u(Face % NodeIndexes))/k
            y(j) = SUM(v(Face % NodeIndexes))/k
            z(j) = SUM(w(Face % NodeIndexes))/k
          END IF
       END IF
    END DO
!
!   add centerpoint for quads & bricks:
!   -----------------------------------
    DO i=1,Mesh % NumberOfBulkElements
       Eold => Mesh % Elements(i)
       k = Eold % Type % NumberOfNodes
       j = j + 1
       SELECT CASE( Eold % TYPE % ElementCode / 100 )

       CASE(4)
          IF (PRESENT(h)) THEN
            n=Mesh % NumberOfNodes
            h1=xh(n+Eold % Edgeindexes(2))
            h2=xh(n+Eold % Edgeindexes(4))
            r=2._dp/(1+h1/h2)-1
            h1=xh(n+Eold % EdgeIndexes(3))
            h2=xh(n+Eold % EdgeIndexes(1))
            s=2._dp/(1+h1/h2)-1
            x(j) = InterpolateInElement2D(Eold,u(Eold % NodeIndexes),r,s)
            y(j) = InterpolateInElement2D(Eold,v(Eold % NodeIndexes),r,s)
            z(j) = InterpolateInElement2D(Eold,w(Eold % NodeIndexes),r,s)
          ELSE
            x(j) = SUM(u(Eold % NodeIndexes))/k
            y(j) = SUM(v(Eold % NodeIndexes))/k
            z(j) = SUM(w(Eold % NodeIndexes))/k
          END IF
       CASE(8)
          IF (PRESENT(h)) THEN
            n=Mesh % NumberOfNodes+Mesh % NumberOfEdges
            h1=xh(n+Eold % FaceIndexes(4))
            h2=xh(n+Eold % FaceIndexes(6))
            r=2._dp/(1+h1/h2)-1

            h1=xh(n+Eold % FaceIndexes(5))
            h2=xh(n+Eold % FaceIndexes(3))
            s=2._dp/(1+h1/h2)-1

            h1=xh(n+Eold % FaceIndexes(2))
            h2=xh(n+Eold % FaceIndexes(1))
            t=2._dp/(1+h1/h2)-1
            x(j) = InterpolateInElement3D(Eold,u(Eold % NodeIndexes),r,s,t)
            y(j) = InterpolateInElement3D(Eold,v(Eold % NodeIndexes),r,s,t)
            z(j) = InterpolateInElement3D(Eold,w(Eold % NodeIndexes),r,s,t)
          ELSE
            x(j) = SUM(u(Eold % NodeIndexes))/k
            y(j) = SUM(v(Eold % NodeIndexes))/k
            z(j) = SUM(w(Eold % NodeIndexes))/k
          END IF
       END SELECT
    END DO
!
!   Update new mesh node count:
!   ---------------------------
    NewMesh % NumberOfEdges = 0
    NewMesh % NumberOfFaces = 0
    NewMesh % MaxBDOFs = Mesh % MaxBDOFs
    NewMesh % MaxEdgeDOFs = Mesh % MaxEdgeDOFs
    NewMesh % MaxFaceDOFs = Mesh % MaxFaceDOFs
    NewMesh % MaxElementDOFs = Mesh % MaxElementDOFs
    NewMesh % MeshDim = Mesh % MeshDim

    NewMesh % NumberOfNodes = NodeCnt
    NewMesh % Nodes % NumberOfNodes = NodeCnt
!
!   Update bulk elements:
!   =====================
!
!   First count new elements:
!   -------------------------
    NewElCnt = 0
    DO i=1, Mesh % NumberOfBulkElements + Mesh % NumberOfBoundaryElements
       Eold => Mesh % Elements(i)
       SELECT CASE( Eold % TYPE % ElementCode/100 )

!      Each element will be divided into 2**Dim new elements:
!      ------------------------------------------------------
       CASE(2)
          NewElCnt = NewElCnt + 2 ! lines
       CASE(3)
          NewElCnt = NewElCnt + 4 ! trias
       CASE(4)
          NewElCnt = NewElCnt + 4 ! quads
       CASE(5)
          NewElCnt = NewElCnt + 8 ! tetras
       CASE(8)
          NewElCnt = NewElCnt + 8 ! hexas
       END SELECT

    END DO
    CALL AllocateVector( NewMesh % Elements, NewElCnt )
    DO i=1,NewELCnt
      NewMesh % Elements(i) % EdgeIndexes => NULL()
      NewMesh % Elements(i) % FaceIndexes => NULL()
    END DO

    CALL AllocateArray( Child, Mesh % NumberOfBulkElements, 8 )
    NewElCnt = 0
    NodeCnt = Mesh % NumberOfNodes
    EdgeCnt = Mesh % NumberOfEdges
!
!   Index to old quad/hexa centerpoint node in the new mesh nodal arrays:
!   ---------------------------------------------------------------------
    Node = NodeCnt + Mesh % NumberOfEdges + Mesh % NumberOfFaces
!
!   Now update all new mesh elements:
!   ---------------------------------
    DO i=1,Mesh % NumberOfBulkElements

       Eold => Mesh % Elements(i)

       SELECT CASE( Eold % TYPE % ElementCode )
       CASE(303)
!
!         Split triangle to four triangles from
!         edge centerpoints:
!         --------------------------------------
!
!         1st new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Child(i,1) = NewElCnt
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( ENew % NodeIndexes, 3)
          Enew % NodeIndexes(1) = Eold % NodeIndexes(1)
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(3) + NodeCnt
!
!         2nd new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Child(i,2) = NewElCnt
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 3)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(2) = Eold % NodeIndexes(2)
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(2) + NodeCnt
!
!         3rd new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Child(i,3) = NewElCnt
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 3)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(3) + NodeCnt
!
!         4th new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Child(i,4) = NewElCnt
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 3)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(2) = Eold % NodeIndexes(3)
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(3) + NodeCnt

       CASE(404)
!
!         Index to old quad centerpoint node in the
!         new mesh nodal arrays:
!         ------------------------------------------
          Node = Node + 1
!
!         Split quad to four new quads from edge
!         centerpoints and centerpoint of the
!         element:
!         --------------------------------------
!         1st new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,1) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % NodeIndexes(1)
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(3) = Node
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(4) + NodeCnt
!
!         2nd new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,2) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(2) = Eold % NodeIndexes(2)
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(4) = Node
!
!         3rd new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,3) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Node
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(3) = Eold % NodeIndexes(3)
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(3) + NodeCnt
!
!         4th new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,4) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(4) + NodeCnt
          Enew % NodeIndexes(2) = Node
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(3) + NodeCnt
          Enew % NodeIndexes(4) = Eold % NodeIndexes(4)


       CASE(504)
!
!         Split tetra to 8 new elements from
!         corners and edge centerpoints:
!         ----------------------------------
!
!         1st new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,1) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % NodeIndexes(1)
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(3) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(4) + NodeCnt
!
!         2nd new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,2) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % NodeIndexes(2)
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(5) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(2) + NodeCnt
!
!         3rd new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,3) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % NodeIndexes(3)
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(6) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(3) + NodeCnt
!
!         4th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,4) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % NodeIndexes(4)
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(4) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(6) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(5) + NodeCnt

!         Then the annoying part; we still have to split the
!         remaining octahedron into four elements. This can
!         be done in three ways of which only one preserves
!         the minimum angle condition (Delaunay splitting):
!         --------------------------------------------------
          dxyz(1,1) = x(Eold % EdgeIndexes(4) + NodeCnt) &
                    - x(Eold % EdgeIndexes(2) + NodeCnt)
          dxyz(2,1) = y(Eold % EdgeIndexes(4) + NodeCnt) &
                    - y(Eold % EdgeIndexes(2) + NodeCnt)
          dxyz(3,1) = z(Eold % EdgeIndexes(4) + NodeCnt) &
                    - z(Eold % EdgeIndexes(2) + NodeCnt)

          dxyz(1,2) = x(Eold % EdgeIndexes(5) + NodeCnt) &
                    - x(Eold % EdgeIndexes(3) + NodeCnt)
          dxyz(2,2) = y(Eold % EdgeIndexes(5) + NodeCnt) &
                    - y(Eold % EdgeIndexes(3) + NodeCnt)
          dxyz(3,2) = z(Eold % EdgeIndexes(5) + NodeCnt) &
                    - z(Eold % EdgeIndexes(3) + NodeCnt)

          dxyz(1,3) = x(Eold % EdgeIndexes(6) + NodeCnt) &
                    - x(Eold % EdgeIndexes(1) + NodeCnt)
          dxyz(2,3) = y(Eold % EdgeIndexes(6) + NodeCnt) &
                    - y(Eold % EdgeIndexes(1) + NodeCnt)
          dxyz(3,3) = z(Eold % EdgeIndexes(6) + NodeCnt) &
                    - z(Eold % EdgeIndexes(1) + NodeCnt)

          Dist(1) = SQRT( dxyz(1,1)**2 + dxyz(2,1)**2 + dxyz(3,1)**2 )
          Dist(2) = SQRT( dxyz(1,2)**2 + dxyz(2,2)**2 + dxyz(3,2)**2 )
          Dist(3) = SQRT( dxyz(1,3)**2 + dxyz(2,3)**2 + dxyz(3,3)**2 )

          Diag = 1  ! The default diagonal for splitting is between edges 2-4
          IF (Dist(2) < Dist(1) .AND. Dist(2) < Dist(3)) Diag = 2 ! Edges 3-5
          IF (Dist(3) < Dist(1) .AND. Dist(3) < Dist(2)) Diag = 3 ! Edges 1-6

          SELECT CASE( Diag )
          CASE(1)
!
!         5th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,5) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(6) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(4) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(5) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(2) + NodeCnt
!
!         6th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,6) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(6) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(4) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(3) + NodeCnt
!
!         7th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,7) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(4) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(5) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(1) + NodeCnt
!
!         8th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,8) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(4) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(3) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(2) + NodeCnt
!
          CASE(2)
!
!         5th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,5) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(5) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(4) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(6) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(3) + NodeCnt
!
!         6th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,6) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(5) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(3) + NodeCnt
!
!         7th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,7) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(3) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(6) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(5) + NodeCnt
!
!         8th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,8) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(3) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(4) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(5) + NodeCnt
!
          CASE(3)
!
!         5th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,5) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(6) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(4) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(5) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(1) + NodeCnt
!
!         6th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,6) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(6) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(3) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(1) + NodeCnt
!
!         7th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,7) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(5) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(6) + NodeCnt
!
!         8th new element:
!         ----------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,8) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 4)
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(3) + NodeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(4) + NodeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(6) + NodeCnt

          END SELECT

       CASE(808)
!
!         Index to old quad centerpoint node in the
!         new mesh nodal arrays:
!         ------------------------------------------
          Node = Node + 1
!
!         Split brick to 8 new bricks from edge
!         centerpoints and centerpoint of the
!         element:
!         --------------------------------------
!
!         1st new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,1) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL  AllocateVector( ENew % NodeIndexes, 8)
          Enew % NodeIndexes(1) = Eold % NodeIndexes(1)
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(3) = Eold % FaceIndexes(1) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(4) + NodeCnt
          Enew % NodeIndexes(5) = Eold % EdgeIndexes(9) + NodeCnt
          Enew % NodeIndexes(6) = Eold % FaceIndexes(3) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(7) = Node
          Enew % NodeIndexes(8) = Eold % FaceIndexes(6) + NodeCnt + EdgeCnt
!
!         2nd new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,2) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( ENew % NodeIndexes, 8 )
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(1) + NodeCnt
          Enew % NodeIndexes(2) = Eold % NodeIndexes(2)
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(4) = Eold % FaceIndexes(1) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(5) = Eold % FaceIndexes(3) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(6) = Eold % EdgeIndexes(10)+ NodeCnt
          Enew % NodeIndexes(7) = Eold % FaceIndexes(4) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(8) = Node
!
!         3rd new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,3) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( ENew % NodeIndexes, 8 )
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(4) + NodeCnt
          Enew % NodeIndexes(2) = Eold % FaceIndexes(1) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(3) + NodeCnt
          Enew % NodeIndexes(4) = Eold % NodeIndexes(4)
          Enew % NodeIndexes(5) = Eold % FaceIndexes(6) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(6) = Node
          Enew % NodeIndexes(7) = Eold % FaceIndexes(5) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(8) = Eold % EdgeIndexes(12)+ NodeCnt
!
!         4th new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,4) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( ENew % NodeIndexes, 8 )
          Enew % NodeIndexes(1) = Eold % FaceIndexes(1) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(2) + NodeCnt
          Enew % NodeIndexes(3) = Eold % NodeIndexes(3)
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(3) + NodeCnt
          Enew % NodeIndexes(5) = Node
          Enew % NodeIndexes(6) = Eold % FaceIndexes(4) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(7) = Eold % EdgeIndexes(11)+ NodeCnt
          Enew % NodeIndexes(8) = Eold % FaceIndexes(5) + NodeCnt + EdgeCnt
!
!         5th new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,5) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( ENew % NodeIndexes, 8 )
          Enew % NodeIndexes(1) = Eold % EdgeIndexes(9) + NodeCnt
          Enew % NodeIndexes(2) = Eold % FaceIndexes(3) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(3) = Node
          Enew % NodeIndexes(4) = Eold % FaceIndexes(6) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(5) = Eold % NodeIndexes(5)
          Enew % NodeIndexes(6) = Eold % EdgeIndexes(5) + NodeCnt
          Enew % NodeIndexes(7) = Eold % FaceIndexes(2) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(8) = Eold % EdgeIndexes(8) + NodeCnt
!
!         6th new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,6) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( ENew % NodeIndexes, 8 )
          Enew % NodeIndexes(1) = Eold % FaceIndexes(3) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(2) = Eold % EdgeIndexes(10)+ NodeCnt
          Enew % NodeIndexes(3) = Eold % FaceIndexes(4) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(4) = Node
          Enew % NodeIndexes(5) = Eold % EdgeIndexes(5) + NodeCnt
          Enew % NodeIndexes(6) = Eold % NodeIndexes(6)
          Enew % NodeIndexes(7) = Eold % EdgeIndexes(6) + NodeCnt
          Enew % NodeIndexes(8) = Eold % FaceIndexes(2) + NodeCnt + EdgeCnt
!
!         7th new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,7) = NewElCnt 
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( ENew % NodeIndexes, 8 )
          Enew % NodeIndexes(1) = Eold % FaceIndexes(6) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(2) = Node
          Enew % NodeIndexes(3) = Eold % FaceIndexes(5) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(4) = Eold % EdgeIndexes(12)+ NodeCnt
          Enew % NodeIndexes(5) = Eold % EdgeIndexes(8) + NodeCnt
          Enew % NodeIndexes(6) = Eold % FaceIndexes(2) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(7) = Eold % EdgeIndexes(7) + NodeCnt
          Enew % NodeIndexes(8) = Eold % NodeIndexes(8)
!
!         8th new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Child(i,8) = NewElCnt
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( ENew % NodeIndexes, 8 )
          Enew % NodeIndexes(1) = Node
          Enew % NodeIndexes(2) = Eold % FaceIndexes(4) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(3) = Eold % EdgeIndexes(11)+ NodeCnt
          Enew % NodeIndexes(4) = Eold % FaceIndexes(5) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(5) = Eold % FaceIndexes(2) + NodeCnt + EdgeCnt
          Enew % NodeIndexes(6) = Eold % EdgeIndexes(6) + NodeCnt
          Enew % NodeIndexes(7) = Eold % NodeIndexes(7)
          Enew % NodeIndexes(8) = Eold % EdgeIndexes(7) + NodeCnt

       CASE DEFAULT
          WRITE( Message,* ) 'Element type ', Eold % TYPE % ElementCode, &
              ' not supprted by the multigrid solver.'
          CALL Fatal( 'SplitMeshEqual', Message )
       END SELECT
    END DO

!
!   Update new mesh element counts:
!   -------------------------------
    NewMesh % NumberOfBulkElements = NewElCnt

!
!   Update boundary elements:
!   NOTE: Internal boundaries not taken care of...:!!!!
!   ---------------------------------------------------
    DO i=1,Mesh % NumberOfBoundaryElements

       j = i + Mesh % NumberOfBulkElements
       Eold => Mesh % Elements(j)
!
!      get parent of the boundary element:
!      -----------------------------------
       Eparent => Eold % BoundaryInfo % Left
       IF ( .NOT.ASSOCIATED(Eparent) ) &
          eParent => Eold % BoundaryInfo % Right
       IF ( .NOT. ASSOCIATED( Eparent ) ) CYCLE

       ParentId = Eparent % ElementIndex

       SELECT CASE( Eold % TYPE % ElementCode / 100 )
       CASE(2)
!
!         Line segments:
!         ==============
!
!         which edge of the parent element are we ?
!         -----------------------------------------
          DO Edge1=1,SIZE(Eparent % EdgeIndexes)
             Edge => Mesh % Edges( Eparent % EdgeIndexes(Edge1) )
             IF ( Eold % NodeIndexes(1) == Edge % NodeIndexes(1) .AND. &
                  Eold % NodeIndexes(2) == Edge % NodeIndexes(2) .OR.  &
                  Eold % NodeIndexes(2) == Edge % NodeIndexes(1) .AND. &
                  Eold % NodeIndexes(1) == Edge % NodeIndexes(2) ) EXIT
          END DO
!
!         index of the old edge centerpoint in the
!         new mesh nodal arrays:
!         ----------------------------------------
          Node = Eparent % EdgeIndexes(Edge1) + Mesh % NumberOfNodes
!
!         1st new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( Enew % NodeIndexes, 2 )
          Enew % NodeIndexes(1) = Eold % NodeIndexes(1)
          Enew % NodeIndexes(2) = Node
          ALLOCATE( Enew % BoundaryInfo )
          Enew % BoundaryInfo = Eold % BoundaryInfo
          NULLIFY( Enew % BoundaryInfo % Left )
          NULLIFY( Enew % BoundaryInfo % Right )
!
!         Search the new mesh parent element among the
!         children of the old mesh parent element:
!         --------------------------------------------
          DO j=1,4
             Eptr => NewMesh % Elements( Child(ParentId,j) )
             n = Eptr % TYPE % NumberOfNodes
             Found = .FALSE.
             DO k=1,n-1
                IF ( Enew % NodeIndexes(1) == Eptr % NodeIndexes(k)   .AND. &
                     Enew % NodeIndexes(2) == Eptr % NodeIndexes(k+1) .OR.  &
                     Enew % NodeIndexes(2) == Eptr % NodeIndexes(k)   .AND. &
                     Enew % NodeIndexes(1) == Eptr % NodeIndexes(k+1) ) THEN
                   Found = .TRUE.
                   EXIT
                END IF
             END DO
             IF ( Enew % NodeIndexes(1) == Eptr % NodeIndexes(n) .AND. &
                  Enew % NodeIndexes(2) == Eptr % NodeIndexes(1) .OR.  &
                  Enew % NodeIndexes(2) == Eptr % NodeIndexes(n) .AND. &
                  Enew % NodeIndexes(1) == Eptr % NodeIndexes(1) ) THEN
                Found = .TRUE.
             END IF
             IF ( Found ) EXIT
          END DO
          Enew % BoundaryInfo % Left => Eptr
!
!         2nd new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( Enew % NodeIndexes, 2 )
          Enew % NodeIndexes(1) = Node
          Enew % NodeIndexes(2) = Eold % NodeIndexes(2)
          ALLOCATE( Enew % BoundaryInfo )
          Enew % BoundaryInfo = Eold % BoundaryInfo
          NULLIFY( Enew % BoundaryInfo % Left )
          NULLIFY( Enew % BoundaryInfo % Right )
!
!         Search the new mesh parent element among the
!         children of the old mesh parent element:
!         --------------------------------------------
          DO j=1,4
             Eptr => NewMesh % Elements( Child(ParentId,j) )
             n = Eptr % TYPE % NumberOfNodes
             Found = .FALSE.
             DO k=1,n-1
                IF ( Enew % NodeIndexes(1) == Eptr % NodeIndexes(k)   .AND. &
                     Enew % NodeIndexes(2) == Eptr % NodeIndexes(k+1) .OR.  &
                     Enew % NodeIndexes(2) == Eptr % NodeIndexes(k)   .AND. &
                     Enew % NodeIndexes(1) == Eptr % NodeIndexes(k+1) ) THEN
                   Found = .TRUE.
                   EXIT
                END IF
             END DO
             IF ( Enew % NodeIndexes(1) == Eptr % NodeIndexes(n) .AND. &
                  Enew % NodeIndexes(2) == Eptr % NodeIndexes(1) .OR.  &
                  Enew % NodeIndexes(2) == Eptr % NodeIndexes(n) .AND. &
                  Enew % NodeIndexes(1) == Eptr % NodeIndexes(1) ) THEN
                Found = .TRUE.
             END IF
             IF ( Found ) EXIT
          END DO
          Enew % BoundaryInfo % Left => Eptr

       CASE(3)
!
!         Trias:
!         ======
!
!         On which face of the parent element are we ?
!         --------------------------------------------
          EoldNodes(1:3) = Eold % NodeIndexes(1:3)
          CALL sort( 3, EoldNodes )

          DO FaceNumber = 1, SIZE( Eparent % FaceIndexes )
             Face => Mesh % Faces( Eparent % FaceIndexes(FaceNumber) )
             FaceNodes(1:3) = Face % NodeIndexes(1:3)
             CALL sort( 3, FaceNodes )

             IF ( EoldNodes(1) == FaceNodes(1) .AND. &
                  EoldNodes(2) == FaceNodes(2) .AND. &
                  EoldNodes(3) == FaceNodes(3) ) EXIT

          END DO
!
!         Then, what are the edges on this face?
!         --------------------------------------
!
!         First edge:
!         -----------
          EoldNodes(1) = MIN( Eold % NodeIndexes(1), Eold % NodeIndexes(2) )
          EoldNodes(2) = MAX( Eold % NodeIndexes(1), Eold % NodeIndexes(2) )
          DO Edge1 = 1,SIZE(Eparent % EdgeIndexes)
             Edge => Mesh % Edges( Eparent % EdgeIndexes(Edge1) )
             EdgeNodes(1) = MIN( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             EdgeNodes(2) = MAX( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             IF ( EoldNodes(1) == EdgeNodes(1) .AND. &
                  EoldNodes(2) == EdgeNodes(2) ) EXIT
          END DO

!         Second edge:
!         ------------
          EoldNodes(1) = MIN( Eold % NodeIndexes(2), Eold % NodeIndexes(3) )
          EoldNodes(2) = MAX( Eold % NodeIndexes(2), Eold % NodeIndexes(3) )
          DO Edge2 = 1,SIZE(Eparent % EdgeIndexes)
             Edge => Mesh % Edges( Eparent % EdgeIndexes(Edge2) )
             EdgeNodes(1) = MIN( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             EdgeNodes(2) = MAX( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             IF ( EoldNodes(1) == EdgeNodes(1) .AND. &
                  EoldNodes(2) == EdgeNodes(2) ) EXIT
          END DO

!         Third edge:
!         -----------
          EoldNodes(1) = MIN( Eold % NodeIndexes(3), Eold % NodeIndexes(1) )
          EoldNodes(2) = MAX( Eold % NodeIndexes(3), Eold % NodeIndexes(1) )
          DO Edge3 = 1,SIZE(Eparent % EdgeIndexes)
             Edge => Mesh % Edges( Eparent % EdgeIndexes(Edge3) )
             EdgeNodes(1) = MIN( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             EdgeNodes(2) = MAX( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             IF ( EoldNodes(1) == EdgeNodes(1) .AND. &
                  EoldNodes(2) == EdgeNodes(2) ) EXIT
          END DO
!
!         index of the old face and edge centerpoints
!         in the new mesh nodal arrays:
!         ----------------------------------------
          Node12 = Eparent % EdgeIndexes(Edge1) + Mesh % NumberOfNodes
          Node23 = Eparent % EdgeIndexes(Edge2) + Mesh % NumberOfNodes
          Node31 = Eparent % EdgeIndexes(Edge3) + Mesh % NumberOfNodes
!
!         1st new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( Enew % NodeIndexes, 3 )
          Enew % NodeIndexes(1) = Eold % NodeIndexes(1)
          Enew % NodeIndexes(2) = Node12
          Enew % NodeIndexes(3) = Node31
          ALLOCATE( Enew % BoundaryInfo )
          Enew % BoundaryInfo = Eold % BoundaryInfo
          NULLIFY( Enew % BoundaryInfo % Left )
          NULLIFY( Enew % BoundaryInfo % Right )
!
!         Search the new mesh parent element among the
!         children of the old mesh parent element:
!         --------------------------------------------
          DO j=1,8
             Eptr => NewMesh % Elements( Child(ParentId,j) )
             n = Eptr % TYPE % NumberOfNodes
             n3 = 0 ! Count matches (metodo stupido)
             DO n1 = 1,3
                DO n2 = 1,4
                   IF( Enew % NodeIndexes(n1) == Eptr % NodeIndexes(n2) ) n3 = n3+1
                END DO
             END DO
             IF ( n3 > 2 ) EXIT
          END DO
          IF( n3 < 3 ) CALL Error( 'SplitMeshEqual', 'Parent element not found' )
          Enew % BoundaryInfo % Left => Eptr
!
!         2nd new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( Enew % NodeIndexes, 3 )
          Enew % NodeIndexes(1) = Node12
          Enew % NodeIndexes(2) = Eold % NodeIndexes(2)
          Enew % NodeIndexes(3) = Node23
          ALLOCATE( Enew % BoundaryInfo )
          Enew % BoundaryInfo = Eold % BoundaryInfo
          NULLIFY( Enew % BoundaryInfo % Left )
          NULLIFY( Enew % BoundaryInfo % Right )
!
!         Search the new mesh parent element among the
!         children of the old mesh parent element:
!         --------------------------------------------
          DO j=1,8
             Eptr => NewMesh % Elements( Child(ParentId,j) )
             n = Eptr % TYPE % NumberOfNodes
             n3 = 0 ! Count matches (metodo stupido)
             DO n1 = 1,3
                DO n2 = 1,4
                   IF( Enew % NodeIndexes(n1) == Eptr % NodeIndexes(n2) ) n3 = n3+1
                END DO
             END DO
             IF ( n3 > 2 ) EXIT
          END DO
          IF( n3 < 3 ) CALL Error( 'SplitMeshEqual', 'Parent element not found' )
          Enew % BoundaryInfo % Left => Eptr
!
!         3rd new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( Enew % NodeIndexes, 3 )
          Enew % NodeIndexes(1) = Node12
          Enew % NodeIndexes(2) = Node23
          Enew % NodeIndexes(3) = Node31
          ALLOCATE( Enew % BoundaryInfo )
          Enew % BoundaryInfo = Eold % BoundaryInfo
          NULLIFY( Enew % BoundaryInfo % Left )
          NULLIFY( Enew % BoundaryInfo % Right )
!
!         Search the new mesh parent element among the
!         children of the old mesh parent element:
!         --------------------------------------------
          DO j=1,8
             Eptr => NewMesh % Elements( Child(ParentId,j) )
             n = Eptr % TYPE % NumberOfNodes
             n3 = 0 ! Count matches (metodo stupido)
             DO n1 = 1,3
                DO n2 = 1,4
                   IF( Enew % NodeIndexes(n1) == Eptr % NodeIndexes(n2) ) n3 = n3+1
                END DO
             END DO
             IF ( n3 > 2 ) EXIT
          END DO
          IF( n3 < 3 ) CALL Error( 'SplitMeshEqual', 'Parent element not found' )
          Enew % BoundaryInfo % Left => Eptr
!
!         4th new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( Enew % NodeIndexes, 3 )
          Enew % NodeIndexes(1) = Node31
          Enew % NodeIndexes(2) = Node23
          Enew % NodeIndexes(3) = Eold % NodeIndexes(3)
          ALLOCATE( Enew % BoundaryInfo )
          Enew % BoundaryInfo = Eold % BoundaryInfo
          NULLIFY( Enew % BoundaryInfo % Left )
          NULLIFY( Enew % BoundaryInfo % Right )
!
!         Search the new mesh parent element among the
!         children of the old mesh parent element:
!         --------------------------------------------
          DO j=1,8
             Eptr => NewMesh % Elements( Child(ParentId,j) )
             n = Eptr % TYPE % NumberOfNodes
             n3 = 0 ! Count matches (metodo stupido)
             DO n1 = 1,3
                DO n2 = 1,4
                   IF( Enew % NodeIndexes(n1) == Eptr % NodeIndexes(n2) ) n3 = n3+1
                END DO
             END DO
             IF ( n3 > 2 ) EXIT
          END DO
          IF( n3 < 3 ) CALL Error( 'SplitMeshEqual', 'Parent element not found' )
          Enew % BoundaryInfo % Left => Eptr

       CASE(4)
!
!         Quads:
!         ======
!
!         On which face of the parent element are we ?
!         --------------------------------------------
          EoldNodes(1:4) = Eold % NodeIndexes(1:4)
          CALL sort( 4, EoldNodes )

          DO FaceNumber = 1, SIZE( Eparent % FaceIndexes )
             Face => Mesh % Faces( Eparent % FaceIndexes(FaceNumber) )
             FaceNodes(1:4) = Face % NodeIndexes(1:4)
             CALL sort( 4, FaceNodes )

             IF ( EoldNodes(1) == FaceNodes(1) .AND. &
                  EoldNodes(2) == FaceNodes(2) .AND. &
                  EoldNodes(3) == FaceNodes(3) ) EXIT

          END DO

!         Then, what are the edges on this face?
!         --------------------------------------
!
!         First edge:
!         -----------
          EoldNodes(1) = MIN( Eold % NodeIndexes(1), Eold % NodeIndexes(2) )
          EoldNodes(2) = MAX( Eold % NodeIndexes(1), Eold % NodeIndexes(2) )
          DO Edge1 = 1,SIZE(Eparent % EdgeIndexes)
             Edge => Mesh % Edges( Eparent % EdgeIndexes(Edge1) )
             EdgeNodes(1) = MIN( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             EdgeNodes(2) = MAX( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             IF ( EoldNodes(1) == EdgeNodes(1) .AND. &
                  EoldNodes(2) == EdgeNodes(2) ) EXIT
          END DO

!         Second edge:
!         ------------
          EoldNodes(1) = MIN( Eold % NodeIndexes(2), Eold % NodeIndexes(3) )
          EoldNodes(2) = MAX( Eold % NodeIndexes(2), Eold % NodeIndexes(3) )
          DO Edge2 = 1,SIZE(Eparent % EdgeIndexes)
             Edge => Mesh % Edges( Eparent % EdgeIndexes(Edge2) )
             EdgeNodes(1) = MIN( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             EdgeNodes(2) = MAX( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             IF ( EoldNodes(1) == EdgeNodes(1) .AND. &
                  EoldNodes(2) == EdgeNodes(2) ) EXIT
          END DO

!         Third edge:
!         -----------
          EoldNodes(1) = MIN( Eold % NodeIndexes(3), Eold % NodeIndexes(4) )
          EoldNodes(2) = MAX( Eold % NodeIndexes(3), Eold % NodeIndexes(4) )
          DO Edge3 = 1,SIZE(Eparent % EdgeIndexes)
             Edge => Mesh % Edges( Eparent % EdgeIndexes(Edge3) )
             EdgeNodes(1) = MIN( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             EdgeNodes(2) = MAX( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             IF ( EoldNodes(1) == EdgeNodes(1) .AND. &
                  EoldNodes(2) == EdgeNodes(2) ) EXIT
          END DO

!         Fourth edge:
!         -----------
          EoldNodes(1) = MIN( Eold % NodeIndexes(4), Eold % NodeIndexes(1) )
          EoldNodes(2) = MAX( Eold % NodeIndexes(4), Eold % NodeIndexes(1) )
          DO Edge4 = 1,SIZE(Eparent % EdgeIndexes)
             Edge => Mesh % Edges( Eparent % EdgeIndexes(Edge4) )
             EdgeNodes(1) = MIN( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             EdgeNodes(2) = MAX( Edge % NodeIndexes(1), Edge % NodeIndexes(2) )
             IF ( EoldNodes(1) == EdgeNodes(1) .AND. &
                  EoldNodes(2) == EdgeNodes(2) ) EXIT
          END DO
!
!         index of the old face and edge centerpoints
!         in the new mesh nodal arrays:
!         ----------------------------------------
          Node = Eparent % FaceIndexes(FaceNumber) & ! faces mid-point
               + Mesh % NumberOfNodes + Mesh % NumberOfEdges
          Node12 = Eparent % EdgeIndexes(Edge1) + Mesh % NumberOfNodes
          Node23 = Eparent % EdgeIndexes(Edge2) + Mesh % NumberOfNodes
          Node34 = Eparent % EdgeIndexes(Edge3) + Mesh % NumberOfNodes
          Node41 = Eparent % EdgeIndexes(Edge4) + Mesh % NumberOfNodes
!
!         1st new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( Enew % NodeIndexes, 4 )
          Enew % NodeIndexes(1) = Eold % NodeIndexes(1)
          Enew % NodeIndexes(2) = Node12
          Enew % NodeIndexes(3) = Node
          Enew % NodeIndexes(4) = Node41
          ALLOCATE( Enew % BoundaryInfo )
          Enew % BoundaryInfo = Eold % BoundaryInfo
          NULLIFY( Enew % BoundaryInfo % Left )
          NULLIFY( Enew % BoundaryInfo % Right )
!
!         Search the new mesh parent element among the
!         children of the old mesh parent element:
!         --------------------------------------------
          DO j=1,8
             Eptr => NewMesh % Elements( Child(ParentId,j) )
             n = Eptr % TYPE % NumberOfNodes
             n3 = 0 ! Count matches (metodo stupido)
             DO n1 = 1,4
                DO n2 = 1,8
                   IF( Enew % NodeIndexes(n1) == Eptr % NodeIndexes(n2) ) n3 = n3+1
                END DO
             END DO
             IF ( n3 > 2 ) EXIT
          END DO
          IF( n3 < 3 )  CALL Error( 'SplitMeshEqual', 'Parent element not found' )
          Enew % BoundaryInfo % Left => Eptr
!
!         2nd new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( Enew % NodeIndexes, 4 )
          Enew % NodeIndexes(1) = Node12
          Enew % NodeIndexes(2) = Eold % NodeIndexes(2)
          Enew % NodeIndexes(3) = Node23
          Enew % NodeIndexes(4) = Node
          ALLOCATE( Enew % BoundaryInfo )
          Enew % BoundaryInfo = Eold % BoundaryInfo
          NULLIFY( Enew % BoundaryInfo % Left )
          NULLIFY( Enew % BoundaryInfo % Right )
!
!         Search the new mesh parent element among the
!         children of the old mesh parent element:
!         --------------------------------------------
          DO j=1,8
             Eptr => NewMesh % Elements( Child(ParentId,j) )
             n = Eptr % TYPE % NumberOfNodes
             n3 = 0 ! Count matches (metodo stupido)
             DO n1 = 1,4
                DO n2 = 1,8
                   IF( Enew % NodeIndexes(n1) == Eptr % NodeIndexes(n2) ) n3 = n3+1
                END DO
             END DO
             IF ( n3 > 2 ) EXIT
          END DO
          IF( n3 < 3 ) CALL Error( 'SplitMeshEqual', 'Parent element not found' )
          Enew % BoundaryInfo % Left => Eptr
!
!         3rd new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( Enew % NodeIndexes, 4 )
          Enew % NodeIndexes(1) = Node41
          Enew % NodeIndexes(2) = Node
          Enew % NodeIndexes(3) = Node34
          Enew % NodeIndexes(4) = Eold % NodeIndexes(4)
          ALLOCATE( Enew % BoundaryInfo )
          Enew % BoundaryInfo = Eold % BoundaryInfo
          NULLIFY( Enew % BoundaryInfo % Left )
          NULLIFY( Enew % BoundaryInfo % Right )
!
!         Search the new mesh parent element among the
!         children of the old mesh parent element:
!         --------------------------------------------
          DO j=1,8
             Eptr => NewMesh % Elements( Child(ParentId,j) )
             n = Eptr % TYPE % NumberOfNodes
             n3 = 0 ! Count matches (metodo stupido)
             DO n1 = 1,4
                DO n2 = 1,8
                   IF( Enew % NodeIndexes(n1) == Eptr % NodeIndexes(n2) ) n3 = n3+1
                END DO
             END DO
             IF ( n3 > 2 ) EXIT
          END DO
          IF( n3 < 3 ) CALL Error( 'SplitMeshEqual', 'Parent element not found' )
          Enew % BoundaryInfo % Left => Eptr
!
!         4th new element
!         ---------------
          NewElCnt = NewElCnt + 1
          Enew => NewMesh % Elements(NewElCnt)
          Enew = Eold
          Enew % ElementIndex = NewElCnt
          CALL AllocateVector( Enew % NodeIndexes, 4 )
          Enew % NodeIndexes(1) = Node
          Enew % NodeIndexes(2) = Node23
          Enew % NodeIndexes(3) = Eold % NodeIndexes(3)
          Enew % NodeIndexes(4) = Node34
          ALLOCATE( Enew % BoundaryInfo )
          Enew % BoundaryInfo = Eold % BoundaryInfo
          NULLIFY( Enew % BoundaryInfo % Left )
          NULLIFY( Enew % BoundaryInfo % Right )
!
!         Search the new mesh parent element among the
!         children of the old mesh parent element:
!         --------------------------------------------
          DO j=1,8
             Eptr => NewMesh % Elements( Child(ParentId,j) )
             n = Eptr % TYPE % NumberOfNodes
             n3 = 0 ! Count matches (metodo stupido)
             DO n1 = 1,4
                DO n2 = 1,8
                   IF( Enew % NodeIndexes(n1) == Eptr % NodeIndexes(n2) ) n3 = n3+1
                END DO
             END DO
             IF ( n3 > 2 ) EXIT
          END DO
          IF( n3 < 3 ) CALL Error( 'SplitMeshEqual', 'Parent element not found' )
          Enew % BoundaryInfo % Left => Eptr
       END SELECT
    END DO

!
!   Update new mesh boundary element counts:
!   ----------------------------------------
    NewMesh % NumberOfBoundaryElements = NewElCnt - &
            NewMesh % NumberOfBulkElements
    NewMesh % MaxElementDOFs  = Mesh % MaxElementDOFs
    NewMesh % MaxElementNodes = Mesh % MaxElementNodes

    DO i=1,NewMesh % NumberOfBulkElements+NewMesh % NumberOfBoundaryElements
      NULLIFY( NewMesh % Elements(i) % EdgeIndexes )
      NULLIFY( NewMesh % Elements(i) % FaceIndexes )
    END DO

    CALL Info( 'SplitMeshEqual', '******** New mesh ********', Level=6 )
    WRITE( Message, * ) 'Nodes             : ',NewMesh % NumberOfNodes
    CALL Info( 'SplitMeshEqual', Message, Level=6 )
    WRITE( Message, * ) 'Bulk elements     : ',NewMesh % NumberOfBulkElements
    CALL Info( 'SplitMeshEqual', Message, Level=6 )
    WRITE( Message, * ) 'Boundary elements : ',NewMesh % NumberOfBoundaryElements
    CALL Info( 'SplitMeshEqual', Message, Level=6 )

    CALL CheckTimer('SplitMeshEqual',Delete=.TRUE.)

!
!   Update structures needed for parallel execution:
!   ------------------------------------------------
    CALL UpdateParallelMesh( Mesh, NewMesh )
!
!   If periodic BC given, compute boundary mesh projector:
!   ------------------------------------------------------
!
    DO i = 1,CurrentModel % NumberOfBCs
       k = ListGetInteger(CurrentModel % BCs(i) % Values, 'Periodic BC', Found, &
               minv=1, maxv=CurrentModel % NumberOFBCs )
       CurrentModel % BCs(i) % PMatrix => &
                 PeriodicProjector( CurrentModel, Mesh, i, k )
    END DO
!
!   Finalize:
!   ---------
    DEALLOCATE( Child )
    CALL ReleaseMeshEdgeTables( Mesh )
    CALL ReleaseMeshFaceTables( Mesh )

!call writemeshtodisk( NewMesh, "." )
!stop
CONTAINS

!------------------------------------------------------------------------------
    SUBROUTINE UpdateParallelMesh( Mesh, NewMesh )
!------------------------------------------------------------------------------
       TYPE(Mesh_t), POINTER :: Mesh, NewMesh
!------------------------------------------------------------------------------
       TYPE(Element_t), POINTER :: Edge, Face, Element, BoundaryElement
       INTEGER :: i,j,k,l,m,n,p,q, istat
       INTEGER, POINTER :: IntCnts(:),IntArray(:),Reorder(:)
       INTEGER, ALLOCATABLE :: list1(:), list2(:)
       LOGICAL, ALLOCATABLE :: InterfaceTag(:)

       INTEGER :: jedges
       LOGICAL :: Found
!------------------------------------------------------------------------------

       IF ( ParEnv % PEs <= 1 ) RETURN
!
!      Update mesh interfaces for parallel execution.
!      ==============================================
!
!      Try to get an agreement about the  global numbering
!      of new mesh nodes among set of processes solving
!      this specific eq. Also allocate and generate
!      all other control information needed in parallel
!      execution:
!      ----------------------------------------------------
       n = NewMesh % NumberOfNodes
       ALLOCATE( NewMesh % ParallelInfo % NeighbourList(n), stat=istat )
       IF ( istat /= 0 ) &
         CALL Fatal( 'UpdateParallelMesh', 'Allocate error.' )
       CALL AllocateVector( NewMesh % ParallelInfo % INTERFACE,n  )
       CALL AllocateVector( NewMesh % ParallelInfo % GlobalDOFs,n )

       DO i=1,n
          NULLIFY( NewMesh % ParallelInfo % NeighbourList(i) % Neighbours )
       END DO

       n = Mesh % NumberOfNodes
       NewMesh % ParallelInfo % INTERFACE = .FALSE.
       NewMesh % ParallelInfo % INTERFACE(1:n) = Mesh % ParallelInfo % INTERFACE

       NewMesh % ParallelInfo % GlobalDOFs = 0
       NewMesh % ParallelInfo % GlobalDOFs(1:n) = &
          Mesh % ParallelInfo % GlobalDOFs
!
!      My theory is, that a new node will be an
!      interface node only if all the edge or face
!      nodes which contribute to its existence are
!      interface nodes (the code immediately below
!      will only count sizes):
!      -------------------------------------------
!

       ! New version based on edges and faces (2. March 2007):
       !=====================================================
       SELECT CASE( CoordinateSystemDimension() )
          
       CASE(2)
          !
          ! Count interface nodes:
          !-----------------------
          p = 0 
          DO i = 1, Mesh % NumberOfNodes
             IF( Mesh % ParallelInfo % INTERFACE(i) ) p = p+1
          END DO
!         WRITE(*,'(A,I4,A,I6,A)')'SplitMeshEqual: PE:', &
!              Parenv % MyPE+1, ' Found',p,' interface nodes'
          !
          ! Determine possible interface edges:
          !------------------------------------
          ALLOCATE( InterfaceTag( Mesh % NumberOfEdges ) )
          InterfaceTag = .FALSE.
          DO i = 1,Mesh % NumberOfEdges
             Edge => Mesh % Edges(i)
             IF( ASSOCIATED(Edge % BoundaryInfo % Left) .AND. &
                  ASSOCIATED(Edge % BoundaryInfo % Right) ) CYCLE
             IF( .NOT.ALL( Mesh % ParallelInfo % INTERFACE( Edge % NodeIndexes ) )) CYCLE
             InterfaceTag(i) = .TRUE.
          END DO
          !
          ! Eliminate false positives based on BoundaryElement -data:
          !----------------------------------------------------------
          DO i = 1,Mesh % NumberOfBoundaryElements
             BoundaryElement => Mesh % Elements( Mesh % NumberOfBulkElements + i )
             Element => BoundaryElement % BoundaryInfo % Left
             IF( .NOT.ASSOCIATED( Element ) ) &
                  Element => BoundaryElement % BoundaryInfo % Right
             IF( .NOT.ASSOCIATED( Element ) ) CYCLE
             
             ALLOCATE( list1( SIZE( BoundaryElement % NodeIndexes )))
             list1 = BoundaryElement % NodeIndexes
             CALL Sort( SIZE(list1), list1 )
             
             DO j = 1,SIZE( Element % EdgeIndexes )
                k = Element % EdgeIndexes(j)
                Edge => Mesh % Edges(k)
                IF( SIZE( Edge % NodeIndexes ) /= SIZE(list1) ) CYCLE
                
                ALLOCATE( list2( SIZE( Edge % NodeIndexes )))
                list2 = Edge % NodeIndexes
                CALL Sort( SIZE(list2), list2 )

                Found = .TRUE.
                DO l = 1,SIZE(list2)
                   Found = Found .AND. ( list1(l)==list2(l) )
                END DO

                DEALLOCATE(list2)
                IF( Found ) InterfaceTag(k) = .FALSE.
             END DO

             DEALLOCATE(list1)
          END DO
          
          ! Mark all new interface nodes and count interface edges:
          !--------------------------------------------------------
          p = 0
          DO i = 1, Mesh % NumberOfEdges
             IF( .NOT. InterfaceTag(i) ) CYCLE
             Edge => Mesh % Edges(i)
             
             ! This is just for the edge count:
             !---------------------------------
             IF( NewMesh % ParallelInfo % INTERFACE( Mesh % NumberOfNodes + i) ) CYCLE
             
             ! Mark interface nodes and count edges:
             !--------------------------------------
             NewMesh % ParallelInfo % INTERFACE( Mesh % NumberOfNodes + i) = .TRUE.
             p = p+1

          END DO
!         WRITE(*,'(A,I4,A,I6,A)')'SplitMeshEqual: PE:', &
!              Parenv % MyPE+1, ' Found',p,' interface edges'
          
          DEALLOCATE( InterfaceTag )

          j = p
          k = 2*p ! check
          
       CASE(3)

          ! Count interface nodes:
          !-----------------------
          p = 0 
          DO i = 1, Mesh % NumberOfNodes
             IF( Mesh % ParallelInfo % INTERFACE(i) ) p = p+1
          END DO
!         WRITE(*,'(A,I4,A,I6,A)')'SplitMeshEqual: PE:', &
!              Parenv % MyPE+1, ' Found',p,' interface nodes'

          ! Determine possible interface faces:
          !------------------------------------
          ALLOCATE( InterfaceTag( Mesh % NumberOfFaces ) )
          InterfaceTag = .FALSE.
          DO i = 1,Mesh % NumberOfFaces
             Face => Mesh % Faces(i)
             IF( ASSOCIATED(Face % BoundaryInfo % Left) .AND. &
                  ASSOCIATED(Face % BoundaryInfo % Right) ) CYCLE
             IF( .NOT.ALL( Mesh % ParallelInfo % INTERFACE( Face % NodeIndexes ) )) CYCLE
             InterfaceTag(i) = .TRUE.
          END DO
          
          ! Eliminate false interface faces based on BoundaryElement -data:
          !----------------------------------------------------------------
          DO i = 1,Mesh % NumberOfBoundaryElements
             BoundaryElement => Mesh % Elements( Mesh % NumberOfBulkElements + i )
             Element => BoundaryElement % BoundaryInfo % Left
             IF( .NOT.ASSOCIATED(Element) ) &
                  Element => BoundaryElement % BoundaryInfo % Right
             IF( .NOT.ASSOCIATED(Element) ) CYCLE
             
             ALLOCATE( list1( SIZE( BoundaryElement % NodeIndexes )))
             list1 = BoundaryElement % NodeIndexes
             CALL Sort( SIZE(list1), list1 )
             
             DO j = 1,SIZE( Element % FaceIndexes )
                k = Element % FaceIndexes(j)
                Face => Mesh % Faces(k)
                IF( SIZE( Face % NodeIndexes ) /= SIZE(list1) ) CYCLE
                
                ALLOCATE( list2( SIZE( Face % NodeIndexes )))
                list2 = Face % NodeIndexes
                CALL Sort( SIZE(list2), list2 )

                Found = .TRUE.
                DO l = 1,SIZE(list2)
                   Found = Found .AND. ( list1(l)==list2(l) )
                END DO
                
                DEALLOCATE(list2)

                IF( Found ) InterfaceTag(k) = .FALSE.
             END DO

             DEALLOCATE(list1)
          END DO
          
          ! Count interface faces:
          !-----------------------
          p = 0
          DO i = 1, Mesh % NumberOfFaces
             Face => Mesh % Faces(i)
             IF( InterfaceTag(i) ) p = p+1
          END DO
!         WRITE(*,'(A,I4,A,I6,A)')'SplitMeshEqual: PE:', &
!              Parenv % MyPE+1, ' Found',p,' interface faces'
          
          ! Mark all new interface nodes and count interface edges:
          !--------------------------------------------------------
          p = 0
          DO i = 1, Mesh % NumberOfFaces
             IF( .NOT. InterfaceTag(i) ) CYCLE
             Face => Mesh % Faces(i)
             
             DO j = 1,SIZE( Face % EdgeIndexes )
                k = Face % EdgeIndexes(j)
                Edge => Mesh % Edges(k)
                
                ! This is just for the edge count:
                !---------------------------------
                IF( NewMesh % ParallelInfo % INTERFACE( Mesh % NumberOfNodes + k) ) CYCLE
                
                ! Mark interface nodes and count edges:
                !--------------------------------------
                NewMesh % ParallelInfo % INTERFACE( Mesh % NumberOfNodes + k) = .TRUE.
                p = p+1
             END DO
          END DO
!         WRITE(*,'(A,I4,A,I6,A)')'SplitMeshEqual: PE:', &
!              Parenv % MyPE+1, ' Found',p,' interface edges'
          
          DEALLOCATE( InterfaceTag )

          j = p
          k = 3*p ! check
          
       END SELECT

!======================================================================================================
       j = p
       jedges = p

!      For bricks, check also the faces:
!      ---------------------------------
       DO i = 1,Mesh % NumberOfFaces
          Face => Mesh % Faces(i) 
          IF( Face % TYPE % NumberOfNodes == 4 ) THEN
             IF ( ALL( Mesh % ParallelInfo % INTERFACE( Face % NodeIndexes ) ) ) THEN
                NewMesh % ParallelInfo % INTERFACE( Mesh % NumberOfNodes &
                     + Mesh % NumberOfEdges + i ) = .TRUE.
                j = j + 1
                k = k + Face % TYPE % NumberOfNodes
             END IF
          END IF
       END DO

!      print*,'Found',j-jedges,'interface faces'

!      CALL AllocateVector( IntCnts,  j )
!      CALL AllocateVector( IntArray, k )
!
!      Old mesh nodes were copied as is...
!      -----------------------------------
       DO i=1,Mesh % NumberOfNodes
          CALL AllocateVector( NewMesh % ParallelInfo % NeighbourList(i) % Neighbours, &
                SIZE( Mesh % ParallelInfo % Neighbourlist(i) % Neighbours) )

          NewMesh % ParallelInfo % NeighbourList(i) % Neighbours = &
             Mesh % ParallelInfo % NeighbourList(i) % Neighbours
       END DO
!
!      Take care of the new mesh internal nodes.
!      Parallel global numbering will take care
!      of the interface nodes:
!      ----------------------------------------
       DO i=Mesh % NumberOfNodes+1, NewMesh % NumberOfNodes
          IF ( .NOT. NewMesh % ParallelInfo % INTERFACE(i) ) THEN
            CALL AllocateVector( NewMesh % ParallelInfo % NeighbourList(i) % Neighbours,1 )
            NewMesh % ParallelInfo % NeighbourList(i) %  Neighbours(1) = ParEnv % MyPE
          END IF
       END DO
!
!      Copy global indices of edge and/or face nodes
!      to temporary work arrays:
!      ---------------------------------------------
!
! check also this:
!      j = 0
!      k = 0
!      DO i = 1,Mesh % NumberOfEdges
!         Edge => Mesh % Edges(i)
!         
!         ! Added check for parent elements 25.2.2007:
!         Found = .NOT.( ASSOCIATED(edge % boundaryinfo % left) &
!              .AND.  ASSOCIATED(edge % boundaryinfo % right) )
!         
!         IF ( ALL(Mesh % ParallelInfo % INTERFACE(Edge % NodeIndexes)) .AND. Found ) THEN
!            j = j + 1
!            IntCnts(j) = Edge % TYPE % NumberOfNodes
!            IntArray( k+1:k+IntCnts(j) ) = &
!                 Mesh % Parallelinfo % GlobalDOFs(Edge % NodeIndexes)
!            CALL Sort( IntCnts(j), IntArray(k+1:k+IntCnts(j)) )
!            k = k + IntCnts(j)
!         END IF
!      END DO
!      !
!      ! For bricks, check also the faces:
!      ! ---------------------------------
!      DO i = 1,Mesh % NumberOfFaces
!         Face => Mesh % Faces(i)
!         IF( Face % TYPE % NumberOfNodes == 4 ) THEN
!            IF ( ALL( Mesh % ParallelInfo % INTERFACE(Face % NodeIndexes) ) ) THEN
!               j = j + 1
!               IntCnts(j) = Face % TYPE % NumberOfNodes
!               IntArray(k+1:k+IntCnts(j)) = &
!                    Mesh % ParallelInfo % GlobalDOFs(Face % NodeIndexes)
!               CALL Sort( IntCnts(j), IntArray(k+1:k+IntCnts(j)) )
!               k = k + IntCnts(j)
!            END IF
!         END IF
!      END DO
!
!      Finally the beef, do the exchange of new
!      interfaces. The parallel global numbering
!      subroutine will also do reordering of the
!      nodes, hence the reorder array:
!      -------------------------------------------
       CALL AllocateVector( Reorder, NewMesh % NumberOfNodes )
       Reorder = (/ (i, i=1,NewMesh % NumberOfNodes) /)

       k = NewMesh % Nodes % NumberOfNodes - Mesh % Nodes % NumberOfNodes

       CALL ParallelGlobalNumbering( NewMesh, Mesh, k, IntCnts, IntArray, Reorder )

!      Account for the reordering of the nodes:
!      ----------------------------------------
       DO i=1,NewMesh % NumberOfBulkElements + &
            NewMesh % NumberOfBoundaryElements
          NewMesh % Elements(i) % NodeIndexes = &
              Reorder( NewMesh % Elements(i) % NodeIndexes )
       END DO

!      DEALLOCATE( IntCnts, IntArray, Reorder )
!      DEALLOCATE( Reorder )
!------------------------------------------------------------------------------
    END SUBROUTINE UpdateParallelMesh
  END FUNCTION SplitMeshEqual
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  SUBROUTINE ReleaseVariableList( VariableList )
!------------------------------------------------------------------------------
    TYPE(Variable_t), POINTER :: VariableList
!------------------------------------------------------------------------------
    REAL(KIND=dp), POINTER :: Ptr(:)
    LOGICAL :: GotValues
    INTEGER :: i, n, m
    TYPE(Variable_t), POINTER :: Var, Var1
!------------------------------------------------------------------------------

    Var => VariableList
    DO WHILE( ASSOCIATED( Var ) ) 

!      This is used to skip variables such as time, timestep, timestep size etc.
       IF( SIZE( Var % Values ) == Var % DOFs ) THEN
         Var => Var % Next
         CYCLE
       END IF 

       SELECT CASE( Var % Name )
       CASE( 'coordinate 1', 'coordinate 2', 'coordinate 3' )
         Var => Var % Next
         CYCLE
       END SELECT

	IF( Var % Secondary ) THEN
          Var => Var % Next
          CYCLE
        END IF

       IF (Var % DOFs > 1) THEN
         Var => Var % Next
         CYCLE
       END IF
!
!      Check that the variable is actually allocated,
!      not pointer to some other variables memory:
!      ----------------------------------------------

       GotValues = .TRUE.
       Var1 => VariableList
       DO WHILE( ASSOCIATED( Var1 ) )
          IF (.NOT.ASSOCIATED(Var,Var1)) THEN
             IF ( ASSOCIATED(Var1 % Values) ) THEN
                DO i=1,Var1 % DOFs
                   ptr => Var1 % Values(i::Var1 % DOFs)
                   IF ( ASSOCIATED(Var % Values,ptr) ) THEN
                      GotValues = .FALSE.
                      EXIT
                   END IF
                END DO
             END IF
          END IF
          IF (.NOT. GotValues) EXIT
          Var1 => Var1 % Next
       END DO

       IF (ASSOCIATED(Var % Perm)) THEN
         Var1 => VariableList
         DO WHILE(ASSOCIATED(Var1))
           IF (.NOT.ASSOCIATED(Var,Var1)) THEN
             IF (ASSOCIATED(Var % Perm,Var1 % Perm)) &
               Var1 % Perm => NULL()
           END IF
           Var1 => Var1 % Next
         END DO

         DEALLOCATE( Var % Perm)
       END IF

       IF ( GotValues ) THEN

        IF ( ASSOCIATED( Var % Values ) ) &
            DEALLOCATE( Var % Values )

         IF ( ASSOCIATED( Var % PrevValues ) ) &
	   DEALLOCATE( Var % PrevValues )

         IF ( ASSOCIATED( Var % EigenValues ) ) &
            DEALLOCATE( Var % EigenValues )

         IF ( ASSOCIATED( Var % EigenVectors ) ) &
            DEALLOCATE( Var % EigenVectors )

         IF ( ASSOCIATED( Var % SteadyValues ) ) &
            DEALLOCATE( Var % SteadyValues )

         IF ( ASSOCIATED( Var % NonlinValues ) ) &
            DEALLOCATE( Var % NonlinValues )
       END IF
       NULLIFY( Var % EigenVectors, Var % EigenValues )
       NULLIFY( Var % Values, Var % PrevValues, Var % Perm )
       NULLIFY( Var % SteadyValues, Var % NonlinValues )

       Var => Var % Next
    END DO

    Var => VariableList
    DO WHILE( ASSOCIATED( Var ) )
       IF ( Var % DOFs > 1 ) THEN
         IF ( ASSOCIATED( Var % Values ) ) &
            DEALLOCATE( Var % Values )

         IF ( ASSOCIATED( Var % Perm ) ) &
            DEALLOCATE( Var % Perm )

         IF ( ASSOCIATED( Var % PrevValues ) ) &
            DEALLOCATE( Var % PrevValues )

         IF ( ASSOCIATED( Var % EigenValues ) ) &
            DEALLOCATE( Var % EigenValues )

         IF ( ASSOCIATED( Var % EigenVectors ) ) &
            DEALLOCATE( Var % EigenVectors )

         IF ( ASSOCIATED( Var % NonlinValues ) ) &
            DEALLOCATE( Var % NonlinValues )
       END IF
       NULLIFY( Var % EigenVectors, Var % EigenValues )
       NULLIFY( Var % Values, Var % PrevValues, Var % Perm )
       NULLIFY( Var % SteadyValues, Var % NonlinValues )

       Var => Var % Next
    END DO

!   Deallocate mesh variable list:
!   ------------------------------
    Var => VariableList
    DO WHILE( ASSOCIATED( Var ) )
       Var1 => Var % Next
       DEALLOCATE( Var )
       Var => Var1
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE ReleaseVariableList
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  SUBROUTINE ReleaseMesh( Mesh )
!------------------------------------------------------------------------------
     TYPE(Mesh_t), POINTER :: Mesh
!------------------------------------------------------------------------------
     TYPE(Projector_t), POINTER :: Projector
     TYPE(Projector_t), POINTER :: Projector1
     TYPE(Variable_t), POINTER  :: Var, Var1
     INTEGER :: i,j,k
     LOGICAL :: GotIt
     REAL(KIND=dp), POINTER :: ptr(:)
!------------------------------------------------------------------------------
 
!    Deallocate mesh variables:
!    --------------------------
     CALL ReleaseVariableList( Mesh % Variables )
     Mesh % Variables => NULL()

!    Deallocate mesh geometry (nodes,elements and edges):
!    ----------------------------------------------------
     IF ( ASSOCIATED( Mesh % Nodes ) ) THEN
        IF ( ASSOCIATED( Mesh % Nodes % x ) ) DEALLOCATE( Mesh % Nodes % x )
        IF ( ASSOCIATED( Mesh % Nodes % y ) ) DEALLOCATE( Mesh % Nodes % y )
        IF ( ASSOCIATED( Mesh % Nodes % z ) ) DEALLOCATE( Mesh % Nodes % z )

        IF ( ASSOCIATED( Mesh % ParallelInfo % GlobalDOFs ) ) &
           DEALLOCATE( Mesh % ParallelInfo % GlobalDOFs )

        DEALLOCATE( Mesh % Nodes )
     END IF
     Mesh % Nodes => NULL()

     IF ( ASSOCIATED( Mesh % Edges ) ) CALL ReleaseMeshEdgeTables( Mesh )
     Mesh % Edges => NULL()

! ML
     IF ( ASSOCIATED( Mesh % Faces ) ) CALL ReleaseMeshFaceTables( Mesh )
     Mesh % Faces => NULL()

     IF (ASSOCIATED(Mesh % ViewFactors) ) &
          CALL ReleaseMeshFactorTables( Mesh % ViewFactors )
     Mesh % ViewFactors => NULL()


     IF ( ASSOCIATED( Mesh % Elements ) ) THEN
        DO i=1,Mesh % NumberOfBulkElements+Mesh % NumberOfBoundaryElements
!          Boundaryinfo structure for boundary elements
!          ---------------------------------------------
           IF ( Mesh % Elements(i) % Copy ) CYCLE

           IF ( i > Mesh % NumberOfBulkElements ) THEN
              IF ( ASSOCIATED( Mesh % Elements(i) % BoundaryInfo ) ) THEN
                 IF (ASSOCIATED(Mesh % Elements(i) % BoundaryInfo % GebhardtFactors)) THEN
                   IF ( ASSOCIATED( Mesh % Elements(i) % BoundaryInfo % &
                      GebhardtFactors % Elements ) ) THEN
                      DEALLOCATE( Mesh % Elements(i) % BoundaryInfo % &
                        GebhardtFactors % Elements )
                      DEALLOCATE( Mesh % Elements(i) % BoundaryInfo % &
                        GebhardtFactors % Factors )
                   END IF
                   DEALLOCATE( Mesh % Elements(i) % BoundaryInfo % GebhardtFactors )
                 END IF
              END IF
           END IF

           IF ( ASSOCIATED( Mesh % Elements(i) % NodeIndexes ) ) &
              DEALLOCATE( Mesh % Elements(i) % NodeIndexes )
           Mesh % Elements(i) % NodeIndexes => NULL()

           IF ( ASSOCIATED( Mesh % Elements(i) % EdgeIndexes ) ) &
              DEALLOCATE( Mesh % Elements(i) % EdgeIndexes )
           Mesh % Elements(i) % EdgeIndexes => NULL()

           IF ( ASSOCIATED( Mesh % Elements(i) % FaceIndexes ) ) &
              DEALLOCATE( Mesh % Elements(i) % FaceIndexes )
           Mesh % Elements(i) % FaceIndexes => NULL()

           IF ( ASSOCIATED( Mesh % Elements(i) % DGIndexes ) ) &
              DEALLOCATE( Mesh % Elements(i) % DGIndexes )
           Mesh % Elements(i) % DGIndexes => NULL()

           IF ( ASSOCIATED( Mesh % Elements(i) % BubbleIndexes ) ) &
              DEALLOCATE( Mesh % Elements(i) % BubbleIndexes )
           Mesh % Elements(i) % BubbleIndexes => NULL()

           IF ( ASSOCIATED( Mesh % Elements(i) % PDefs ) ) &
              DEALLOCATE( Mesh % Elements(i) % PDefs )
           Mesh % Elements(i) % PDefs => NULL()
 
        END DO
        DEALLOCATE( Mesh % Elements )
     END IF
     Mesh % Elements => NULL()

!    Deallocate mesh to mesh projector structures:
!    ---------------------------------------------
     Projector => Mesh % Projector
     DO WHILE( ASSOCIATED( Projector ) )
        CALL FreeMatrix( Projector % Matrix )
        CALL FreeMatrix( Projector % TMatrix )
        Projector1 => Projector
        Projector => Projector % Next
        DEALLOCATE( Projector1 )
     END DO
     Mesh % Projector => NULL()

!    Deallocate quadrant tree (used in mesh to mesh interpolation):
!    --------------------------------------------------------------
     CALL FreeQuadrantTree( Mesh % RootQuadrant )
     Mesh % RootQuadrant => NULL()

!    DEALLOCATE( Mesh )

!------------------------------------------------------------------------------
  END SUBROUTINE ReleaseMesh
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE ReleaseMeshEdgeTables( Mesh )
!------------------------------------------------------------------------------
    TYPE(Mesh_t), POINTER :: Mesh
!------------------------------------------------------------------------------
    INTEGER :: i
    TYPE(Element_t), POINTER :: Edge
!------------------------------------------------------------------------------
    IF ( ASSOCIATED( Mesh % Edges ) ) THEN
       DO i=1,Mesh % NumberOfEdges
          Edge => Mesh % Edges(i)
          IF ( ASSOCIATED( Edge % NodeIndexes ) ) THEN
             DEALLOCATE( Edge % NodeIndexes )
          END IF
          IF ( ASSOCIATED( Edge % BoundaryInfo ) ) THEN
             DEALLOCATE( Edge % BoundaryInfo )
          END IF
       END DO

       DEALLOCATE( Mesh % Edges )
    END IF
    NULLIFY( Mesh % Edges )
    Mesh % NumberOfEdges = 0

    DO i=1,Mesh % NumberOfBulkElements
       IF ( ASSOCIATED( Mesh % Elements(i) % EdgeIndexes ) ) THEN
          DEALLOCATE( Mesh % Elements(i) % EdgeIndexes )
          NULLIFY( Mesh % Elements(i) % EdgeIndexes )
       END IF
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE ReleaseMeshEdgeTables
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  SUBROUTINE ReleaseMeshFaceTables( Mesh )
!------------------------------------------------------------------------------
    TYPE(Mesh_t), POINTER :: Mesh
!------------------------------------------------------------------------------
    INTEGER :: i
    TYPE(Element_t), POINTER :: Face
!------------------------------------------------------------------------------
    IF ( ASSOCIATED( Mesh % Faces ) ) THEN
       DO i=1,Mesh % NumberOfFaces
          Face => Mesh % Faces(i)
          IF ( ASSOCIATED( Face % NodeIndexes ) ) THEN
             DEALLOCATE( Face % NodeIndexes )
          END IF
          IF ( ASSOCIATED( Face % BoundaryInfo ) ) THEN
             DEALLOCATE( Face % BoundaryInfo )
          END IF
       END DO

       DEALLOCATE( Mesh % Faces )
    END IF
    NULLIFY( Mesh % Faces )
    Mesh % NumberOfFaces = 0

    DO i=1,Mesh % NumberOfBulkElements
       IF ( ASSOCIATED( Mesh % Elements(i) % FaceIndexes ) ) THEN
          DEALLOCATE( Mesh % Elements(i) % FaceIndexes )
          NULLIFY( Mesh % Elements(i) % FaceIndexes )
       END IF
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE ReleaseMeshFaceTables
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  SUBROUTINE ReleaseMeshFactorTables( Factors )
!------------------------------------------------------------------------------
    TYPE(Factors_t), POINTER :: Factors(:)
!------------------------------------------------------------------------------
    INTEGER :: i
!------------------------------------------------------------------------------
    IF ( ASSOCIATED( Factors ) ) THEN
       DO i=1,SIZE( Factors)
          IF (ASSOCIATED(Factors(i) % Factors))  DEALLOCATE(Factors(i) % Factors)
          IF (ASSOCIATED(Factors(i) % Elements)) DEALLOCATE(Factors(i) % Elements)
       END DO
       DEALLOCATE(  Factors )
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE ReleaseMeshFactorTables
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE SetCurrentMesh( Model, Mesh )
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    TYPE(Mesh_t),  POINTER :: Mesh
!------------------------------------------------------------------------------
    Model % Variables => Mesh % Variables

    Model % Mesh  => Mesh
    Model % Nodes => Mesh % Nodes
    Model % NumberOfNodes = Mesh % NumberOfNodes
    Model % Nodes % NumberOfNodes = Mesh % NumberOfNodes

    Model % Elements => Mesh % Elements
    Model % MaxElementNodes = Mesh % MaxElementNodes
    Model % NumberOfBulkElements = Mesh % NumberOfBulkElements
    Model % NumberOfBoundaryElements = Mesh % NumberOfBoundaryElements
!------------------------------------------------------------------------------
  END SUBROUTINE SetCurrentMesh
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE DisplaceMesh( Mesh, Update, SIGN, Perm, DOFs, StabRecomp )
!------------------------------------------------------------------------------
    TYPE(Mesh_t) , POINTER :: Mesh 
    REAL(KIND=dp) :: Update(:)
    INTEGER :: DOFs,SIGN,Perm(:)
    LOGICAL, OPTIONAL :: StabRecomp

    INTEGER :: i,k
    LOGICAL :: StabFlag

    TYPE(Nodes_t) :: ElementNodes
    TYPE(Element_t), POINTER :: Element

    DO i=1,MIN( SIZE(Perm), SIZE(Mesh % Nodes % x) )
       k = Perm(i)
       IF ( k > 0 ) THEN
         k = DOFs * (k-1)
         Mesh % Nodes % x(i)   = Mesh % Nodes % x(i) + SIGN * Update(k+1)
         IF ( DOFs > 1 ) &
           Mesh % Nodes % y(i) = Mesh % Nodes % y(i) + SIGN * Update(k+2)
         IF ( DOFs > 2 ) &
           Mesh % Nodes % z(i) = Mesh % Nodes % z(i) + SIGN * Update(k+3)
        END IF
    END DO

    StabFlag = .TRUE.
    IF ( PRESENT( StabRecomp ) ) StabFlag = StabRecomp

    IF ( SIGN == 1 .AND. StabFlag ) THEN
       k = Mesh % MaxElementDOFs
       CALL AllocateVector( ElementNodes % x,k )
       CALL AllocateVector( ElementNodes % y,k )
       CALL AllocateVector( ElementNodes % z,k )

       DO i=1,Mesh % NumberOfBulkElements
          Element => Mesh % Elements(i)
          IF ( ANY( Perm( Element % NodeIndexes ) == 0 ) ) CYCLE

          k = Element % TYPE % NumberOfNodes
          ElementNodes % x(1:k) = Mesh % Nodes % x(Element % NodeIndexes)
          ElementNodes % y(1:k) = Mesh % Nodes % y(Element % NodeIndexes)
          ElementNodes % z(1:k) = Mesh % Nodes % z(Element % NodeIndexes)
          IF ( Mesh % Stabilize ) THEN
             CALL StabParam( Element,ElementNodes,k, &
                          Element % StabilizationMk, Element % Hk )
          ELSE
             Element % hK = ElementDiameter( Element, ElementNodes )
          END IF
       END DO

       DEALLOCATE( ElementNodes % x, ElementNodes % y, ElementNodes % z)
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE DisplaceMesh
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE ConvertToACTetra( Tetra )
!******************************************************************************
!
!  DESCRIPTION:
!     Convert tetrahedral element to Ainsworth & Coyle type tetrahedron.
!
!  ARGUMENTS:
!    Type(Element_t) :: Tetra
!      INOUT: Tetrahedral element to convert
!    
!******************************************************************************
!------------------------------------------------------------------------------
    USE PElementMaps, ONLY : getTetraEdgeMap, getTetraFaceMap
    IMPLICIT NONE
    
    TYPE(Element_t), POINTER :: Tetra
    INTEGER :: i, globalMin, globalMax, globalMinI
    INTEGER, DIMENSION(3) :: face, globalFace
    INTRINSIC MIN, MAX, CSHIFT

    ! Sanity check
    IF (Tetra % TYPE % ElementCode /= 504 .OR. &
         .NOT. ASSOCIATED(Tetra % PDefs)) THEN
       CALL Warn('MeshUtils::ConvertToACTetra','Element to convert not p tetrahedron!')
       RETURN
    END IF    
   
    ! Find global min and max vertices
    globalMin = Tetra % NodeIndexes(1)
    globalMinI = 1
    globalMax = Tetra % NodeIndexes(1)
    DO i=2,4
       ! Find min
       IF (globalMin > Tetra % NodeIndexes(i)) THEN
          globalMin = Tetra % NodeIndexes(i)
          globalMinI = i
       ELSE IF (globalMax < Tetra % NodeIndexes(i)) THEN
          globalMax = Tetra % NodeIndexes(i)
       END IF
    END DO
    
    ! Get face containing global min (either face 1 or 2)
    IF (globalMinI == 4) THEN
       face = getTetraFaceMap(2)
    ELSE
       face = getTetraFaceMap(1)
    END IF
    globalFace(1:3) = Tetra % NodeIndexes(face)

    ! Rotate face until first local index is min global
    DO 
       ! Check if first node matches global min node
       IF (globalMin == globalFace(1)) EXIT
       
       globalFace(1:3) = CSHIFT(globalFace,1)
    END DO
    ! Assign new local numbering
    Tetra % NodeIndexes(face) = globalFace(1:3)

    ! Face 3 now contains global max
    face = getTetraFaceMap(3)
    globalFace(1:3) = Tetra % NodeIndexes(face)
    ! Rotate face until last local index is max global
    DO 
       ! Chech if last node matches global max node
       IF (globalMax == globalFace(3)) EXIT
       
       globalFace(1:3) = CSHIFT(globalFace,1)
    END DO
    ! Assign new local numbering
    Tetra % NodeIndexes(face) = globalFace(1:3)

    ! Set AC tetra type
    IF (Tetra % NodeIndexes(2) < Tetra % NodeIndexes(3)) THEN
       Tetra % PDefs % TetraType = 1
    ELSE IF (Tetra % NodeIndexes(3) < Tetra % NodeIndexes(2)) THEN
       Tetra % PDefs % TetraType = 2
    ELSE 
       CALL Fatal('MeshUtils::ConvertToACTetra','Corrupt element type')
    END IF
   
  END SUBROUTINE ConvertToACTetra


!------------------------------------------------------------------------------
  SUBROUTINE AssignLocalNumber( EdgeElement, Element, Mesh )
!******************************************************************************
!
!  DESCRIPTION:
!     Assign local number of edge to given boundary element. Also copies all 
!     p element attributes from element edge to boundary edge.
!
!  ARGUMENTS:
!    Type(Element_t), POINTER :: EdgeElement, Element
!      INOUT: Edge element to which assign local number and element 
!        with some global numbering to use to assign local number.
!    
!    Type(Mesh_t), POINTER :: Mesh
!      INPUT: Finite element mesh containing faces and edges.
!
!******************************************************************************
!------------------------------------------------------------------------------
    USE PElementMaps, ONLY : getFaceEdgeMap 
    IMPLICIT NONE
    ! Parameters
    TYPE(Element_t), POINTER :: EdgeElement, Element 
    TYPE(Mesh_t), POINTER :: Mesh
    ! Variables
    INTEGER i,j,n,edgeNumber, numEdges, bMap(4)
    TYPE(Element_t), POINTER :: Edge
    
    ! Get number of points, edges or faces
    numEdges = 0
    SELECT CASE (Element % TYPE % DIMENSION)
    CASE (2)
       numEdges = Element % TYPE % NumberOfEdges
    CASE (3)   
       numEdges = Element % TYPE % NumberOfFaces
    CASE DEFAULT
       WRITE (*,*) 'MeshUtils::AssignLocalNumber Unsupported dimension'
       RETURN
    END SELECT

    ! For each edge or face in element try to find local number
    DO edgeNumber=1, numEdges
       ! If edges have not been created, stop search. This should not happen, actually.
       IF (.NOT. ASSOCIATED(Element % EdgeIndexes)) THEN
          ! EdgeElement % localNumber = 0
          RETURN
       END IF

       Edge => GetElementEntity(Element,edgeNumber,Mesh)

       ! Edge element not found. This should not be possible, unless there
       ! is an error in the mesh read in process..
       IF (.NOT. ASSOCIATED(Edge)) THEN
          CALL Warn('MeshUtils::AssignLocalNumber','Edge element not found')
          ! EdgeElement % localNumber = 0
          RETURN
       END IF

       n = 0
       ! For each element node
       DO i=1, Edge % TYPE % NumberOfNodes
          ! For each node in edge element
          DO j=1, EdgeElement % TYPE % NumberOfNodes
             ! If edge and edgeelement node match increment counter
             IF (Edge % NodeIndexes(i) == EdgeElement % NodeIndexes(j)) n = n + 1
          END DO
       END DO

       ! If all nodes are on boundary, edge was found
       IF (n == EdgeElement % TYPE % NumberOfNodes) THEN
          EdgeElement % PDefs % localNumber = edgeNumber

          ! Change ordering of global nodes to match that of element
          bMap = getElementBoundaryMap( Element, edgeNumber )
          EdgeElement % NodeIndexes(1:n) = Element % NodeIndexes(bMap(1:n))

          ! Copy attributes of edge element to boundary element
          ! Misc attributes
          EdgeElement % PDefs % isEdge = Edge % PDefs % isEdge
          
          ! Gauss points
          EdgeElement % PDefs % GaussPoints = Edge % PDefs % GaussPoints
          ! Element p (and boundary bubble dofs)
          EdgeElement % BDOFs = Edge % BDOFs
          EdgeElement % PDefs % P = Edge % PDefs % P

          ! If this boundary has edges copy edge indexes
          IF (ASSOCIATED(Edge % EdgeIndexes)) THEN
             ! Allocate element edges to element
             n = Edge % TYPE % NumberOfEdges
             bmap(1:4) = getFaceEdgeMap( Element, edgeNumber )
             
             IF ( ASSOCIATED( EdgeElement % EdgeIndexes) ) THEN
                DEALLOCATE( EdgeElement % EdgeIndexes )
             END IF
             
             CALL AllocateVector( EdgeElement % EdgeIndexes, n )
             ! Copy edges from edge to boundary edge
             DO i=1,n
                EdgeElement % EdgeIndexes(i) = Element % EdgeIndexes(bmap(i))
             !    EdgeElement % EdgeIndexes(i) = Element % EdgeIndexes(i)
             END DO
          END IF
          
          ! Edge fields copied and local edge found so return
          RETURN
       END IF
    END DO

    ! If we are here local number not found
    CALL Warn('MeshUtils::AssignLocalNumber','Unable to find local edge')
    ! EdgeElement % localNumber = 1
  CONTAINS

    FUNCTION GetElementEntity(Element, which, Mesh) RESULT(Entity)
      IMPLICIT NONE

      TYPE(Element_t), POINTER :: Element, Entity 
      TYPE(Mesh_t), POINTER :: Mesh
      INTEGER :: which

      NULLIFY(Entity)
      ! Switch by element dimension
      SELECT CASE (Element % TYPE % DIMENSION)
         CASE (2)
            Entity => Mesh % Edges( Element % EdgeIndexes(which))
         CASE (3)
            Entity => Mesh % Faces( Element % FaceIndexes(which))
         CASE DEFAULT
            WRITE (*,*) 'AssignLocalNumber::GetElementEntity: Unsupported dimension'
            RETURN
      END SELECT
    END FUNCTION GetElementEntity
  END SUBROUTINE AssignLocalNumber
    

!------------------------------------------------------------------------------
  FUNCTION getElementMaxDOFs( Mesh, Element ) RESULT(dofs)
!******************************************************************************
!
!  DESCRIPTION:
!     Based on element degrees of freedom, return the sum of element
!     degrees of freedom.
!
!  ARGUMENTS:
!
!    Type(Mesh_t), POINTER :: Mesh
!      INPUT: Finite element mesh
!
!    Type(Element_t), POINTER :: Element
!      INPUT: Element to get maximum dofs for
!
!  FUNCTION VALUE:
!    REAL(KIND=dp) :: dofs
!       maximum number of dofs for Element
!    
!******************************************************************************
!------------------------------------------------------------------------------
    IMPLICIT NONE

    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Element_t), POINTER :: Element
    TYPE(ELement_t), POINTER :: Edge, Face
    INTEGER :: i, edgeDofs, faceDofs, dofs
    
    ! Get sum of edge dofs if any
    edgeDofs = 0
    IF (ASSOCIATED(Element % EdgeIndexes)) THEN
       DO i=1, Element % TYPE % NumberOfEdges
          Edge => Mesh % Edges(Element % EdgeIndexes(i))
          edgeDofs = edgeDofs + Edge % BDOFs
       END DO
    END IF

    ! Get sum of face dofs if any
    faceDofs = 0
    IF (ASSOCIATED(Element % FaceIndexes)) THEN
       DO i=1, Element % TYPE % NumberOfFaces
          Face => Mesh % Faces(Element % FaceIndexes(i))
          faceDofs = faceDofs + Face % BDOFs
       END DO
    END IF

    ! Get sum of all dofs in element
    dofs = Element % TYPE % NumberOfNodes + &
         edgeDofs + faceDofs + Element % BDOFs
  END FUNCTION getElementMaxDOFs




!------------------------------------------------------------------------------
  SUBROUTINE MakePermUsingMask( Model,Solver,Mesh,MaskName, &
       OptimizeBW, Perm, LocalNodes, MaskOnBulk )
!------------------------------------------------------------------------------
! Creates a permutation table for bodies or boundaries using a free chosen string
! as mask. The resulting permutation is optimized in order, if requested. The
! subroutine is intended to help in saving boundary data in an ordered manner,
! but it can find other uses as well. Currently the implementation is limited
! to normal Lagrangian elements.
!------------------------------------------------------------------------------
    TYPE(Model_t)  :: Model
    TYPE(Mesh_t)   :: Mesh
    TYPE(SOlver_t) :: Solver
    INTEGER :: LocalNodes
    LOGICAL :: OptimizeBW
    INTEGER :: Perm(:)
    CHARACTER(LEN=*) :: MaskName
    LOGICAL, OPTIONAL :: MaskOnBulk
!------------------------------------------------------------------------------
    INTEGER, POINTER :: InvPerm(:)
    TYPE(ListMatrix_t), POINTER :: ListMatrix(:)
    INTEGER :: t,i,j,k,l,m,k1,k2,n,p,q,e1,e2,f1,f2,This,bf_id   
    LOGICAL :: Flag, Found, FirstRound
    INTEGER :: Indexes(30), ElemStart, ElemFin, Width
    TYPE(ListMatrixEntry_t), POINTER :: CList, Lptr
    TYPE(Element_t), POINTER :: CurrentElement,Elm
    REAL(KIND=dp) :: MinDist, Dist
!------------------------------------------------------------------------------
    
    ! First check if there are active elements for this mask
    IF( PRESENT( MaskOnBulk ) ) MaskOnBulk = .FALSE.
    ElemStart = HUGE(ElemStart) 
    ElemFin = 0     
    DO l = 1, Model % NumberOfBodyForces
       IF(ListCheckPresent( Model % BodyForces(l) % Values,MaskName) ) THEN
          ElemStart = 1
          ElemFin = Mesh % NumberOfBulkElements
          IF( PRESENT( MaskOnBulk ) ) MaskOnBulk = .TRUE.
          EXIT
       END IF
    END DO
    DO l = 1, Model % NumberOfBCs
       IF( ListCheckPresent(Model % BCs(l) % Values,MaskName ) ) THEN
          ElemStart = MIN( ElemStart, Mesh % NumberOfBulkElements + 1)
          ElemFin = Mesh % NumberOfBulkElements + Mesh % NumberOFBoundaryElements
          EXIT
       END IF
    END DO
    
    IF( ElemFin - ElemStart <= 0) THEN
       LocalNodes = 0
       RETURN
    END IF


    k = 0
    Perm = 0
    FirstRound = .TRUE.

    ! Loop over the active elements
    ! 1st round initial numbering is given
    ! 2nd round a list matrix giving all the connections is created

100 DO t=ElemStart, ElemFin
       
       CurrentElement => Mesh % Elements(t)
       
       Found = .FALSE.
       IF(t <= Mesh % NumberOfBulkElements) THEN
          l = CurrentElement % BodyId
	  bf_id = ListGetInteger( Model % Bodies(l) % Values, 'Body Force',Found)
	  IF( bf_id>0 ) THEN
            IF(ListCheckPresent( Model % BodyForces(bf_id) % Values, MaskName )) Found = .TRUE.
	  END IF 
       ELSE
          DO l=1, Model % NumberOfBCs
             IF ( Model % BCs(l) % Tag /= CurrentElement % BoundaryInfo % Constraint ) CYCLE
             IF( ListCheckPresent(Model % BCs(l) % Values,MaskName ) ) Found = .TRUE.
          END DO
       END IF       
       IF( .NOT. Found ) CYCLE       
       
       n = CurrentElement % NDOFs               
       Indexes(1:n) = CurrentElement % NodeIndexes(1:n)
       
       IF( FirstRound ) THEN
          DO i=1,n
             j = Indexes(i)
             IF ( Perm(j) == 0 ) THEN
                k = k + 1
                Perm(j) = k
             END IF
          END DO
       ELSE
          DO i=1,n
             k1 = Perm(Indexes(i))
             IF ( k1 <= 0 ) CYCLE
             DO j=1,n
                k2 = Perm(Indexes(j))
                IF ( k2 <= 0 ) CYCLE
                Lptr => List_GetMatrixIndex( ListMatrix,k1,k2 )
             END DO
          END DO
       END IF
    END DO
    LocalNodes = k

    IF( .NOT. OptimizeBW ) RETURN

    IF(FirstRound) THEN
       ! Allocate space 
       NULLIFY( ListMatrix )
       ALLOCATE( ListMatrix(LocalNodes) )
       DO i=1,LocalNodes
          ListMatrix(i) % Degree = 0
          NULLIFY( ListMatrix(i) % Head )
       END DO
       FirstRound = .FALSE.

       ! Find the node in the lower left corner at give it the 1st index
       ! since it will probably determine the 1st index
       MinDist = HUGE(MinDist)
       DO i=1,SIZE(Perm)
          IF( Perm(i) <= 0) CYCLE
          Dist = Mesh % Nodes % x(i) + Mesh % Nodes % y(i) + Mesh % Nodes % z(i)
          IF(Dist < MinDist) THEN
             MinDist = Dist
             j = i
          END IF
       END DO

       ! Find the 1st node and swap it with the lower corner
       DO i=1,SIZE(Perm)
          IF( Perm(i) == 1) EXIT
       END DO       
       Perm(i) = Perm(j)
       Perm(j) = 1

       GOTO 100
    END IF

!------------------------------------------------------------------------------

    ALLOCATE( InvPerm(LocalNodes) )
    InvPerm = 0
    DO i=1,SIZE(Perm)
       IF (Perm(i)>0) InvPerm(Perm(i)) = i
    END DO

    ! The bandwidth optimization for lines results to perfectly ordered 
    ! permutations. If there is only one line the 1st node should be the 
    ! lower left corner.

    Flag = .TRUE.
    Width = OptimizeBandwidth( ListMatrix, Perm, InvPerm, &

         LocalNodes, Flag, Flag, MaskName )

    ! We really only need the permutation, as there will be no matrix equation
    ! associated with it.
    DEALLOCATE( InvPerm )
    CALL List_FreeMatrix( LocalNodes, ListMatrix )

!------------------------------------------------------------------------------
  END SUBROUTINE MakePermUsingMask
!------------------------------------------------------------------------------




!------------------------------------------------------------------------
! Find a point in the mesh structure
! There are two strategies:
! 1) Recursive where the same routine is repeated with sloppier criteria
! 2) One-sweep strategy where the best hit is registered and used if of 
!    acceptable accuracy. 
! There are two different epsilons that control the search. One for the 
! rough test in absolute coordinates and another one for the more accurate
! test in local coordinates.   
!-------------------------------------------------------------------------
  FUNCTION PointInMesh(Solver, GlobalCoords, LocalCoords, HitElement, &
      CandElement, ExtInitialize ) RESULT ( Hit )
        
    TYPE(Solver_t) :: Solver
    REAL(KIND=dp) :: GlobalCoords(3), LocalCoords(3)
    TYPE(Element_t), POINTER :: HitElement 
    TYPE(Element_t), POINTER, OPTIONAL :: CandElement
    LOGICAL, OPTIONAL :: ExtInitialize
    LOGICAL :: Hit
!-------------------------------------------------------------------------
    LOGICAL :: Initialize, Allocated = .FALSE., Stat, DummySearch, &
        MaskExists, Found, IsRecursive
    INTEGER :: i,j,k,n,bf_id,dim,mini
    REAL(KIND=dp) :: u,v,w,dist,mindist,MinLocalCoords(3)
    TYPE(Nodes_t) :: ElementNodes
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER, POINTER :: NodeIndexes(:)
    TYPE(Element_t), POINTER :: CurrentElement
    TYPE(Quadrant_t), POINTER, SAVE :: RootQuadrant =>Null(), LeafQuadrant
    REAL(kind=dp) :: BoundingBox(6), eps2, eps1 = 1e-3, GlobalEps, LocalEps
    CHARACTER(LEN=MAX_NAME_LEN) :: MaskName


    SAVE :: Allocated, ElementNodes, DummySearch, Mesh, MaskName, MaskExists, &
        GlobalEps, LocalEps, IsRecursive


    IF( PRESENT( ExtInitialize ) ) THEN
      Initialize = ExtInitialize
    ELSE
      Initialize = .NOT. Allocated 
    END IF

    IF( Initialize ) THEN
      Mesh => Solver % Mesh
      n = Mesh % MaxElementNodes
      IF( Allocated ) THEN
        DEALLOCATE( ElementNodes % x, ElementNodes % y, ElementNodes % z )
      END IF
      ALLOCATE( ElementNodes % x(n), ElementNodes % y(n), ElementNodes % z(n))
      Allocated = .TRUE.

      IsRecursive = ListGetLogical( CurrentModel % Simulation,&
          'Interpolation Search Recursive',Stat )
!      IF(.NOT. Stat ) IsRecursive = .TRUE.

      LocalEps = ListGetConstReal( CurrentModel % Simulation,  &
          'Interpolation Local Epsilon', Stat )
      IF(.NOT. stat) LocalEps = 1.0e-10

      GlobalEps = ListGetConstReal( CurrentModel % Simulation,  &
          'Interpolation Global Epsilon', Stat ) 
      IF(.NOT. stat) THEN
        IF( IsRecursive ) THEN
          GlobalEps = 2.0e-10
        ELSE
          GlobalEps = 1.0e-4
        END IF
      END IF

      DummySearch = ListGetLogical( CurrentModel % Simulation,&
          'Interpolation Search Dummy',Stat )

      MaskName = ListGetString( CurrentModel % Simulation,&
          'Interpolation Search Mask',MaskExists )

      IF( ASSOCIATED( Mesh % RootQuadrant ) ) THEN
        CALL FreeQuadrantTree( Mesh % RootQuadrant )
        Mesh % RootQuadrant => Null()
      END IF
    END IF
      

    !-----------------------------------------------
    ! Create the octree search structure, if needed 
    !-----------------------------------------------
    IF ( .NOT. ( DummySearch .OR.  ASSOCIATED( Mesh % RootQuadrant ) ) ) THEN
      BoundingBox(1) = MINVAL( Mesh % Nodes % x )
      BoundingBox(2) = MINVAL( Mesh % Nodes % y )
      BoundingBox(3) = MINVAL( Mesh % Nodes % z )
      BoundingBox(4) = MAXVAL( Mesh % Nodes % x )
      BoundingBox(5) = MAXVAL( Mesh % Nodes % y )
      BoundingBox(6) = MAXVAL( Mesh % Nodes % z )
      
      eps2 = eps1 * MAXVAL( BoundingBox(4:6) - BoundingBox(1:3) )
      BoundingBox(1:3) = BoundingBox(1:3) - eps2
      BoundingBox(4:6) = BoundingBox(4:6) + eps2
      
      CALL BuildQuadrantTree( Mesh,BoundingBox,Mesh % RootQuadrant)
      RootQuadrant => Mesh % RootQuadrant
      IF (.NOT. ASSOCIATED(RootQuadrant) ) THEN
        CALL Warn('PointInMesh','No RootQuadrant associated')
        RETURN
      END IF
    END IF


    Hit = .FALSE.

    ! Check that the previous hit is not hit even now
    !-------------------------------------------------
    IF( PRESENT( CandElement ) ) THEN

      IF( ASSOCIATED(CandElement)) THEN

        CurrentElement => CandElement
        n = CurrentElement % TYPE % NumberOfNodes
        NodeIndexes => CurrentElement % NodeIndexes
        
        ElementNodes % x(1:n) = Mesh % Nodes % x(NodeIndexes)
        ElementNodes % y(1:n) = Mesh % Nodes % y(NodeIndexes)
        ElementNodes % z(1:n) = Mesh % Nodes % z(NodeIndexes)
        
        IF ( PointInElement( CurrentElement, ElementNodes, &
            GlobalCoords, LocalCoords ) ) THEN
          Hit = .TRUE.
          HitElement => CurrentElement
          RETURN
        END IF
      END IF
    END IF


    Eps1 = GlobalEps
    Eps2 = LocalEps


100 IF( DummySearch ) THEN

      mindist = HUGE( mindist ) 
      
      !----------------------------------------------------------
      ! Go through all bulk elements in a dummy search.
      ! This algorithm is mainly here for debugging purposes, or
      ! if just a few nodes need to be searched.
      !----------------------------------------------------------
      DO k=1,Mesh % NumberOfBulkElements
        CurrentElement => Mesh % Elements(k)
        n = CurrentElement % TYPE % NumberOfNodes
        NodeIndexes => CurrentElement % NodeIndexes
        
        IF( MaskExists ) THEN
          bf_id = ListGetInteger( CurrentModel % Bodies(CurrentElement % BodyId) % Values, &
              'Body Force', Found )
          IF( .NOT. Found ) CYCLE
          IF(.NOT. ListCheckPresent( CurrentModel % BodyForces(bf_id) % Values,MaskName) ) CYCLE
        END IF

        ElementNodes % x(1:n) = Mesh % Nodes % x(NodeIndexes)
        ElementNodes % y(1:n) = Mesh % Nodes % y(NodeIndexes)
        ElementNodes % z(1:n) = Mesh % Nodes % z(NodeIndexes)
        
        Hit = PointInElement( CurrentElement, ElementNodes, &
            GlobalCoords, LocalCoords, Eps1, Eps2, LocalDistance = dist )
        IF( dist < mindist ) THEN
          mini = k
          mindist = dist
        END IF
        IF( Hit ) EXIT
      END DO      
    ELSE
      !-----------------------------------------------
      ! Find the right element using an octree search
      ! This is the preferred algorithms of the two.
      !-----------------------------------------------
      NULLIFY(CurrentElement)
      CALL FindLeafElements(GlobalCoords, Mesh % MeshDim, RootQuadrant, LeafQuadrant)
      IF ( ASSOCIATED(LeafQuadrant) ) THEN
        DO j=1, LeafQuadrant % NElemsInQuadrant
          k = LeafQuadrant % Elements(j)
          CurrentElement => Mesh % Elements(k)
          
          IF( MaskExists ) THEN
            bf_id = ListGetInteger( CurrentModel % Bodies(CurrentElement % BodyId) % Values, &
                'Body Force', Found )
            IF( .NOT. Found ) CYCLE
            IF(.NOT. ListCheckPresent( CurrentModel % BodyForces(bf_id) % Values,MaskName) ) CYCLE
          END IF
          
          n = CurrentElement % TYPE % NumberOfNodes
          NodeIndexes => CurrentElement % NodeIndexes
                    
          ElementNodes % x(1:n) = Mesh % Nodes % x(NodeIndexes)
          ElementNodes % y(1:n) = Mesh % Nodes % y(NodeIndexes)
          ElementNodes % z(1:n) = Mesh % Nodes % z(NodeIndexes)
          
          Hit = PointInElement( CurrentElement, ElementNodes, &
              GlobalCoords, LocalCoords, Eps1, Eps2, LocalDistance = dist ) 
          IF( dist < mindist ) THEN
            mini = k
            mindist = dist
            MinLocalCoords = LocalCoords
          END IF
          IF( Hit ) EXIT
        END DO
      END IF      
    END IF

    IF( .NOT. Hit ) THEN
      IF( IsRecursive ) THEN
        Eps1 = 10.0 * Eps1
        Eps2 = 10.0 * Eps2
        IF( Eps1 <= 1.0_dp ) GOTO 100
      ELSE
        IF( mindist < Eps1 ) THEN
          CurrentElement => Mesh % Elements(k)
          LocalCoords = MinLocalCoords
          Hit = .TRUE.
        END IF
      END IF
    END IF

    IF( Hit ) HitElement => CurrentElement
    
  END FUNCTION PointInMesh



!--------------------------------------------------------------------------
!  This subroutine finds the structure of an extruded mesh even though it is 
! given in an unstructured formar. The routine may be used by some special
! solvers that employ the special character of the mesh.
! The extrusion is found for a given direction and for each node the corresponding 
! up and down, and thereafter top and bottom node is computed.
!-----------------------------------------------------------------------------
  SUBROUTINE DetectExtrudedStructure( Mesh, Direction, Tolerance, MaskPerm, &
      TopNodePointer, BotNodePointer, UpNodePointer, DownNodePointer )
    
    USE CoordinateSystems

    TYPE(Mesh_t), POINTER :: Mesh
    REAL(KIND=dp) :: Direction(3)
    REAL(KIND=dp), OPTIONAL :: Tolerance
    INTEGER, POINTER, OPTIONAL :: MaskPerm(:)
    INTEGER, POINTER, OPTIONAL :: TopNodePointer(:), BotNodePointer(:), &
        UpNodePointer(:), DownNodePointer(:)
!-----------------------------------------------------------------------------
    TYPE(Element_t), POINTER :: Element
    TYPE(Nodes_t) :: Nodes
    INTEGER :: i,j,k,n,ii,jj,dim, nsize, elem, TopNodes, BotNodes, Rounds
    INTEGER, POINTER :: NodeIndexes(:)
    LOGICAL :: MaskExists, UpActive, DownActive, GotIt, Found
    REAL(KIND=dp) :: at0, at1, Length, UnitVector(3), ElemVector(3), DotPro, Eps, CPUTime
    INTEGER, POINTER :: TopPointer(:), BotPointer(:), UpPointer(:), DownPointer(:)

   
    CALL Info('DetectExtrudedStructure','Determining extruded structure')
    at0 = CPUTime()

    ! Choose active direction coordinate and set corresponding unit vector
    !---------------------------------------------------------------------
    
    Length = SQRT( SUM( Direction ** 2 ) )
    IF( Length < EPSILON(Length) ) THEN
      CALL Warn('DetectExtrudedStructure','Invalid direction vector, exiting...')
      RETURN
    END IF
    UnitVector = Direction / Length
    
    WRITE(Message,'(A,3F8.3)') 'Unit vector of direction:',UnitVector
    CALL Info('DetectExtrudedStructure',Message)

    ! Check which direction is active
    !---------------------------------------------------------------------
    UpActive = PRESENT( UpNodePointer) .OR. PRESENT ( TopNodePointer )
    DownActive = PRESENT( DownNodePointer) .OR. PRESENT ( BotNodePointer )
    IF(.NOT. (UpActive .OR. DownActive ) ) THEN
      CALL Warn('DetectExtrudedStructure','Either up or down direction should be active')
    END IF

    ! Allocate pointers to top and bottom, and temporary pointers up and down
    !------------------------------------------------------------------------
    n = Mesh % MaxElementNodes
    ALLOCATE( Nodes % x(n), Nodes % y(n),Nodes % z(n) )

    DIM = Mesh % MeshDim
    MaskExists = PRESENT( MaskPerm )
    IF( MaskExists ) THEN
      nsize = MAXVAL( MaskPerm ) 
      WRITE(Message,'(A,I8)') 'Applying mask of size:',nsize
      CALL Info('DetectExtrudedStructure',Message)
    ELSE
      nsize = Mesh % NumberOfNodes
    END IF
    
    IF( UpActive ) THEN
      ALLOCATE(TopPointer(nsize),UpPointer(nsize))
      DO i=1,nsize
        TopPointer(i) = i
        UpPointer(i) = i
      END DO
    END IF
    IF( DownActive ) THEN
      ALLOCATE(BotPointer(nsize),DownPointer(nsize))
      DO i=1,nsize
        BotPointer(i) = i
        DownPointer(i) = i
      END DO
    END IF

    ! Set the dot product tolerance
    !-----------------------------------------------------------------
    IF( PRESENT( Tolerance ) ) THEN
      Eps = Tolerance 
    ELSE
      Eps = ListGetConstReal(CurrentModel % Solver % Values,'Dot Product Tolerance',GotIt)
      IF(.NOT. GotIt) Eps = 0.01_dp
    END IF

    CALL Info('DetectExtrudedStructure','determine up and down pointers')

    ! Determine the up and down pointers using dot product as criterion
    !-----------------------------------------------------------------
    DO elem = 1,Mesh % NumberOfBulkElements      
      Element => Mesh % Elements(elem)
      NodeIndexes => Element % NodeIndexes
      CurrentModel % CurrentElement => Element

      n = Element % TYPE % NumberOfNodes
      Nodes % x(1:n) = Mesh % Nodes % x(NodeIndexes)
      Nodes % y(1:n) = Mesh % Nodes % y(NodeIndexes)
      Nodes % z(1:n) = Mesh % Nodes % z(NodeIndexes)

      IF (.NOT. (Element % PartIndex == Parenv % Mype) ) CYCLE

      IF( MaskExists ) THEN
        IF( ANY(MaskPerm(NodeIndexes) == 0) ) CYCLE
      END IF

      DO i=1,n
        ii = NodeIndexes(i)
        DO j=i+1,n
          jj = NodeIndexes(j)

          ElemVector(1) = Nodes % x(j) - Nodes % x(i)
          ElemVector(2) = Nodes % y(j) - Nodes % y(i)
          ElemVector(3) = Nodes % z(j) - Nodes % z(i)
          Length = SQRT(SUM(ElemVector*ElemVector))
          DotPro = SUM(ElemVector * UnitVector) / Length

          IF(DotPro > 1.0_dp - Eps) THEN 
            IF( UpActive ) UpPointer(ii) = jj
            IF( DownActive ) DownPointer(jj) = ii
          ELSE IF(DotPro < Eps - 1.0_dp) THEN
            IF( DownActive ) DownPointer(ii) = jj
            IF( UpActive ) UpPointer(jj) = ii
          END IF
        END DO
      END DO
    END DO
    
    ! Pointer to top and bottom are found recursively using up and down
    !------------------------------------------------------------------
    CALL Info('DetectExtrudedStructure','determine top and bottom pointers')

    Found = .TRUE.
    Rounds = 0
    DO WHILE(Found) 
      Found = .FALSE.
      DO i=1,nsize
        IF( MaskExists ) THEN
          IF( MaskPerm(i) == 0) CYCLE
        END IF
        IF( UpActive ) THEN
          j = UpPointer(i)
          IF( TopPointer(i) /= TopPointer( j ) ) THEN
            Found = .TRUE.
            TopPointer(i) = TopPointer( j )
          END IF
        END IF
        IF( DownActive ) THEN
          j = DownPointer(i)
          IF( BotPointer(i) /= BotPointer( j ) ) THEN
            Found = .TRUE.
            BotPointer(i) = BotPointer( j )
          END IF
        END IF
      END DO
      IF( Found ) Rounds = Rounds + 1
    END DO

    ! Count the number of nodes, for information only
    !---------------------------------------------------------------
    IF( UpActive ) THEN
      TopNodes = 0
      DO i=1,nsize
        IF(TopPointer(i) == i) THEN
          TopNodes = TopNodes + 1
        END IF
      END DO
    END IF

    IF( DownActive ) THEN
      BotNodes = 0
      DO i=1,nsize
        IF(BotPointer(i) == i) THEN
          BotNodes = BotNodes + 1
        END IF
      END DO
    END IF

    ! Return the requested pointer structures, otherwise deallocate
    !---------------------------------------------------------------
    DEALLOCATE( Nodes % x, Nodes % y,Nodes % z )

    IF( UpActive ) THEN
      IF( PRESENT( TopNodePointer ) ) THEN
        TopNodePointer => TopPointer 
        NULLIFY( TopPointer )
      ELSE
        DEALLOCATE( TopPointer )
      END IF
      IF( PRESENT( UpNodePointer ) ) THEN
        UpNodePointer => UpPointer 
        NULLIFY( UpPointer )
      ELSE
        DEALLOCATE( UpPointer )
      END IF
    END IF
    IF( DownActive ) THEN
      IF( PRESENT( BotNodePointer ) ) THEN
        BotNodePointer => BotPointer 
        NULLIFY( BotPointer ) 
      ELSE
        DEALLOCATE( BotPointer )
      END IF
      IF( PRESENT( DownNodePointer ) ) THEN
        DownNodePointer => DownPointer 
        NULLIFY( DownPointer ) 
      ELSE
        DEALLOCATE( DownPointer )
      END IF
    END IF

    !---------------------------------------------------------------
    at1 = CPUTime()  
    WRITE(Message,* ) 'Top and bottom pointer init time: ',at1-at0
    CALL Info('DetectExtrudedStructure',Message)
    WRITE(Message,* ) 'Top and bottom pointer init rounds: ',Rounds
    CALL Info('DetectExtrudedStructure',Message)
    IF( UpActive ) THEN
      WRITE(Message,* ) 'Number of nodes at the top: ',TopNodes
      CALL Info('DetectExtrudedStructure',Message)
    END IF
    IF( DownActive ) THEN
      WRITE(Message,* ) 'Number of nodes at the bottom: ',BotNodes
      CALL Info('DetectExtrudedStructure',Message)
    END IF

  END SUBROUTINE DetectExtrudedStructure
 !---------------------------------------------------------------




!---------------------------------------------------------------
! This partitions the mesh into a given number of partitions in each 
! direction. It may be used in clustering multigrid or similar. 
! It is not easily applicable to parallel computation as this 
! partitioning should be done outside ElmerSolver in advance.
!---------------------------------------------------------------
  SUBROUTINE ClusterNodesByDirection(Solver,Mesh,Clustering,MaskPerm)
 
    USE GeneralUtils

    TYPE(Solver_t), POINTER :: Solver
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER, OPTIONAL :: MaskPerm(:)
    INTEGER, POINTER :: Clustering(:)
!---------------------------------------------------------------

    LOGICAL :: MaskExists,GotIt,Hit
    REAL(KIND=dp), ALLOCATABLE :: Measure(:)
    INTEGER :: i,j,k,k0,l,ind,n,dim,dir,divs,nsize,elemsinpart,clusters
    INTEGER, POINTER :: Iarray(:),Order(:),NodePart(:),NoPart(:)
    INTEGER :: Divisions(3),minpart,maxpart,clustersize
    REAL(KIND=dp), POINTER :: PArray(:,:), Arrange(:)
    REAL(KIND=dp) :: Normal(3), Tangent1(3), Tangent2(3), Coord(3), Weights(3), &
        avepart,devpart
!---------------------------------------------------------------

    ! CALL Info('ClusterNodesByDirection','')

    MaskExists = PRESENT(MaskPerm)
    IF( MaskExists ) THEN
      nsize = MAXVAL( MaskPerm ) 
    ELSE
      nsize = Mesh % NumberOfNodes
    END IF
    
    dim = Mesh % MeshDim
    Parray => ListGetConstRealArray( Solver % Values,'Clustering Normal Vector',GotIt )
    IF( GotIt ) THEN
      Normal = Parray(1:3,1)
    ELSE
      Normal(1) = 1.0
      Normal(2) = 1.0e-2
      IF( dim == 3) Normal(3) = 1.0e-4
    END IF
    Normal = Normal / SQRT( SUM( Normal ** 2) )

    CALL TangentDirections( Normal,Tangent1,Tangent2 )
    

    IF( .FALSE. ) THEN
      PRINT *,'Normal:',Normal
      PRINT *,'Tangent1:',Tangent1
      PRINT *,'Tangent2:',Tangent2
    END IF


    Iarray => ListGetIntegerArray( Solver % Values,'Clustering Divisions',GotIt )
    IF( GotIt ) THEN
      Divisions = Iarray(1:3)
    ELSE
      clustersize = ListGetInteger( Solver % Values,'MG Cluster Size',GotIt)
      IF( GotIt ) THEN
        IF( dim == 2 ) THEN
          Divisions(1) = ( nsize / clustersize ) ** 0.5
          Divisions(2) = ( nsize / ( clustersize * Divisions(1) ) )
          Divisions(3) = 1
        ELSE
          Divisions(1:2) = ( nsize / clustersize ) ** (1.0_dp / 3 )
          Divisions(3) = ( nsize / ( clustersize * Divisions(1) * Divisions(2) ) )
        END IF
      ELSE
        CALL Fatal('ClusterNodesByDirection','Clustering Divisions not given!')
      END IF
    END IF

    Clusters = Divisions(1) * Divisions(2) * Divisions(3)

    IF( .FALSE. ) THEN
      PRINT *,'clusters:',clusters
      PRINT *,'nsize:',nsize
    END IF

    ALLOCATE(Order(nsize),Arrange(nsize),NodePart(nsize),NoPart(Clusters))
    

    ! These are needed as an initial value for the loop over dimension
    elemsinpart = nsize
    nodepart = 1
    

    ! Go through each direction and cumulatively add to the clusters
    !-----------------------------------------------------------

    DO dir = 1,dim      
      divs = Divisions(dir)
      IF( divs <= 1 ) CYCLE
      
      ! Use the three principal directions as the weight
      !-------------------------------------------------
      IF( dir == 1 ) THEN
        Weights = Normal
      ELSE IF( dir == 2 ) THEN
        Weights = Tangent1
      ELSE 
        Weights = Tangent2
      END IF

      ! Initialize ordering for the current direction
      !----------------------------------------------
      DO i=1,nsize
        Order(i) = i
      END DO
      

      ! Now compute the weights for each node
      !----------------------------------------
      DO i=1,Mesh % NumberOfNodes
        j = i
        IF( MaskExists ) j = MaskPerm(j)
        IF( j == 0 ) CYCLE
        
        Coord(1) = Mesh % Nodes % x(i)
        Coord(2) = Mesh % Nodes % y(i)
        Coord(3) = Mesh % Nodes % z(i)

        Arrange(j) = SUM( Weights * Coord )
      END DO

      ! Order the nodes for given direction
      !----------------------------------------------
      CALL SortR(nsize,Order,Arrange)

      ! For each direction the number of elements in cluster becomes smaller
      elemsinpart = elemsinpart / divs

      ! initialize the counter partition
      nopart = 0


      ! Go through each node and locate it to a cluster taking into consideration
      ! the previous clustering (for 1st direction all one)
      !------------------------------------------------------------------------
      j = 1
      DO i = 1,nsize
        ind = Order(i)
        
        ! the initial partition offset depends on previous partitioning
        k0 = (nodepart(ind)-1) * divs

        ! Find the correct new partitioning, this loop is just long enough
        DO l=1,divs
          Hit = .FALSE.
          
          ! test for increase of local partition
          IF( j < divs ) THEN
            IF( nopart(k0+j) >= elemsinpart ) THEN
              j = j + 1
              Hit = .TRUE.
            END IF
          END IF
          
          ! test for decrease of local partition
          IF( j > 1 )  THEN            
            IF( nopart(k0+j-1) < elemsinpart ) THEN
              j = j - 1
              Hit = .TRUE.
            END IF
          END IF
          
          ! If either increase or decrease is needed, this must be ok 
          IF(.NOT. Hit) EXIT
        END DO
          
        k = k0 + j
        nopart(k) = nopart(k) + 1
        nodepart(ind) = k
      END DO

    END DO


    minpart = HUGE(minpart)
    maxpart = 0
    avepart = 1.0_dp * nsize / clusters
    devpart = 0.0_dp
    DO i=1,clusters
      minpart = MIN( minpart, nopart(i))
      maxpart = MAX( maxpart, nopart(i))
      devpart = devpart + ABS ( nopart(i) - avepart )
    END DO
    devpart = devpart / clusters

    WRITE(Message,'(A,T25,I10)') 'Min nodes in cluster:',minpart
    CALL Info('ClusterNodesByDirection',Message)
    WRITE(Message,'(A,T25,I10)') 'Max nodes in cluster:',maxpart
    CALL Info('ClusterNodesByDirection',Message)
    WRITE(Message,'(A,T28,F10.2)') 'Average nodes in cluster:',avepart
    CALL Info('ClusterNodesByDirection',Message)
    WRITE(Message,'(A,T28,F10.2)') 'Deviation of nodes:',devpart
    CALL Info('ClusterNodesByDirection',Message)
    

    IF( ASSOCIATED(Clustering)) THEN
      Clustering = Nodepart 
      DEALLOCATE(Nodepart)
    ELSE
      Clustering => Nodepart
      NULLIFY( Nodepart ) 
    END IF
    
    DEALLOCATE(Order,Arrange,NoPart)


  END SUBROUTINE ClusterNodesByDirection



!------------------------------------------------------------------------------
  FUNCTION CreateLineMesh( Params ) RESULT( Mesh )
!------------------------------------------------------------------------------
!   Create a 1D mesh, may be used in 1D outlet conditions
!------------------------------------------------------------------------------
    TYPE(ValueList_t), POINTER :: Params 
    TYPE(Mesh_t), POINTER :: Mesh
!------------------------------------------------------------------------------
    REAL(KIND=dp), POINTER :: x(:),y(:),z(:)
    INTEGER :: i, j, k, n, NoNodes, NoElements, ActiveDirection, Order
    LOGICAL :: Found
    TYPE(Element_t), POINTER :: Element
    TYPE(ElementType_t),POINTER :: elmt
    REAL(KIND=dp) :: MeshVector(3), Length, Coord(3)

!------------------------------------------------------------------------------
    IF ( .NOT. ASSOCIATED( Params ) ) RETURN
    Mesh => AllocateMesh()

    CALL Info('CreateLineMesh','Starting')


!   Read in the parameters defining a uniform 1D mesh
!--------------------------------------------------------------    
    Order = ListGetInteger( Params,'1D Element Order',Found,minv=1,maxv=2)
    NoElements = ListGetInteger( Params,'1D Number Of Elements',minv=1)
    Length = ListGetConstReal( Params,'1D Mesh Length')    
    ActiveDirection = ListGetInteger( Params,'1D Active Direction',minv=-3,maxv=3)

    
!   Compute the resulting mesh parameters
!--------------------------------------------------------------
    NoNodes = NoElements + 1 + NoElements * (Order - 1)    
    MeshVector = 0.0_dp
    MeshVector( ABS( ActiveDirection ) ) = 1.0_dp
    IF( ActiveDirection < 0 ) MeshVector = -MeshVector
    MeshVector = MeshVector * Length

!   Define nodal coordinates
!   -------------------------------
    CALL AllocateVector( Mesh % Nodes % x, NoNodes )
    CALL AllocateVector( Mesh % Nodes % y, NoNodes )
    CALL AllocateVector( Mesh % Nodes % z, NoNodes )

    x => Mesh % Nodes % x
    y => Mesh % Nodes % y
    z => Mesh % Nodes % z
   
    DO i=1, NoNodes
      Coord = MeshVector * (i-1) / (NoNodes-1)

      x(i) = Coord(1)
      y(i) = Coord(2)
      z(i) = Coord(3)
    END DO
    
    CALL Info('CreateLineMesh','Nodes created')

!   Define elements
!   -------------------------------
    CALL AllocateVector( Mesh % Elements, NoElements )

    IF( Order == 1 ) THEN
      Elmt => GetElementType( 202 )
    ELSE
      Elmt => GetElementType( 203 )
    END IF

    DO i=1,NoElements
      Element => Mesh % Elements(i)      
      Element % TYPE => Elmt
      Element % EdgeIndexes => NULL()
      Element % FaceIndexes => NULL()     
      Element % ElementIndex = i
      IF( Order == 1 ) THEN
        CALL AllocateVector( Element % NodeIndexes, 2 )
        Element % Ndofs = 2
        Element % NodeIndexes(1) = i
        Element % NodeIndexes(2) = i + 1
      ELSE IF( Order == 2 ) THEN
        CALL AllocateVector( Element % NodeIndexes, 3 )
        Element % Ndofs = 3
        Element % NodeIndexes(1) = 2*i-1
        Element % NodeIndexes(2) = 2*i+1
        Element % NodeIndexes(3) = 2*i
      END IF
    END DO

    CALL Info('CreateLineMesh','Elements created')

!   Update new mesh node count:
!   ---------------------------

    Mesh % NumberOfNodes = NoNodes
    Mesh % Nodes % NumberOfNodes = NoNodes
    Mesh % NumberOfBulkElements = NoElements
    Mesh % MaxElementNodes = 1 + Order
    Mesh % MaxElementDOFs = 1 + Order


    PRINT *,'NoNodes:',NoNodes
    PRINT *,'NoElements:',NoElements
 
    CALL Info('CreateLineMesh','All done')

  END FUNCTION CreateLineMesh


!------------------------------------------------------------------------------
END MODULE MeshUtils
!------------------------------------------------------------------------------
