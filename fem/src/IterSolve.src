!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Module containing a iterative solver for linear systems.
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 08 Jun 1997
! *
! ****************************************************************************/

#include "huti_fdefs.h"

!------------------------------------------------------------------------------
MODULE IterSolve

   USE Lists
   USE CRSMatrix
   USE BandMatrix
   USE IterativeMethods

   IMPLICIT NONE

   !/*
   ! * Iterative method selection
   ! */
   INTEGER, PARAMETER, PRIVATE :: ITER_BiCGStab     =           320
   INTEGER, PARAMETER, PRIVATE :: ITER_TFQMR        =           330
   INTEGER, PARAMETER, PRIVATE :: ITER_CG           =           340
   INTEGER, PARAMETER, PRIVATE :: ITER_CGS          =           350
   INTEGER, PARAMETER, PRIVATE :: ITER_GMRES        =           360
   INTEGER, PARAMETER, PRIVATE :: ITER_BiCGStab2    =           370
   INTEGER, PARAMETER, PRIVATE :: ITER_SGS          =           380
   INTEGER, PARAMETER, PRIVATE :: ITER_JACOBI       =           390
   INTEGER, PARAMETER, PRIVATE :: ITER_BICGSTABL    =           400

   !/*
   ! * Preconditioning type code
   ! */
   INTEGER, PARAMETER, PRIVATE :: PRECOND_NONE      =           500
   INTEGER, PARAMETER, PRIVATE :: PRECOND_DIAGONAL  =           510
   INTEGER, PARAMETER, PRIVATE :: PRECOND_ILUn      =           520
   INTEGER, PARAMETER, PRIVATE :: PRECOND_ILUT      =           530
   INTEGER, PARAMETER, PRIVATE :: PRECOND_MG        =           540
   INTEGER, PARAMETER, PRIVATE :: PRECOND_BILUn     =           550
   INTEGER, PARAMETER, PRIVATE :: PRECOND_Vanka     =           560

   LOGICAL :: FirstCall = .TRUE.

CONTAINS


!------------------------------------------------------------------------------
! We DON'T use the backward error estimate e = ||Ax-b||/(||A|| ||x|| + ||b||)
! as stopping criteriation.
!------------------------------------------------------------------------------
  FUNCTION STOPC( x,b,r,ipar,dpar ) RESULT(err)
!------------------------------------------------------------------------------

     INTEGER :: ipar(*),n
     DOUBLE PRECISION :: x(*),b(*),r(*),dpar(*),err,res(HUTI_NDIM)

     n = HUTI_NDIM

     CALL CRS_MatrixVectorMultiply( GlobalMatrix,x,res )
     res = res - b(1:n)

     err = SQRT(SUM( res(1:n)**2) ) /  &
        ( SQRT(SUM(GlobalMatrix % Values**2)) * SQRT(SUM(x(1:n)**2)) + SQRT(SUM(b(1:n)**2)) )

  END FUNCTION STOPC
!------------------------------------------------------------------------------


#ifndef HUTI_MAXTOLERANCE
#define HUTI_MAXTOLERANCE dpar(2)
#endif
#ifndef HUTI_SGSPARAM
#define HUTI_SGSPARAM dpar(3)
#endif
#ifndef HUTI_BICGSTABL_L
#define HUTI_BICGSTABL_L ipar(16)
#endif
#ifndef HUTI_DIVERGENCE
#define HUTI_DIVERGENCE 3
#endif


!------------------------------------------------------------------------------
  SUBROUTINE pcond_dummy(u,v,ipar )
!------------------------------------------------------------------------------
    INTEGER :: ipar(*)
    REAL(KIND=dp) :: u(HUTI_NDIM), v(HUTI_NDIM)
!------------------------------------------------------------------------------
    u=v 
!------------------------------------------------------------------------------
  END SUBROUTINE pcond_dummy
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE IterSolver( A,x,b,SolverParam,DotF,NormF,MatvecF )
!------------------------------------------------------------------------------

    USE SParIterGlobals
    IMPLICIT NONE

!------------------------------------------------------------------------------
    TYPE(Solver_t) :: SolverParam
    REAL(KIND=dp), DIMENSION(:) :: x,b
    TYPE(Matrix_t), POINTER :: A, Adiag
    INTEGER(KIND=AddrInt), OPTIONAL :: DotF, NormF, MatVecF
!------------------------------------------------------------------------------

    REAL(KIND=dp) :: dpar(50),stopfun
!   external stopfun
    REAL(KIND=dp), ALLOCATABLE :: work(:,:)
    INTEGER :: k,N,ipar(50),wsize,istat,IterType,PCondType,ILUn,Blocks

    REAL(KIND=dp) :: ILUT_TOL
    LOGICAL :: Condition,GotIt,AbortNotConverged, Refactorize

    CHARACTER(LEN=MAX_NAME_LEN) :: str

    EXTERNAL MultigridPrec

    INTEGER  :: HUTI_D_BICGSTAB, HUTI_D_BICGSTAB_2, HUTI_D_TFQMR, &
                HUTI_D_CG, HUTI_D_CGS, HUTI_D_GMRES
    EXTERNAL :: HUTI_D_BICGSTAB, HUTI_D_BICGSTAB_2, HUTI_D_TFQMR, &
                HUTI_D_CG, HUTI_D_CGS, HUTI_D_GMRES

    INTEGER  :: HUTI_Z_BICGSTAB, HUTI_Z_BICGSTAB_2, HUTI_Z_TFQMR, &
                HUTI_Z_CG, HUTI_Z_CGS, HUTI_Z_GMRES
    EXTERNAL :: HUTI_Z_BICGSTAB, HUTI_Z_BICGSTAB_2, HUTI_Z_TFQMR, &
                HUTI_Z_CG, HUTI_Z_CGS, HUTI_Z_GMRES

    REAL(KIND=dp) :: ddot, dnrm2
    EXTERNAL :: ddot, dnrm2

    INTEGER(KIND=Addrint) :: dotProc, normProc, pcondProc, &
            pcondrProc=0, mvProc, AddrFunc, iterProc

    INTERFACE
       SUBROUTINE VankaCreate(A,Solver)
          USE Types
          TYPE(Matrix_t) :: A
          TYPE(Solver_t) :: Solver
       END SUBROUTINE VankaCreate

       SUBROUTINE VankaPrec(u,v,ipar)
          USE Types
          INTEGER :: ipar(*)
          REAL(KIND=dp) :: u(*),v(*)
       END SUBROUTINE VankaPrec
    END INTERFACE
!------------------------------------------------------------------------------
    N = A % NumberOfRows

    ipar = 0
    dpar = 0.0D0

!------------------------------------------------------------------------------
    str = ListGetString( SolverParam % Values,'Linear System Iterative Method' )

    IF ( str(1:9) == 'bicgstab2' ) THEN
      IterType = ITER_BiCGStab2
    ELSE IF ( str(1:9) == 'bicgstabl' ) THEN
      IterType = ITER_BICGstabl
    ELSE IF ( str(1:8) == 'bicgstab' ) THEN
      IterType = ITER_BiCGStab
    ELSE IF ( str(1:5) == 'tfqmr' )THEN
      IterType = ITER_TFQMR
    ELSE IF ( str(1:3) == 'cgs' ) THEN
      IterType = ITER_CGS
    ELSE IF ( str(1:2) == 'cg' ) THEN
      IterType = ITER_CG
    ELSE IF ( str(1:5) == 'gmres' ) THEN
      IterType = ITER_GMRES
    ELSE IF ( str(1:3) == 'sgs' ) THEN
      IterType = ITER_SGS
    ELSE IF ( str(1:6) == 'jacobi' ) THEN
      IterType = ITER_jacobi
    ELSE
      IterType = ITER_BiCGStab
    END IF
!------------------------------------------------------------------------------

    HUTI_WRKDIM = 0
    wsize = HUTI_WRKDIM

    SELECT CASE ( IterType )
      CASE (ITER_BiCGStab)
        HUTI_WRKDIM = HUTI_BICGSTAB_WORKSIZE
        wsize = HUTI_WRKDIM

      CASE (ITER_BiCGStab2)
        HUTI_WRKDIM = HUTI_BICGSTAB_2_WORKSIZE
        wsize = HUTI_WRKDIM

      CASE (ITER_TFQMR)
        HUTI_WRKDIM = HUTI_TFQMR_WORKSIZE
        wsize = HUTI_WRKDIM

      CASE (ITER_CG)
        HUTI_WRKDIM = HUTI_CG_WORKSIZE
        wsize = HUTI_WRKDIM

      CASE (ITER_CGS)
        HUTI_WRKDIM = HUTI_CGS_WORKSIZE
        wsize = HUTI_WRKDIM
          
      CASE (ITER_GMRES)

        HUTI_GMRES_RESTART = ListGetInteger( SolverParam % Values, &
             'Linear System GMRES Restart',  GotIt ) 
        IF ( .NOT. GotIT ) HUTI_GMRES_RESTART = 10
        HUTI_WRKDIM = HUTI_GMRES_WORKSIZE + HUTI_GMRES_RESTART
        wsize = HUTI_WRKDIM

      /*******  Solvers from IterativeMethods.src ******/
      CASE (ITER_SGS)
        HUTI_WRKDIM = 1
        wsize = HUTI_WRKDIM
        HUTI_SGSPARAM = ListGetConstReal( SolverParam % Values,'SGS Overrelaxation Factor',&
            GotIt,minv=0.0_dp,maxv=2.0_dp)
        IF(.NOT. GotIt) HUTI_SGSPARAM = 1.8

      CASE (ITER_Jacobi)
        HUTI_WRKDIM = 1
        wsize = HUTI_WRKDIM

      CASE (ITER_BICGSTABL)
        HUTI_WRKDIM = 1
        wsize = HUTI_WRKDIM
        HUTI_BICGSTABL_L = ListGetInteger( SolverParam % Values,'BiCGstabl polynomial degree',&
            GotIt,minv=2)
        IF(.NOT. GotIt) HUTI_BICGSTABL_L = 2

     END SELECT
!------------------------------------------------------------------------------
          
     HUTI_STOPC = HUTI_TRESID_SCALED_BYB
     HUTI_NDIM  = N

     HUTI_DBUGLVL  = ListGetInteger( SolverParam % Values, &
           'Linear System Residual Output', GotIt )
     IF ( .NOT.Gotit ) HUTI_DBUGLVL = 1

     IF ( Parenv % myPE /= 0 ) HUTI_DBUGLVL=0
     IF ( .NOT. OutputLevelMask(6) )  HUTI_DBUGLVL = 0


     HUTI_MAXIT = ListGetInteger( SolverParam % Values, &
         'Linear System Max Iterations', minv=1 )
 
     ALLOCATE( work(N,wsize),stat=istat )
     IF ( istat /= 0 ) THEN
       CALL Fatal( 'IterSolve', 'Memory allocation failure.' )
     END IF

     IF ( ALL(x == 0.0) ) x = 1.0d-8
     HUTI_INITIALX = HUTI_USERSUPPLIEDX

     HUTI_TOLERANCE = ListGetCReal( SolverParam % Values, &
          'Linear System Convergence Tolerance' )

     HUTI_MAXTOLERANCE = ListGetCReal( SolverParam % Values, &
             'Linear System Divergence Tolerance', GotIt)
     IF(.NOT. GotIt) HUTI_MAXTOLERANCE = HUGE(HUTI_MAXTOLERANCE) 


!------------------------------------------------------------------------------

     str = ListGetString( SolverParam % Values, &
      'Linear System Preconditioning',gotit )

     IF ( .NOT.gotit ) str = 'none'

     IF ( str(1:4) == 'none' ) THEN
       PCondType = PRECOND_NONE
     ELSE IF ( str(1:8) == 'diagonal' ) THEN
       PCondType = PRECOND_DIAGONAL
     ELSE IF ( str(1:4) == 'ilut' ) THEN
       ILUT_TOL = ListGetCReal( SolverParam % Values, &
           'Linear System ILUT Tolerance',GotIt )
       PCondType = PRECOND_ILUT
     ELSE IF ( str(1:3) == 'ilu' ) THEN
       ILUn = NINT(ListGetCReal( SolverParam % Values, &
          'Linear System ILU Order', gotit ))
       IF ( .NOT.gotit ) &
         ILUn = ICHAR(str(4:4)) - ICHAR('0')
       IF ( ILUn  < 0 .OR. ILUn > 9 ) ILUn = 0
       PCondType = PRECOND_ILUn
     ELSE IF ( str(1:4) == 'bilu' ) THEN
       ILUn = ICHAR(str(5:5)) - ICHAR('0')
       IF ( ILUn  < 0 .OR. ILUn > 9 ) ILUn = 0
       IF( SolverParam % Variable % Dofs == 1) THEN
         CALL Warn('IterSolver','BILU for one dofs is equal to ILU!')
         PCondType = PRECOND_ILUn
       ELSE
         PCondType = PRECOND_BILUn
       END IF
     ELSE IF ( str(1:9) == 'multigrid' ) THEN
       PCondType = PRECOND_MG
     ELSE IF ( str(1:5) == 'vanka' ) THEN
       PCondType = PRECOND_VANKA
     ELSE
       PCondType = PRECOND_NONE
       CALL Warn( 'IterSolve', 'Unknown preconditioner type, feature disabled.' )
     END IF

     IF ( .NOT. ListGetLogical( SolverParam % Values, 'No Precondition Recompute',GotIt ) ) THEN
        n = ListGetInteger( SolverParam % Values, 'Linear System Precondition Recompute', GotIt )
        IF ( n <= 0 ) n = 1

        Refactorize = ListGetLogical( SolverParam % Values, 'Linear System Refactorize', Gotit )
        IF ( .NOT. Gotit ) Refactorize = .TRUE.

        IF (.NOT. ASSOCIATED(A % ILUValues).OR.(Refactorize.AND.MOD(A % SolveCount, n)==0) ) THEN
           IF ( A % FORMAT == MATRIX_CRS ) THEN
             IF ( A % COMPLEX ) THEN
                IF ( PCondType == PRECOND_ILUn ) THEN
                   Condition = CRS_ComplexIncompleteLU(A,ILUn)
                ELSE IF ( PCondType == PRECOND_ILUT ) THEN
                   Condition = CRS_ComplexILUT( A,ILUT_TOL )
                END IF
             ELSE
               SELECT CASE(PCondType)
               CASE(PRECOND_ILUn)
                 Condition = CRS_IncompleteLU(A,ILUn)
               CASE(PRECOND_ILUT)
                 Condition = CRS_ILUT( A,ILUT_TOL )
               CASE(PRECOND_BILUn)
                 Blocks = SolverParam % Variable % Dofs
                 IF ( Blocks <= 1 ) THEN
                   Condition = CRS_IncompleteLU(A,ILUn)
                 ELSE
                   Adiag => AllocateMatrix()
                   CALL CRS_BlockDiagonal(A,Adiag,Blocks)
                   Condition = CRS_IncompleteLU(Adiag,ILUn)
                   A % ILURows   => Adiag % ILURows
                   A % ILUCols   => Adiag % ILUCols
                   A % ILUValues => Adiag % ILUValues
                   A % ILUDiag   => Adiag % ILUDiag                 
                   IF (ILUn > 0) THEN
                     DEALLOCATE(Adiag % Rows,Adiag % Cols, Adiag % Diag, Adiag % Values)
                   END IF
                   DEALLOCATE( Adiag )
                 END IF
               CASE(PRECOND_VANKA)
!                CALL VankaCreate( A, SolverParam )
               END SELECT
             END IF
           ELSE
             IF ( PCondType == PRECOND_ILUn ) THEN
               CALL Warn( 'IterSolve', 'No ILU Preconditioner for Band Matrix format,' )
               CALL Warn( 'IterSolve', 'using Diagonal preconditioner instead...' )
               PCondType = PRECOND_DIAGONAL
             END IF
           END IF
        END IF
     END IF

     A % SolveCount = A % SolveCount + 1
!------------------------------------------------------------------------------

     AbortNotConverged = ListGetLogical( SolverParam % Values, &
          'Linear System Abort Not Converged', GotIt )
     IF ( .NOT. GotIt ) AbortNotConverged = .TRUE.

!------------------------------------------------------------------------------
     FirstCall = .TRUE.

     IF ( PRESENT(MatvecF) ) THEN
       mvProc = MatvecF
     ELSE
       IF ( .NOT. A % COMPLEX ) THEN
         mvProc = AddrFunc( CRS_MatrixVectorProd )
       ELSE
         mvProc = AddrFunc( CRS_ComplexMatrixVectorProd )
       END IF
     END IF

     IF ( PRESENT(dotF) ) THEN
       dotProc = dotF
     ELSE
       dotProc =0
     END IF

     IF ( PRESENT(normF) ) THEN
       normProc = normF
     ELSE
       normProc = 0
     END IF


     SELECT CASE( PCondType )
       CASE (PRECOND_NONE)
         pcondProc = AddrFunc( pcond_dummy )

       CASE (PRECOND_DIAGONAL)
         IF ( .NOT. A % COMPLEX ) THEN
           pcondProc = AddrFunc( CRS_DiagPrecondition )
         ELSE
           pcondProc = AddrFunc( CRS_ComplexDiagPrecondition )
         END IF

       CASE (PRECOND_ILUn, PRECOND_ILUT, PRECOND_BILUn )
         IF ( .NOT. A % COMPLEX ) THEN
           pcondProc = AddrFunc( CRS_LUPrecondition )
         ELSE
           pcondProc = AddrFunc( CRS_ComplexLUPrecondition )
         END IF

       CASE (PRECOND_MG)
         pcondProc = AddrFunc( MultiGridPrec )

       CASE (PRECOND_VANKA)
         pcondProc = AddrFunc( VankaPrec )

       CASE DEFAULT
         pcondProc = 0
     END SELECT

     IF ( .NOT. A % COMPLEX ) THEN
       SELECT CASE ( IterType )
       CASE (ITER_BiCGStab)
          iterProc = AddrFunc( HUTI_D_BICGSTAB )
       CASE (ITER_BiCGStab2)
          iterProc = AddrFunc( HUTI_D_BICGSTAB_2 )
       CASE (ITER_TFQMR)
          iterProc = AddrFunc( HUTI_D_TFQMR )
       CASE (ITER_CG)
          iterProc = AddrFunc( HUTI_D_CG )
       CASE (ITER_CGS)
          iterProc = AddrFunc( HUTI_D_CGS )
       CASE (ITER_GMRES)
          iterProc = AddrFunc( HUTI_D_GMRES )

     /*******  Solvers from IterativeMethods.src ******/

       CASE (ITER_SGS)
         iterProc = AddrFunc( itermethod_sgs )
         IF ( dotProc  == 0 ) dotProc = AddrFunc(ddot)
         IF ( normProc == 0 ) normproc = AddrFunc(dnrm2)
         ! Eliminate the MOD(i,0) problem in later testing
         IF( HUTI_DBUGLVL == 0) HUTI_DBUGLVL = HUGE( HUTI_DBUGLVL )

       CASE (ITER_JACOBI)
         iterProc = AddrFunc( itermethod_jacobi )
         IF ( dotProc  == 0 ) dotProc = AddrFunc(ddot)
         IF ( normProc == 0 ) normproc = AddrFunc(dnrm2)
         IF( HUTI_DBUGLVL == 0) HUTI_DBUGLVL = HUGE( HUTI_DBUGLVL )

       CASE (ITER_BICGSTABL)
         iterProc = AddrFunc( itermethod_bicgstabl )
         IF ( dotProc  == 0 ) dotProc = AddrFunc(ddot)
         IF ( normProc == 0 ) normproc = AddrFunc(dnrm2)
         IF( HUTI_DBUGLVL == 0) HUTI_DBUGLVL = HUGE( HUTI_DBUGLVL )

       END SELECT

     ELSE
       HUTI_NDIM = HUTI_NDIM / 2
       SELECT CASE ( IterType )
       CASE (ITER_BiCGStab)
          iterProc = AddrFunc( HUTI_Z_BICGSTAB )
       CASE (ITER_BiCGStab2)
          iterProc = AddrFunc( HUTI_Z_BICGSTAB_2 )
       CASE (ITER_TFQMR)
          iterProc = AddrFunc( HUTI_Z_TFQMR )
       CASE (ITER_CG)
          iterProc = AddrFunc( HUTI_Z_CG )
       CASE (ITER_CGS)
          iterProc = AddrFunc( HUTI_Z_CGS )
       CASE (ITER_GMRES)
          iterProc = AddrFunc( HUTI_Z_GMRES )
       END SELECT
     END IF

!------------------------------------------------------------------------------

     GlobalMatrix => A
     CALL IterCall( iterProc, x, b, ipar, dpar, work, &
       mvProc, pcondProc, pcondrProc, dotProc, normProc, STOPC )

     IF ( A % COMPLEX ) HUTI_NDIM = HUTI_NDIM * 2
!------------------------------------------------------------------------------
     IF ( HUTI_INFO /= HUTI_CONVERGENCE .AND. ParEnv % myPE==0 ) THEN
       IF( HUTI_INFO == HUTI_DIVERGENCE ) THEN
         CALL Fatal( 'IterSolve', 'System diverged over tolerance.' )
       ELSE IF ( AbortNotConverged ) THEN
         CALL Fatal( 'IterSolve', 'Failed convergence tolerances.' )
       ELSE
         CALL Error( 'IterSolve', 'Failed convergence tolerances.' )
       END IF
     END IF
!------------------------------------------------------------------------------
     DEALLOCATE( work )


!------------------------------------------------------------------------------
   END SUBROUTINE IterSolver
!------------------------------------------------------------------------------

END MODULE IterSolve
