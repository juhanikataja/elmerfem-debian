!/******************************************************************************
! *
! *  Authors: Peter Råback & Juha Ruokolainen
! *  Email:   Peter.Raback@csc.fi & Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 16.6.2011
! *
! *****************************************************************************/

!-------------------------------------------------------------------------------
!> Subroutine for advecting fields in time using particles to follow them  
!> backwards in time, and taking the field value from the given point. This should overcome
!> all problems with diffusion. 
!> This is a dynamically loaded solver with a standard interface. 
!> \ingroup Solvers
!-------------------------------------------------------------------------------
SUBROUTINE ParticleAdvector( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
  USE DefUtils
  USE Interpolation
  USE MeshUtils
  USE ElementUtils
  USE ParticleUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t), TARGET :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------

  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(ValueList_t), POINTER :: Params
  TYPE(Solver_t), POINTER :: PSolver
  TYPE(Variable_t), POINTER :: Var
  TYPE(Variable_t), POINTER :: AgeVar
  LOGICAL :: GotIt, Debug, Hit, InitLocation, InitTimestep, Found, ParticleInfo
  INTEGER :: i,j,k,n,dim,No,nodims,&
      ElementIndex, VisitedTimes = 0, nstep, &
      Status,TimeOrder, PartitionChanges, TimeStepsTaken=0,&
      ParticleStepsTaken=0, TotParticleStepsTaken, TotNoParticles, &
      istep,iorder
  REAL(KIND=dp) :: maxdt, dertime, tottime = 0.0
  CHARACTER(LEN=MAX_NAME_LEN) :: VariableName, IntegMethod
  TYPE(Particle_t), POINTER  :: Particles
  
  SAVE Nstep, VisitedTimes, TimeOrder, &
      tottime, TimeStepsTaken, ParticleStepsTaken, ParticleInfo

!------------------------------------------------------------------------------

  CALL Info('ParticleAdvector','-----------------------------------------', Level=4 )
  CALL Info('ParticleAdvector','Advecting fields using particle tracking',Level=4) 
  
  Particles => GlobalParticles
  VisitedTimes = VisitedTimes + 1

  Params => Solver % Values
  Mesh => Solver % Mesh
  PSolver => Solver
  DIM = CoordinateSystemDimension()

  maxdt = 0.0_dp  
  istep = 1
  iorder = 1

  ! Do some initalialization: allocate space, check fields  
  !------------------------------------------------------------------------
  IF( VisitedTimes == 1 ) THEN
    TimeOrder = GetInteger( Params,'Time Order',GotIt)
    CALL SetParticlePreliminaries( Particles, dim, TimeOrder )
    Nstep = GetInteger( Params,'Max Timestep Intervals',Found)
    IF(.NOT. Found) Nstep = 1
    ParticleInfo = GetLogical( Params,'Particle Info',Found)
  END IF

  ! Initialize particles always since we just advance -dt each time
  !-------------------------------------------------------------------------
  CALL InitializeParticles( Particles ) 
  CALL ReleaseWaitingParticles(Particles) 
  Particles % Status = PARTICLE_LOCATED

  IF( GetLogical( Params,'Particle Time',Found) ) THEN
    CALL ParticleVariableCreate( Particles,'particle time')
  END IF
  CALL ParticleVariableCreate( Particles,'particle distance')

  ! We are advecting backwards in time!
  !----------------------------------------------------
  InitTimestep = .TRUE.
  IF( Particles % RK2 ) THEN
    iorder = 2
  ELSE
    iorder = 1
  END IF


  DO i=1,nstep

    ! Get the timestep size, initialize at 1st round
    !--------------------------------------------------------------
    maxdt = GetParticleTimeStep( Particles, InitTimestep )

 
! CALL ParticleStatusCount(Particles)

    ! If size of timestep goes to zero then no more steps are needed
    !---------------------------------------------------------------
    IF( ABS( maxdt )  < TINY( maxdt ) ) EXIT	

    dertime = dertime + maxdt
    tottime = tottime + maxdt

    TimeStepsTaken = TimeStepsTaken + 1
    ParticleStepsTaken = ParticleStepsTaken + Particles % NumberOfParticles

    ! If there are periodic BCs apply them just before locating the particles
    !------------------------------------------------------------------------
    ! CALL ParticleBoxPeriodic( Particles )


    ! Loop over possible runge-kutta steps
    !------------------------------------------------------------------------

    DO istep = 1, iorder

      ! Set velocity field at points.
      ! This is not done the first time. 
      !------------------------------------------------------------------
      IF( .NOT. InitTimestep ) CALL SetParticleVelocities()

      ! Advance the coordinate, r = r0 + v * dt
      ! either with 2nd order Runge-Kutta, or with 1st order explicit scheme.
      !------------------------------------------------------------------
      CALL ParticleAdvanceTimestep( Particles, istep )

      ! Find the elements (and only the elements) in which the particles are in. 
      !------------------------------------------------------------------------    
      CALL LocateParticles( Particles ) 
      InitTimestep = .FALSE.
    END DO 

    WRITE (Message,'(A,I0,A,I0,A)') 'Timestep ',i,' with ',&
	Particles % NumberOfMovingParticles,' moving particles'
    CALL Info('ParticleAdvector',Message,Level=6)


  END DO

  ! Set the advected field giving the final locations of the particles backward in time
  !------------------------------------------------------------------------------------
  CALL SetAdvectedField()
  
  ! In the end show some statistical info
  !---------------------------------------------------------------   
  IF( ParticleInfo ) THEN
    CALL ParticleInformation(Particles, ParticleStepsTaken, &
	TimeStepsTaken, tottime )
  END IF
    
  CALL Info('ParticleAdvector','All done',Level=4)
  CALL Info('ParticleAdvector', '-----------------------------------------', Level=4 )
  

CONTAINS

   
  
  !------------------------------------------------------------------------
  !> Compute field values at the given points in the FE mesh. 
  !-------------------------------------------------------------------------
  SUBROUTINE SetParticleVelocities()

    TYPE(Element_t), POINTER :: BulkElement
    INTEGER :: No, Status
    REAL(KIND=dp) :: Coord(3),Velo(3),GradVelo(3,3)    
    TYPE(Element_t), POINTER :: BulkElement2
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Valuelist_t), POINTER :: Params
    REAL(KIND=dp) :: VeloAtPoint(3), GradVeloAtPoint(3,3),dtime
    LOGICAL :: Stat, UseGradVelo, Visited = .FALSE.
    INTEGER :: i,j,k,l,n,dim,TimeOrder
    INTEGER, POINTER :: NodeIndexes(:), FieldPerm(:),FieldIndexes(:)
    REAL(KIND=dp) :: SqrtElementMetric, Weight
    REAL(KIND=dp), POINTER :: Basis(:), dBasisdx(:,:), Coordinate(:,:), Velocity(:,:)
    LOGICAL :: GotIt
    CHARACTER(LEN=MAX_NAME_LEN) :: VariableName
    TYPE(Variable_t), POINTER :: VeloVar
    TYPE(Variable_t), POINTER :: DtVar	
    
    
    SAVE :: Visited, Mesh, dim, Basis, dBasisdx, Params, VeloVar, UseGradvelo, DtVar

    IF( .NOT. Visited ) THEN
      Mesh => GetMesh()
      dim = Mesh % MeshDim
      n = Mesh % MaxElementNodes
      ALLOCATE( Basis(n), dBasisdx(n, 3) )
      
      Params => GetSolverParams()
      
      VariableName = ListGetString(Params,'Velocity Variable Name',Found)
      IF(.NOT. Found) VariableName = 'flow solution'
      VeloVar => VariableGet( Mesh % Variables, TRIM(VariableName) )
      IF(.NOT. ASSOCIATED( VeloVar ) ) THEN
        CALL Fatal('ParticleFieldInteraction','Velocity field variable does not exist: '//TRIM(VariableName))           
      END IF
      UseGradVelo = GetLogical( Params,'Velocity Gradient Correction',Found)

      IF( .NOT. Particles % DtConstant ) THEN
        DtVar => ParticleVariableGet( Particles,'particle dt')
        IF( .NOT. ASSOCIATED( DtVar ) ) THEN
          CALL Fatal('SetParticleVelocities','Required field > particle dt < not present!')
        END IF
      END IF      

      Visited = .TRUE.
    END IF 

    Coordinate => Particles % Coordinate
    Velocity => Particles % Velocity
    Coord = 0.0_dp
    Velo = 0.0_dp

    IF( Particles % DtConstant ) THEN
      dtime = Particles % DtSign * Particles % dtime
    END IF

    DO No = 1, Particles % NumberOfParticles
      Status = GetParticleStatus( Particles, No )
      IF( Status >= PARTICLE_LOST ) CYCLE
      IF( Status <= PARTICLE_INITIATED ) CYCLE
      IF( Status == PARTICLE_WALLBOUNDARY ) CYCLE
      
      ElementIndex = GetParticleElement( Particles, No )
      BulkElement => Mesh % Elements( ElementIndex )
      
      Coord(1:dim) = Coordinate( No, 1:dim )

      !-------------------------------------------------------------------------
      ! Get velocity from mesh
      !-------------------------------------------------------------------------
      IF( UseGradVelo ) THEN
        stat = ParticleElementInfo( BulkElement, Coord, &
            SqrtElementMetric, Basis, dBasisdx )
        IF(.NOT. Stat ) CYCLE
        CALL GetVectorFieldInMesh(VeloVar,BulkElement, Basis, VeloAtPoint, &
            dBasisdx, GradVeloAtPoint )

	IF( .NOT. Particles % DtConstant ) THEN
          dtime = Particles % DtSign * DtVar % Values(No)
        END IF

        DO i=1,dim
          Velo(i) = VeloAtPoint(i) + &
              0.5_dp * SUM( GradVeloAtPoint(i,1:dim) * VeloAtPoint(1:dim) ) * dtime        
        END DO
      ELSE
        stat = ParticleElementInfo( BulkElement, Coord, &
            SqrtElementMetric, Basis )
        IF(.NOT. Stat ) CYCLE
        CALL GetVectorFieldInMesh(VeloVar, BulkElement, Basis, VeloAtPoint )
	Velo(1:dim) = VeloAtPoint(1:dim)
      END IF

      Velocity( No, 1:dim ) = Velo(1:dim)
    END DO
    
  END SUBROUTINE SetParticleVelocities
   



  !------------------------------------------------------------------------
  !> Compute field values at the given points in the FE mesh. 
  !-------------------------------------------------------------------------
  SUBROUTINE SetAdvectedField()

    TYPE(Element_t), POINTER :: BulkElement
    INTEGER :: No, Status, NoParticles
    REAL(KIND=dp) :: dtime, Coord(3),Velo(3),val,vals(10)
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Valuelist_t), POINTER :: Params
    LOGICAL :: Stat, Visited = .FALSE.
    INTEGER :: i,j,k,l,n,nsize,dim,wallcount,NoVar,NoNorm,dofs
    INTEGER, POINTER :: NodeIndexes(:)
    REAL(KIND=dp) :: SqrtElementMetric, Norm
    REAL(KIND=dp), POINTER :: Basis(:)
    LOGICAL :: GotIt, Difference,Cumulative,Derivative,GotVar,GotRes,Debug,&
        UsePerm,InternalVariable
    CHARACTER(LEN=MAX_NAME_LEN) :: VariableName, ResultName, OperName, Name
    TYPE(Variable_t), POINTER :: TargetVar, ResultVar, Var
    TYPE(Variable_t), POINTER :: ParticleVar
    REAL(KIND=dp), ALLOCATABLE :: NewValues(:)
    REAL(KIND=dp), POINTER :: TmpValues(:)
    INTEGER, POINTER :: TmpPerm(:)
    REAL(KIND=dp) :: x,y,z
    
    
    SAVE :: Visited
    
    Mesh => GetMesh()
    dim = Mesh % MeshDim
    n = Mesh % MaxElementNodes
    ALLOCATE( Basis(n) )
    Coord = 0.0_dp
    Velo = 0.0_dp

    Params => GetSolverParams()
    NoNorm = GetInteger( Params,'Norm Variable Index',GotIt)
    NoParticles = Particles % NumberOfParticles

    NoVar = 0 
    DO WHILE(.TRUE.)
      NoVar = NoVar + 1

      WRITE (Name,'(A,I0)') 'Variable ',NoVar
      VariableName = GetString( Params,Name,GotVar)
      IF(.NOT. GotVar ) EXIT

      ! Get the target variables
      !------------------------------------------------
      IF( VariableName == 'particle status' .OR. &
          VariableName == 'particle number' .OR. &
          VariableName == 'particle distance' .OR. &
          VariableName == 'particle coordinate_abs' .OR. &
          VariableName == 'particle velocity_abs' .OR. &
	  VariableName == 'particle time' .OR. &
	  VariableName == 'particle dt' ) THEN
        dofs = 1
        InternalVariable = .TRUE.
      ELSE IF( VariableName == 'particle coordinate' .OR. &
          VariableName == 'particle velocity') THEN
        dofs = dim
        InternalVariable = .TRUE.
      ELSE
        TargetVar => VariableGet( Mesh % Variables, TRIM(VariableName) )
        IF( .NOT. ASSOCIATED(TargetVar)) THEN
          CALL Fatal('ParticleAdvector','Could not obtain target variable:'&
              //TRIM(VariableName))
        END IF
        dofs = TargetVar % dofs
        IF( dofs > 1 ) THEN
          CALL Fatal('ParticleAdvector','Advection implemented so far only for scalars')
        END IF
        InternalVariable = .FALSE.
      END IF

      ! For internal variables the target name is the field name
      !---------------------------------------------------------      
      WRITE (Name,'(A,I0)') 'Result Variable ',NoVar
      ResultName = GetString( Params,Name,GotRes)
      IF( .NOT. GotRes ) THEN
        IF( InternalVariable ) THEN
          ResultName = VariableName
        ELSE
          ResultName = 'Adv '//TRIM(VariableName)
        END IF
      END IF

      ! Create variables if they do not exist
      !---------------------------------------------------------      
      ResultVar => VariableGet( Mesh % Variables, TRIM(ResultName) )
      IF( .NOT. ASSOCIATED(ResultVar)) THEN
        IF( InternalVariable ) THEN
          UsePerm = .FALSE.
        ELSE
          UsePerm = ASSOCIATED( TargetVar % Perm ) 
        END IF

        IF(UsePerm) THEN
          n = SIZE(TargetVar % Values)
          NULLIFY(TmpValues)
          ALLOCATE(TmpValues(n))
          TmpValues = 0.0_dp         
          CALL VariableAddVector( Mesh % Variables,Mesh,PSolver,ResultName,dofs,&
              TmpValues,TargetVar % Perm)
        ELSE
          n = NoParticles
          NULLIFY(TmpValues)
          ALLOCATE(TmpValues(n*dofs))
          TmpValues = 0.0_dp
          CALL VariableAddVector( Mesh % Variables,Mesh,PSolver,ResultName,dofs,TmpValues)          
        END IF
        IF( dofs == 1 ) THEN
          CALL Info('ParticleAdvector','Created a scalar variable: '//TRIM(ResultName) )
        ELSE
          CALL Info('ParticleAdvector','Created a vector variable: '//TRIM(ResultName) )          
        END IF
        ResultVar => VariableGet( Mesh % Variables, TRIM(ResultName))
        IF(.NOT. ASSOCIATED(ResultVar)) CALL Fatal('ParticleAdvector','Problems in VariableAdd')
      END IF
      
      IF( .NOT. InternalVariable ) THEN
        WRITE (Name,'(A,I0)') 'Operator ',NoVar
        OperName = GetString( Params,Name,GotIt)
        Difference = .FALSE.
        Derivative = .FALSE.
        Cumulative = .FALSE.
        IF( GotIt ) THEN
          IF( OperName == 'difference' ) THEN
            Difference = .TRUE.
          ELSE IF( OperName == 'derivative') THEN
            Derivative = .TRUE.
          ELSE IF( OperName == 'cumulative') THEN
            Cumulative = .TRUE.
          END IF
        END IF
      END IF

      ! Finally, set the values
      !---------------------------------------------------------      
      IF( InternalVariable ) THEN
        IF( VariableName == 'particle status') THEN
          ResultVar % Values = 1.0_dp * Particles % Status
        ELSE IF( VariableName == 'particle number') THEN
          ResultVar % Values = 1.0_dp * Particles % NodeIndex
        ELSE IF( VariableName == 'particle coordinate') THEN
          IF( ResultVar % Dofs /= dim ) THEN
            CALL Fatal('ParticleAdvector','Variable should have dim dofs: '//TRIM(VariableName))
          END IF
          DO i=1,NoParticles
            DO j=1,dim
              ResultVar % Values(dim*(i-1)+j) = Particles % Coordinate(i,j)
            END DO
          END DO
        ELSE IF( VariableName == 'particle coordinate_abs') THEN
          DO i=1,NoParticles
            ResultVar % Values(i) = 0.0_dp
            DO j=1,dim
              ResultVar % Values(i) = ResultVar % Values(i) + Particles % Coordinate(i,j)**2
            END DO
            ResultVar % Values(i) = SQRT( ResultVar % Values(i) )
          END DO
        ELSE IF( VariableName == 'particle velocity') THEN
          IF( ResultVar % Dofs /= dim ) THEN
            CALL Fatal('ParticleAdvector','Variable should have dim dofs: '//TRIM(VariableName))
          END IF
          DO i=1,NoParticles
            DO j=1,dim
              ResultVar % Values(dim*(i-1)+j) = Particles % Velocity(i,j)
            END DO
          END DO

        ELSE IF( VariableName == 'particle velocity_abs') THEN
          DO i=1,NoParticles
            ResultVar % Values(i) = 0.0_dp
            DO j=1,dim
              ResultVar % Values(i) = ResultVar % Values(i) + Particles % Velocity(i,j)**2
            END DO
            ResultVar % Values(i) = SQRT( ResultVar % Values(i) )
          END DO
        ELSE IF( VariableName == 'particle time' .OR. &
                 VariableName == 'particle dt'   .OR. &
                 VariableName == 'particle distance' ) THEN
          ParticleVar => ParticleVariableGet( Particles, VariableName )
          IF( ASSOCIATED( ParticleVar ) ) THEN
            ResultVar % Values = ParticleVar % Values
          ELSE
            CALL Warn('ParticleAdvector','Field does not exist:'//TRIM(VariableName))
          END IF
        ELSE	
          CALL Warn('ParticleAdvector','Unknown field:'//TRIM(VariableName))
        END IF
      ELSE 

        IF( Cumulative .AND. Visited ) TargetVar => ResultVar 
        
        n = SIZE( TargetVar % Values ) 
        IF( ALLOCATED( NewValues ) ) THEN
          IF( SIZE(NewValues) < n ) DEALLOCATE( NewValues ) 
        END IF
        IF( .NOT. ALLOCATED( NewValues ) ) THEN
          ALLOCATE( NewValues( n ) ) 
          NewValues = 0.0_dp
        END IF

        DO No = 1, NoParticles
          Status = GetParticleStatus( Particles, No )
          
          IF( Status >= PARTICLE_LOST ) CYCLE
          IF( Status <= PARTICLE_INITIATED ) CYCLE
          
          ElementIndex = GetParticleElement( Particles, No )
	  IF( ElementIndex == 0 ) CYCLE

          BulkElement => Mesh % Elements( ElementIndex )      
          
          Coord(1:dim) = Particles % Coordinate(No, 1:dim) 
          Velo(1:dim) = Particles % Velocity(No, 1:dim) 
          
          stat = ParticleElementInfo( BulkElement, Coord, SqrtElementMetric, Basis )
          IF(.NOT. stat) CYCLE

          i = Particles % NodeIndex(No)
          j = i
          IF( ASSOCIATED( ResultVar % Perm)) j = ResultVar % Perm(i)
 
          
          IF( dofs == 1 ) THEN
            CALL GetScalarFieldInMesh(TargetVar, BulkElement, Basis, val ) 
            IF( Difference .OR. Derivative ) THEN
              k = i
              IF( ASSOCIATED( TargetVar % Perm ) ) k = TargetVar % Perm( k )
              NewValues( j ) =  val - TargetVar % Values( k ) 
            ELSE
              NewValues( j ) = val     
            END IF
          ELSE
            CALL GetVectorFieldInMesh(TargetVar, BulkElement, Basis, vals ) 
            IF( Difference .OR. Derivative ) THEN
              k = i
              IF( ASSOCIATED( TargetVar % Perm ) ) k = TargetVar % Perm( k )
              DO l=1,dofs
                NewValues( dofs*(j-1)+l ) =  vals(l) - TargetVar % Values( dofs*(k-1)+l ) 
              END DO
            ELSE
              DO l=1,dofs             
                NewValues( dofs*(j-1)+l ) = vals(l)     
              END DO
            END IF
          END IF
        END DO
        
        IF( Derivative ) NewValues = NewValues / dertime
        
        ! To allow computation of change in the standard manner the Variable
        ! is set to point to the one of interest.
        !---------------------------------------------------------------
        IF( NoVar == NoNorm ) THEN
          Solver % Variable => ResultVar 
          CALL ComputeChange(Solver,.FALSE.,NoParticles,NewValues,ResultVar % Values)
        END IF
        
        ! There most be a temporal vector for the values in case it would point 
        ! to itself. 
        !---------------------------------------------------------------
        j = SIZE( NewValues )
        k = SIZE( ResultVar % Values )
	IF( j /= k ) THEN
	  CALL Warn('ParticleAdvector','Vectors of different size!')
          j = MIN(j,k)
        END IF
        ResultVar % Values(1:j) = NewValues(1:j)
      END IF



    END DO

    NoVar = NoVar - 1
    IF( NoVar < 1 ) THEN
      CALL Fatal('ParticleAdvector','No target and result variables exist!')
    END IF
    
    IF( ALLOCATED( NewValues ) ) DEALLOCATE( NewValues ) 

    Visited = .TRUE.

  END SUBROUTINE SetAdvectedField


!------------------------------------------------------------------------------
END SUBROUTINE ParticleAdvector
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!> Initialization for the primary solver: ParticleAdvector
!> \ingroup Solvers
!------------------------------------------------------------------------------
SUBROUTINE ParticleAdvector_Init( Model,Solver,dt,TransientSimulation )

  USE DefUtils
  USE Interpolation
  USE MeshUtils
  USE ElementUtils
  USE ParticleUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t), TARGET :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------
  
  TYPE(ValueList_t), POINTER :: Params
  LOGICAL :: Found

  Params => Solver % Values

  ! These are default setting that make the operation of the advection solver 
  ! possible. There should always be one passive particle for each active node.
  !---------------------------------------------------------------------------
  CALL ListAddString( Params,'Coordinate Initialization Method','nodal ordered')
  CALL ListAddString( Params,'Velocity Initialization Method','nodal velocity')
  CALL ListAddInteger( Params,'Time Order',0 )
  CALL ListAddConstReal( Params,'Particle Node Fraction',1.0_dp)
  IF(.NOT. ListCheckPresent( Params,'Particle Accurate At Face') ) &
      CALL ListAddLogical( Params,'Particle Accurate At Face',.TRUE.)  
  CALL ListAddLogical( Params,'Particle Dt Negative',.TRUE.)
  CALL ListAddLogical( Params,'Particle Fix Frozen',.TRUE.)

END SUBROUTINE ParticleAdvector_Init
