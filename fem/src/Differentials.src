!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  This module contains some vector utilities, curl, dot, cross, etc...
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 02 Jun 1997
! *
! *****************************************************************************/

MODULE Differentials

  USE Types
  USE Lists
  USE LinearAlgebra
  USE ElementDescription

  IMPLICIT NONE

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION LorentzForce( Element,Nodes,u,v,w,n ) RESULT(L)
!------------------------------------------------------------------------------
    TYPE(Element_t), POINTER :: Element
    TYPE(Nodes_t) :: Nodes
    INTEGER :: n
    REAL(KIND=dp) :: L(3),u,v,w,x,y,z
!------------------------------------------------------------------------------
    TYPE(Variable_t), POINTER :: Mx,My,Mz,MFx,MFy,MFz
    INTEGER :: i,j,k,bfId
    LOGICAL :: stat,GotIt
    INTEGER, POINTER :: NodeIndexes(:)

    TYPE(ValueList_t), POINTER :: Material

    REAL(KIND=dp) :: B(3),dHdx(3,3)
    REAL(KIND=dp) :: dBasisdx(n,3),SqrtElementMetric
    REAL(KIND=dp) :: Basis(n),Permeability(n),mu

    REAL(KIND=dp) :: ExtMx(n),ExtMy(n),ExtMz(n)

    REAL(KIND=dp) :: SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3)
!------------------------------------------------------------------------------
    L = 0.0D0

!     bfId = ListGetInteger( CurrentModel % Bodies( Element % BodyId ) % Values, &
!                 'Body Force', GotIt, 1, CurrentModel % NumberOFBodyForces )

!     IF ( .NOT.GotIt ) RETURN

!     IF ( .NOT.ListGetLogical( CurrentModel % BodyForces( &
!           bfId ) % Values, 'Lorentz Force' , GotIt ) ) RETURN
!------------------------------------------------------------------------------
    NodeIndexes => Element % NodeIndexes

    Mx => VariableGet( CurrentModel % Variables, 'Magnetic Field 1' )
    My => VariableGet( CurrentModel % Variables, 'Magnetic Field 2' )
    Mz => VariableGet( CurrentModel % Variables, 'Magnetic Field 3' )
    IF ( .NOT.ASSOCIATED( Mx ) ) RETURN

    IF ( ANY(Mx % Perm(NodeIndexes)<=0) ) RETURN

    k = ListGetInteger( CurrentModel % Bodies &
                    (Element % BodyId) % Values, 'Material', &
                     minv=1, maxv=CurrentModel % NumberOFMaterials )
    Material => CurrentModel % Materials(k) % Values

    Permeability(1:n) = ListGetReal( Material, 'Magnetic Permeability', &
                              n, NodeIndexes ) 
!------------------------------------------------------------------------------
    ExtMx(1:n) = ListGetReal( Material, 'Applied Magnetic Field 1', &
                    n,NodeIndexes, Gotit )

    ExtMy(1:n) = ListGetReal( Material, 'Applied Magnetic Field 2', &
                  n,NodeIndexes, Gotit )

    ExtMz(1:n) = ListGetReal( Material, 'Applied Magnetic Field 3', &
                  n,NodeIndexes, Gotit )

! If you want to use time-domain solution for high-frequendy part,
! leave external field out. Better to use frequency-domain solver!
#if 1
    MFx => VariableGet( CurrentModel % Variables, 'Magnetic Flux Density 1' )
    MFy => VariableGet( CurrentModel % Variables, 'Magnetic Flux Density 2' )
    MFz => VariableGet( CurrentModel % Variables, 'Magnetic Flux Density 3' )
    IF ( ASSOCIATED( MFx ) ) THEN
      ExtMx(1:n) = ExtMx(1:n) + MFx % Values(MFx % Perm(NodeIndexes))
      ExtMy(1:n) = ExtMy(1:n) + MFy % Values(MFy % Perm(NodeIndexes))
      ExtMz(1:n) = ExtMz(1:n) + MFz % Values(MFz % Perm(NodeIndexes))
    END IF
#endif

!------------------------------------------------------------------------------
!   Get element info 
!------------------------------------------------------------------------------
    stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
               Basis,dBasisdx )
!------------------------------------------------------------------------------
    B(1) = SUM( Basis(1:n)*Mx % Values(Mx % Perm(NodeIndexes)) )
    B(2) = SUM( Basis(1:n)*My % Values(My % Perm(NodeIndexes)) )
    B(3) = SUM( Basis(1:n)*Mz % Values(Mz % Perm(NodeIndexes)) )

    B(1) = B(1) + SUM( Basis(1:n)*ExtMx(1:n) )
    B(2) = B(2) + SUM( Basis(1:n)*ExtMy(1:n) )
    B(3) = B(3) + SUM( Basis(1:n)*ExtMz(1:n) )

    DO i=1,3
      dHdx(1,i) = SUM( dBasisdx(1:n,i)* &
           Mx % Values(Mx % Perm(NodeIndexes)) / Permeability(1:n) )
      dHdx(2,i) = SUM( dBasisdx(1:n,i)* &
           My % Values(My % Perm(NodeIndexes)) / Permeability(1:n) )
      dHdx(3,i) = SUM( dBasisdx(1:n,i)* &
           Mz % Values(Mz % Perm(NodeIndexes)) / Permeability(1:n) )
    END DO
!------------------------------------------------------------------------------
!       Get coordinate system info
!------------------------------------------------------------------------------
    x = SUM( Nodes % x(1:n) * Basis(1:n) )
    y = SUM( Nodes % y(1:n) * Basis(1:n) )
    z = SUM( Nodes % z(1:n) * Basis(1:n) )
    CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,x,y,z )
    IF ( CurrentCoordinateSystem() /= Cartesian ) CALL InvertMatrix( Metric,3 )

    mu = SUM( Permeability(1:n)*Basis(1:n) )
    L = ComputeLorentz( B,dHdx,mu,SqrtMetric,Metric,Symb )

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION ComputeLorentz( B,dHdx,mu,SqrtMetric,Metric,Symb ) RESULT(LF)
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: B(:),dHdx(:,:),mu,LF(3),SqrtMetric,Metric(:,:),Symb(:,:,:)
!------------------------------------------------------------------------------
    INTEGER :: i,j,k,l,m
    REAL(KIND=dp) :: Bc(3),Ji(3),Jc(3),s,Perm(3,3,3),r
!------------------------------------------------------------------------------

    IF ( CurrentCoordinateSystem() == Cartesian ) THEN
      Ji(1) = dHdx(3,2) - dHdx(2,3)
      Ji(2) = dHdx(1,3) - dHdx(3,1)
      Ji(3) = dHdx(2,1) - dHdx(1,2)
      LF(1) = Ji(2)*B(3) - Ji(3)*B(2)
      LF(2) = Ji(3)*B(1) - Ji(1)*B(3)
      LF(3) = Ji(1)*B(2) - Ji(2)*B(1)
      RETURN
    END IF

    r = SqrtMetric

    IF ( CurrentCoordinateSystem()  == CylindricSymmetric ) THEN
      Ji(1) = -dHdx(3,2)
      Ji(2) =  dHdx(3,1)
      IF (r > 1.0d-10) THEN
         Ji(2) = Ji(2) + B(3)/(r*mu)
      ELSE
         Ji(2) = Ji(2) + Ji(2)
      END IF
      Ji(3) = dHdx(1,2) - dHdx(2,1)

      LF(1) = Ji(3)*B(2) - Ji(2)*B(3)
      LF(2) = Ji(1)*B(3) - Ji(3)*B(1)
! You might want to use SI units for the azimuthal component,
! if you compute Lorentz force at nodal points and symmetry axis,
! otherwise you divide by zero.
#ifdef SI_UNITS
      LF(3) = Ji(2)*B(1) - Ji(1)*B(2)
#else
      IF (r > 1.0d-10) THEN
         LF(3) = ( Ji(2)*B(1) - Ji(1)*B(2) ) / r
      ELSE
         LF(3) = 0.d0
      END IF
#endif
      RETURN
    END IF

    Perm = 0
    Perm(1,2,3) = -1.0d0 / SqrtMetric
    Perm(1,3,2) =  1.0d0 / SqrtMetric
    Perm(2,1,3) =  1.0d0 / SqrtMetric
    Perm(2,3,1) = -1.0d0 / SqrtMetric
    Perm(3,1,2) = -1.0d0 / SqrtMetric
    Perm(3,2,1) =  1.0d0 / SqrtMetric
!------------------------------------------------------------------------------

    Bc = 0.0d0
    DO i=1,3
      DO j=1,3
        Bc(i) = Bc(i) + Metric(i,j)*B(j)
      END DO
    END DO

!------------------------------------------------------------------------------

    Ji = 0.0d0
    DO i=1,3
      s = 0.0D0
      DO j=1,3
        DO k=1,3
          IF ( Perm(i,j,k) /= 0 ) THEN
            DO l=1,3
              s = s + Perm(i,j,k)*Metric(j,l)*dHdx(l,k)
              DO m=1,3
                s = s + Perm(i,j,k)*Metric(j,l)*Symb(k,m,l)*B(m)/mu
              END DO
            END DO
          END IF
        END DO
      END DO
      Ji(i) = s
    END DO
 
    Jc = 0.0d0
    DO i=1,3
      DO j=1,3
        Jc(i) = Jc(i) + Metric(i,j)*Ji(j)
      END DO
    END DO
!------------------------------------------------------------------------------

    LF = 0.0d0
    DO i=1,3
      s = 0.0D0
      DO j=1,3
        DO k=1,3
          IF ( Perm(i,j,k) /= 0 ) THEN
            s = s + Perm(i,j,k)*Jc(k)*Bc(j)
          END IF
        END DO
      END DO
      LF(i) = s
    END DO
!------------------------------------------------------------------------------
  END FUNCTION ComputeLorentz
!------------------------------------------------------------------------------
  END FUNCTION LorentzForce
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  FUNCTION JouleHeat( Element,Nodes,u,v,w,n ) RESULT(JouleH)
!------------------------------------------------------------------------------
    TYPE(Element_t) :: Element
    TYPE(Nodes_t) :: Nodes
    INTEGER :: n
    REAL(KIND=dp) :: JouleH,u,v,w,x,y,z
!------------------------------------------------------------------------------
    TYPE(Variable_t), POINTER :: Mx,My,Mz,MFx,MFy,MFz
    INTEGER :: i,j,k,bfId,JouleMode
    LOGICAL :: stat,GotIt
    INTEGER, POINTER :: NodeIndexes(:)

    TYPE(ValueList_t), POINTER :: Material

    REAL(KIND=dp) :: B(3),dHdx(3,3)
    REAL(KIND=dp) :: dBasisdx(n,3),SqrtElementMetric
    REAL(KIND=dp) :: Basis(n),Permeability(n), &
             ElectricConductivity(n)

    REAL(KIND=dp) :: ExtMx(n),ExtMy(n),ExtMz(n)
    REAL(KIND=dp) :: mu,elcond,SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3)
!------------------------------------------------------------------------------
    JouleH = 0.0D0

    bfId = ListGetInteger( CurrentModel % Bodies( Element % BodyId ) % &
         Values, 'Body Force', GotIt, 1, CurrentModel % NumberOfBodyForces )

    IF ( .NOT.GotIt ) RETURN
    
    IF ( .NOT.ListGetLogical( CurrentModel % BodyForces( &
         bfId ) % Values, 'Joule Heat' , GotIt ) ) RETURN
!------------------------------------------------------------------------------
    NodeIndexes => Element % NodeIndexes

    JouleMode = 0
    IF( JouleMode == 0 ) THEN
       Mx => VariableGet( CurrentModel % Variables, 'Joule Field' )
       IF ( ASSOCIATED( Mx ) ) THEN
          IF ( ALL(Mx % Perm(NodeIndexes) > 0) ) JouleMode = 2
       END IF
    END IF

    IF( JouleMode == 0 ) THEN
      Mx => VariableGet( CurrentModel % Variables, 'Magnetic Field 1' )
      IF ( ASSOCIATED( Mx ) ) THEN
        IF ( ALL(Mx % Perm(NodeIndexes) > 0) ) JouleMode = 1
      END IF
    END IF

    IF( JouleMode == 0 ) THEN
       Mx => VariableGet( CurrentModel % Variables, 'Potential' )
       IF ( ASSOCIATED( Mx ) ) THEN
          IF ( ALL(Mx % Perm(NodeIndexes) > 0) ) JouleMode = 3
       END IF
    END IF


    IF( JouleMode == 0) RETURN
    
    !------------------------------------------------------------------------------
    !   Get element info 
    !------------------------------------------------------------------------------
    stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
         Basis,dBasisdx )
    IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
       x = SUM( Nodes % x(1:n) * Basis(1:n))
       y = SUM( Nodes % y(1:n) * Basis(1:n))
       z = SUM( Nodes % z(1:n) * Basis(1:n))
       CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,x,y,z )
       CALL InvertMatrix( Metric,3 )
    END IF

    !------------------------------------------------------------------------------
    !  All modelds need electric conductivity
    !------------------------------------------------------------------------------
    k = ListGetInteger( CurrentModel % Bodies &
         (Element % BodyId) % Values, 'Material')
    Material => CurrentModel % Materials(k) % Values
    
    ElectricConductivity(1:n) = ListGetReal( Material, &
         'Electrical Conductivity',n,NodeIndexes, GotIt )
    IF( GotIt ) THEN
       CALL Warn('JouleHeat','Use electric conductivity instead of electrical')
    ELSE
       ElectricConductivity(1:n) = ListGetReal( Material, &
            'Electric Conductivity',n,NodeIndexes,GotIt )
    END IF
    elcond = SUM( ElectricConductivity(1:n) * Basis(1:n) )


    ! Joule heating takes place only when there is ohmic resistance
    IF( elcond < TINY(elcond) ) RETURN

    !------------------------------------------------------------------------------
    !  Magnetic induction equation
    !------------------------------------------------------------------------------
    IF( JouleMode == 1 ) THEN
       Permeability(1:n) = ListGetReal( Material, 'Magnetic Permeability', &
            n, NodeIndexes ) 
       
       Mx => VariableGet( CurrentModel % Variables, 'Magnetic Field 1' )
       My => VariableGet( CurrentModel % Variables, 'Magnetic Field 2' )
       Mz => VariableGet( CurrentModel % Variables, 'Magnetic Field 3' )
              
       !------------------------------------------------------------------------------
       ExtMx(1:n) = ListGetReal( Material, 'Applied Magnetic Field 1', &
            n,NodeIndexes, Gotit )       
       ExtMy(1:n) = ListGetReal( Material, 'Applied Magnetic Field 2', &
            n,NodeIndexes, Gotit )       
       ExtMz(1:n) = ListGetReal( Material, 'Applied Magnetic Field 3', &
            n,NodeIndexes, Gotit )
!
       MFx => VariableGet( CurrentModel % Variables, 'Magnetic Flux Density 1' )
       MFy => VariableGet( CurrentModel % Variables, 'Magnetic Flux Density 2' )
       MFz => VariableGet( CurrentModel % Variables, 'Magnetic Flux Density 3' )
       IF ( ASSOCIATED( MFx ) ) THEN
          ExtMx(1:n) = ExtMx(1:n) + MFx % Values(MFx % Perm(NodeIndexes))
          ExtMy(1:n) = ExtMy(1:n) + MFy % Values(MFy % Perm(NodeIndexes))
          ExtMz(1:n) = ExtMz(1:n) + MFz % Values(MFz % Perm(NodeIndexes))
       END IF

       !------------------------------------------------------------------------------
       B(1) = SUM( Basis(1:n)*Mx % Values(Mx % Perm(NodeIndexes)) )
       B(2) = SUM( Basis(1:n)*My % Values(My % Perm(NodeIndexes)) )
       B(3) = SUM( Basis(1:n)*Mz % Values(Mz % Perm(NodeIndexes)) )
       
       B(1) = B(1) + SUM( Basis(1:n) * ExtMx(1:n) )
       B(2) = B(2) + SUM( Basis(1:n) * ExtMy(1:n) )
       B(3) = B(3) + SUM( Basis(1:n) * ExtMz(1:n) )
       
       mu = SUM( Basis(1:n) * Permeability(1:n) )
       DO i=1,3
          dHdx(1,i) = SUM( dBasisdx(1:n,i)* &
               Mx % Values(Mx % Perm(NodeIndexes))/Permeability(1:n) )
          dHdx(2,i) = SUM( dBasisdx(1:n,i)* &
               My % Values(My % Perm(NodeIndexes))/Permeability(1:n) )
          dHdx(3,i) = SUM( dBasisdx(1:n,i)* &
               Mz % Values(Mz % Perm(NodeIndexes))/Permeability(1:n) )
       END DO
       
       JouleH = ComputeMagneticHeat( B,dHdx,mu,SqrtMetric,Metric,Symb ) / &
            elcond            
    END IF

     !------------------------------------------------------------------------------
    !  Axisymmetric vector potential
    !------------------------------------------------------------------------------
    IF( JouleMode == 2) THEN
       JouleH = elcond * SUM( Basis(1:n)*Mx % Values(Mx % Perm(NodeIndexes)) )
    END IF

   !------------------------------------------------------------------------------
    !  Static current condution
    !------------------------------------------------------------------------------
    IF( JouleMode == 3) THEN
       ! The electric field at IP
       B(1) = SUM( dBasisdx(1:n,1) * Mx % Values(Mx % Perm(NodeIndexes)) )
       B(2) = SUM( dBasisdx(1:n,2) * Mx % Values(Mx % Perm(NodeIndexes)) )
       B(3) = SUM( dBasisdx(1:n,3) * Mx % Values(Mx % Perm(NodeIndexes)) )     
       JouleH = elcond * SUM( B * B )
    END IF

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION ComputeMagneticHeat( B,dHdx,mu,SqrtMetric,Metric,Symb ) RESULT(JH)
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: B(:),dHdx(:,:),mu,JH,SqrtMetric,Metric(:,:),Symb(:,:,:)
!------------------------------------------------------------------------------
    INTEGER :: i,j,k,l,m
    REAL(KIND=dp) :: Bc(3),Ji(3),Jc(3),s,Perm(3,3,3),r
!------------------------------------------------------------------------------

    IF ( CurrentCoordinateSystem() == Cartesian ) THEN
      Ji(1) = dHdx(3,2) - dHdx(2,3)
      Ji(2) = dHdx(1,3) - dHdx(3,1)
      Ji(3) = dHdx(2,1) - dHdx(1,2)
      JH = Ji(1)*Ji(1) + Ji(2)*Ji(2) + Ji(3)*Ji(3)
      RETURN
    END IF

    IF ( CurrentCoordinateSystem() == CylindricSymmetric ) THEN
      r = SqrtMetric
      Ji(1) = -dHdx(3,2)
      Ji(2) = B(3)/(r*mu) + dHdx(3,1)
      Ji(3) = dHdx(1,2) - dHdx(2,1)
      JH = Ji(1)*Ji(1) + Ji(2)*Ji(2) + Ji(3)*Ji(3)
      RETURN
    END IF

    Perm = 0
    Perm(1,2,3) = -1.0d0 / SqrtMetric
    Perm(1,3,2) =  1.0d0 / SqrtMetric
    Perm(2,1,3) =  1.0d0 / SqrtMetric
    Perm(2,3,1) = -1.0d0 / SqrtMetric
    Perm(3,1,2) = -1.0d0 / SqrtMetric
    Perm(3,2,1) =  1.0d0 / SqrtMetric
!------------------------------------------------------------------------------

    Bc = 0.0d0
    DO i=1,3
      DO j=1,3
        Bc(i) = Bc(i) + Metric(i,j)*B(j)
      END DO
    END DO

!------------------------------------------------------------------------------

    Ji = 0.0d0
    DO i=1,3
      s = 0.0D0
      DO j=1,3
        DO k=1,3
          IF ( Perm(i,j,k) /= 0 ) THEN
            DO l=1,3
              s = s + Perm(i,j,k)*Metric(j,l)*dHdx(l,k)
              DO m=1,3
                s = s + Perm(i,j,k)*Metric(j,l)*Symb(k,m,l)*B(m)/mu
              END DO
            END DO
          END IF
        END DO
      END DO
      Ji(i) = s
    END DO
 
    Jc = 0.0d0
    DO i=1,3
      DO j=1,3
        Jc(i) = Jc(i) + Metric(i,j)*Ji(j)
      END DO
    END DO

!------------------------------------------------------------------------------

    JH = 0.0d0
    DO i=1,3
      JH = JH + Ji(i) * Jc(i)
    END DO
!------------------------------------------------------------------------------
  END FUNCTION ComputeMagneticHeat
!------------------------------------------------------------------------------
  END FUNCTION JouleHeat
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
! Compute the curl vector B = curl(A) at model nodes
!------------------------------------------------------------------------------
  SUBROUTINE Curl( Ax,Ay,Az,Bx,By,Bz,Reorder )
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: Ax(:),Ay(:),Az(:),Bx(:),By(:),Bz(:)
    INTEGER :: Reorder(:)
!------------------------------------------------------------------------------
    TYPE(Element_t), POINTER :: Element
    TYPE(Nodes_t) :: Nodes 

    LOGICAL :: Stat
    INTEGER :: i,j,k,l,m,n,p,q,t
    REAL(KIND=dp) :: x,y,z,u,v,w,s,A(3),B(3),dx(3,3)

    INTEGER :: Perm(3,3,3)
    INTEGER, POINTER :: NodeIndexes(:),Visited(:)

    REAL(KIND=dp), ALLOCATABLE :: dBasisdx(:,:)
    REAL(KIND=dp), ALLOCATABLE :: Basis(:),aaz(:)

    REAL(KIND=dp) :: SqrtElementMetric
    REAL(KIND=dp) :: SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3)
!------------------------------------------------------------------------------

    ALLOCATE( Visited(CurrentModel % NumberOfNodes) )
    Visited = 0

    Perm = 0
    Perm(1,2,3) = -1
    Perm(1,3,2) =  1
    Perm(2,1,3) =  1
    Perm(2,3,1) = -1
    Perm(3,1,2) = -1
    Perm(3,2,1) =  1

    n = CurrentModel % Mesh % MaxElementNodes
    ALLOCATE( dBasisdx(n,3), Basis(n), aaz(n) )
    ALLOCATE( Nodes % x(n), Nodes % y(n), Nodes % z(n) )

    Bx = 0.0D0
    By = 0.0D0
    Bz = 0.0D0
!------------------------------------------------------------------------------
!   Go trough model elements, we will compute on average of elementwise
!   curls on nodes of the model
!------------------------------------------------------------------------------
    DO t=1,CurrentModel % NumberOfBulkElements
!------------------------------------------------------------------------------
      Element => CurrentModel % Elements(t)
      n = Element % TYPE % NumberOfNodes
      NodeIndexes => Element % NodeIndexes

      Nodes % x(1:n) = CurrentModel % Nodes % x( NodeIndexes )
      Nodes % y(1:n) = CurrentModel % Nodes % y( NodeIndexes )
      Nodes % z(1:n) = CurrentModel % Nodes % z( NodeIndexes )
!------------------------------------------------------------------------------
!     Trough element nodes
!------------------------------------------------------------------------------

      IF (MINVAL(Reorder(NodeIndexes)) > 0) THEN

      DO p=1,n
        q = Reorder(NodeIndexes(p))
        u = Element % TYPE % NodeU(p)
        v = Element % TYPE % NodeV(p)

        IF ( Element % TYPE % DIMENSION == 3 ) THEN
          w = Element % TYPE % NodeW(p)
        ELSE
          w = 0.0D0
        END IF
!------------------------------------------------------------------------------
!       Get element basis functions, basis function derivatives, etc,
!       and compute partials derivatives of the vector A with respect
!       to global coordinates.
!------------------------------------------------------------------------------
        stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
                  Basis,dBasisdx )
!------------------------------------------------------------------------------
!       Get coordinate system info
!------------------------------------------------------------------------------
        IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
          x = SUM( Nodes % x(1:n) * Basis(1:n))
          y = SUM( Nodes % y(1:n) * Basis(1:n))
          z = SUM( Nodes % z(1:n) * Basis(1:n))
          CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,x,y,z )
          CALL InvertMatrix( Metric,3 )
        END IF

!        print *, '***',p
!        print *, '***',x,y,z
!        print *, '***',NodeIndexes
!        print *, '***',Reorder(NodeIndexes)

        DO k=1,3
          dx(1,k) = SUM( dBasisdx(1:n,k) * Ax(Reorder(NodeIndexes)) )
          dx(2,k) = SUM( dBasisdx(1:n,k) * Ay(Reorder(NodeIndexes)) )
          dx(3,k) = SUM( dBasisdx(1:n,k) * Az(Reorder(NodeIndexes)) )
        END DO
!------------------------------------------------------------------------------
!       And compute the curl for the node of the current element
!------------------------------------------------------------------------------
        IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
          A(1) = Ax(q)
          A(2) = Ay(q)
          A(3) = Az(q)
          B = 0.0D0
          IF ( ABS(SqrtMetric) > 1.0d-15 ) THEN
            DO i=1,3
              s = 0.0D0
              DO j=1,3
                DO k=1,3
                  IF ( Perm(i,j,k) /= 0 ) THEN
                    DO l=1,3
                      s = s + Perm(i,j,k)*Metric(j,l)*dx(l,k)
                      DO m=1,3
                        s = s + Perm(i,j,k)*Metric(j,l)*Symb(k,m,l)*A(m)
                      END DO
                    END DO
                  END IF
                END DO
              END DO
              B(i) = s
            END DO
       
            Bx(q) = Bx(q) + B(1) / SqrtMetric
            By(q) = By(q) + B(2) / SqrtMetric
            Bz(q) = Bz(q) + B(3) / SqrtMetric
          END IF
        ELSE

          Bx(q) = Bx(q) + dx(3,2) - dx(2,3)
          By(q) = By(q) + dx(1,3) - dx(3,1)
          Bz(q) = Bz(q) + dx(2,1) - dx(1,2)

        END IF
        Visited(q) = Visited(q) + 1
      END DO

    END IF

!------------------------------------------------------------------------------
    END DO
!------------------------------------------------------------------------------
!   Finally, compute average of the the curls at nodes
!------------------------------------------------------------------------------
    DO i=1,CurrentModel % NumberOfNodes
      IF ( Visited(i) > 0 ) THEN
        Bx(i) = Bx(i) / Visited(i)
        By(i) = By(i) / Visited(i)
        Bz(i) = Bz(i) / Visited(i)
      END IF
    END DO

    DEALLOCATE( Visited, Nodes % x, Nodes % y, Nodes % z, Basis, dBasisdx, aaz )
!------------------------------------------------------------------------------
  END SUBROUTINE Curl
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
SUBROUTINE AxiSCurl( Ar,Az,Ap,Br,Bz,Bp,Reorder )
!------------------------------------------------------------------------------
  IMPLICIT NONE
  REAL(KIND=dp) :: Ar(:),Az(:),Ap(:),Br(:),Bz(:),Bp(:)
  INTEGER :: Reorder(:)

  TYPE(Element_t), POINTER :: Element
  TYPE(Nodes_t) :: Nodes 

  LOGICAL :: Stat

  INTEGER, POINTER :: NodeIndexes(:),Visited(:)
  INTEGER :: p,q,i,t,n

  REAL(KIND=dp) :: u,v,w,r

  REAL(KIND=dp) :: SqrtElementMetric
  REAL(KIND=dp), ALLOCATABLE :: Basis(:), dBasisdx(:,:)
  
!------------------------------------------

  ALLOCATE( Visited(CurrentModel % NumberOfNodes) )

 
  n = CurrentModel % Mesh % MaxElementDOFs
  ALLOCATE( Basis(n), dBasisdx(n,3) )
  ALLOCATE(Nodes % x(n),Nodes % y(n),Nodes % z(n))

  Visited = 0

  Br = 0.0d0
  Bz = 0.0d0
  Bp = 0.0d0

  DO t=1,CurrentModel % NumberOfBulkElements

     Element => CurrentModel % Elements(t)
     n = Element % TYPE % NumberOfNodes
     NodeIndexes => Element % NodeIndexes

     Nodes % x(1:n) = CurrentModel % Nodes % x( NodeIndexes )
     Nodes % y(1:n) = CurrentModel % Nodes % y( NodeIndexes )
     Nodes % z(1:n) = CurrentModel % Nodes % z( NodeIndexes )

     IF ( MINVAL(Reorder(NodeIndexes)) > 0 ) THEN

        DO p=1,n

           q = Reorder(NodeIndexes(p))
           u = Element % TYPE % NodeU(p)
           v = Element % TYPE % NodeV(p)

           IF ( Element % TYPE % DIMENSION == 3 ) THEN
              w = Element % TYPE % NodeW(p)
           ELSE
              w = 0.0D0
           END IF

           stat = ElementInfo( Element, Nodes, u, v, w, SqrtElementMetric, &
                          Basis, dBasisdx )

           r = SUM( Basis(1:n) * Nodes % x(1:n) )

           Br(q) = Br(q) - SUM( dBasisdx(1:n,2)*Ap(Reorder(NodeIndexes)) )

           Bp(q) = Bp(q) + SUM( dBasisdx(1:n,2) * Ar(Reorder(NodeIndexes)) ) &
                - SUM( dBasisdx(1:n,1) * Az(Reorder(NodeIndexes)) )

           Bz(q) = Bz(q) + SUM( dBasisdx(1:n,1) * Ap(Reorder(NodeIndexes)) )

           IF (r > 1.0d-10) THEN
              Bz(q) = Bz(q) + SUM( Basis(1:n)*Ap(Reorder(NodeIndexes)) ) / r
           ELSE
              Bz(q) = Bz(q) + SUM( dBasisdx(1:n,1)*Ap(Reorder(NodeIndexes)) )
           END IF

           Visited(q) = Visited(q) + 1
           
        END DO
     END IF
  END DO

  DO i=1,CurrentModel % NumberOfNodes
     IF ( Visited(i) > 0 ) THEN
        Br(i) = Br(i) / Visited(i)
        Bp(i) = Bp(i) / Visited(i)
        Bz(i) = Bz(i) / Visited(i)
     END IF
  END DO

  DEALLOCATE( Visited, Basis, dBasisdx )
  DEALLOCATE( Nodes % x, Nodes % y, Nodes % z )

!------------------------------------------------------------------------------
END SUBROUTINE AxiSCurl
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
! Compute the curl vector B = curl(A) at model nodes, A given at edge dofs
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
SUBROUTINE WhitneyCurl( Ae,Bx,By,Bz,Reorder,nedges )
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: Ae(:),Bx(:),By(:),Bz(:)
    INTEGER :: Reorder(:),nedges
!------------------------------------------------------------------------------
    TYPE(Element_t) :: Element
    TYPE(Nodes_t) :: Nodes 

    LOGICAL :: Stat
    INTEGER :: i,j,k,l,m,n,p,q,t
    REAL(KIND=dp) :: x,y,z,u,v,w,s,A(3),B(3),dx(3,3)

    INTEGER, POINTER :: NodeIndexes(:),Visited(:)

    REAL(KIND=dp), ALLOCATABLE :: dBasisdx(:,:)
    REAL(KIND=dp), ALLOCATABLE :: Basis(:),aaz(:)

    REAL(KIND=dp) :: WhitneyBasis(nedges,3), SqrtElementMetric
    REAL(KIND=dp) :: dWhitneyBasisdx(nedges,3,3)

    REAL(KIND=dp) :: SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3)
!------------------------------------------------------------------------------

    ALLOCATE( Visited(CurrentModel % NumberOfNodes) )
    Visited = 0

    n = CurrentModel % Mesh % MaxElementNodes
    ALLOCATE( Basis(n), dBasisdx(n,3), aaz(n) )
    ALLOCATE( Nodes % x(n), Nodes % y(n), Nodes % z(n) )

    Bx = 0.0D0
    By = 0.0D0
    Bz = 0.0D0
!------------------------------------------------------------------------------
!   Go through model elements, we will compute on average of elementwise
!   curls on nodes of the model
!------------------------------------------------------------------------------
    DO t=1,CurrentModel % NumberOfBulkElements
!------------------------------------------------------------------------------
      Element = CurrentModel % Elements(t)

      IF ( Element % Type % ElementCode/100 == 3 ) THEN
         Element % Type => GetElementType( 303 )
      ELSE
         Element % Type => GetElementType( 504 )
      END IF

      n = Element % Type % NumberOfNodes
      NodeIndexes => Element % NodeIndexes

      Nodes % x(1:n) = CurrentModel % Nodes % x( NodeIndexes )
      Nodes % y(1:n) = CurrentModel % Nodes % y( NodeIndexes )
      Nodes % z(1:n) = CurrentModel % Nodes % z( NodeIndexes )
!------------------------------------------------------------------------------
!     Through element nodes
!------------------------------------------------------------------------------

      IF (MINVAL(Reorder(NodeIndexes)) > 0) THEN

      DO p=1,n+nedges
        q = Reorder(NodeIndexes(p))
        u = Element % Type % NodeU(p)
        v = Element % Type % NodeV(p)
        w = Element % Type % NodeW(p)

!------------------------------------------------------------------------------
!       Get element basis functions, basis function derivatives, etc,
!       and compute partials derivatives of the vector A with respect
!       to global coordinates.
!------------------------------------------------------------------------------
        stat = ElementInfo( Element, Nodes, u, v, w, SqrtElementMetric, &
                    Basis, dBasisdx )

        stat = WhitneyElementInfo( Element, Basis, dBasisdx,&
               nedges, WhitneyBasis, dWhitneyBasisdx )

        DO k=1,3
          dx(1,k) = SUM( dWhitneyBasisdx(1:nedges,1,k)*Ae(Reorder(NodeIndexes(n+1:n+nedges))))
          dx(2,k) = SUM( dWhitneyBasisdx(1:nedges,2,k)*Ae(Reorder(NodeIndexes(n+1:n+nedges))))
          dx(3,k) = SUM( dWhitneyBasisdx(1:nedges,3,k)*Ae(Reorder(NodeIndexes(n+1:n+nedges))))      
        END DO

!------------------------------------------------------------------------------
!       And compute the curl for the node of the current element
!------------------------------------------------------------------------------

        Bx(q) = Bx(q) + dx(3,2) - dx(2,3)
        By(q) = By(q) + dx(1,3) - dx(3,1)
        Bz(q) = Bz(q) + dx(2,1) - dx(1,2)

        Visited(q) = Visited(q) + 1
      END DO

    END IF

!------------------------------------------------------------------------------
    END DO
!------------------------------------------------------------------------------
!   Finally, compute average of the the curls at nodes
!------------------------------------------------------------------------------
    DO i=1,CurrentModel % NumberOfNodes
      IF ( Visited(i) > 0 ) THEN
        Bx(i) = Bx(i) / Visited(i)
        By(i) = By(i) / Visited(i)
        Bz(i) = Bz(i) / Visited(i)
      END IF
    END DO

    DEALLOCATE( Visited, Basis, dBasisdx, nodes % x, Nodes % y, Nodes % z, aaz )
!------------------------------------------------------------------------------
  END SUBROUTINE WhitneyCurl
!------------------------------------------------------------------------------


!-------------------------------------------------
!  Compute divergence in cylindrical coordinates
!-------------------------------------------------

SUBROUTINE Divergence(dive,Ar,Az,Aphi,Reorder)
  IMPLICIT NONE
  REAL(KIND=dp) :: dive(:),Ar(:),Az(:),Aphi(:)
  INTEGER :: Reorder(:)

  TYPE(Element_t), POINTER :: Element
  TYPE(Nodes_t) :: Nodes 

  LOGICAL :: Stat

  INTEGER, POINTER :: NodeIndexes(:),Visited(:)
  
  REAL(KIND=dp), ALLOCATABLE :: Basis(:), dBasisdx(:,:)

  INTEGER :: t,n,p,i,q
  REAL(KIND=dp) :: u,v,w,r, SqrtElementMetric

!--------------------------------------------------------------
 
  ALLOCATE( Visited(CurrentModel % NumberOfNodes) )

  n = CurrentModel % Mesh % MaxElementNodes
  ALLOCATE( Basis(n), dBasisdx(n,3) )
  ALLOCATE(Nodes % x(n),Nodes % y(n),Nodes % z(n))

  Visited = 0

  dive=0

  DO t=1,CurrentModel % NumberOfBulkElements

   Element => CurrentModel % Elements(t) 
   n = Element % TYPE % NumberOfNodes
   NodeIndexes => Element % NodeIndexes

   Nodes % x(1:n) = CurrentModel % Nodes % x( NodeIndexes )
   Nodes % y(1:n) = CurrentModel % Nodes % y( NodeIndexes )
   Nodes % z(1:n) = CurrentModel % Nodes % z( NodeIndexes )

   IF (MINVAL(Reorder(NodeIndexes)) > 0) THEN

   DO p=1,n

     q = Reorder(NodeIndexes(p))
     u = Element % TYPE % NodeU(p)
     v = Element % TYPE % NodeV(p)

     IF ( Element % TYPE % DIMENSION == 3 ) THEN
       w = Element % TYPE % NodeW(p)
     ELSE
       w = 0.0D0
     END IF

     stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
         Basis,dBasisdx )

     r = SUM(Basis(1:n)*nodes % x(1:n))

     dive(q) = dive(q) + SUM(dBasisdx(1:n,1)*Ar(Reorder(NodeIndexes))) &
         + SUM(dBasisdx(1:n,3)*Aphi(Reorder(NodeIndexes))) &
         + SUM(dBasisdx(1:n,2)*Az(Reorder(NodeIndexes)))

     IF (r > 1d-10) THEN
       dive(q) = dive(q) + SUM(Basis(1:n)*Ar(Reorder(NodeIndexes)))/r
     ELSE
       dive(q) = dive(q) + SUM(dBasisdx(1:n,1)*Ar(Reorder(NodeIndexes)))
     END IF

     Visited(q) = Visited(q) + 1

   END DO

 END IF

END DO

DO i=1,CurrentModel % NumberOfNodes
  IF ( Visited(i) > 1 ) THEN
    dive(i) = dive(i)/Visited(i)
  END IF
END DO

DEALLOCATE( Visited )
DEALLOCATE(Nodes%x,nodes%y,nodes%z, Basis, dBasisdx )

END SUBROUTINE Divergence

!------------------------------------------------------------------------------
!  Compute cross product of given vectors
!------------------------------------------------------------------------------
  SUBROUTINE Cross( Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,n )
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz
!------------------------------------------------------------------------------
    INTEGER :: i,j,k,n
    REAL(KIND=dp) :: SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3),x,y,z
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
!   Compute the cross product
!------------------------------------------------------------------------------
    Cx = Ay * Bz - Az * By
    Cy = Az * Bx - Ax * Bz
    Cz = Ax * By - Ay * Bx
!------------------------------------------------------------------------------
!   Make contravariant
!------------------------------------------------------------------------------
    IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
      x = CurrentModel % Nodes % x(n)
      y = CurrentModel % Nodes % y(n)
      z = CurrentModel % Nodes % z(n)
      CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,x,y,z )

      x = SqrtMetric * Cx
      y = SqrtMetric * Cy
      z = SqrtMetric * Cz

      Cx = Metric(1,1)*x + Metric(1,2)*y + Metric(1,3)*z
      Cy = Metric(2,1)*x + Metric(2,2)*y + Metric(2,3)*z
      Cz = Metric(3,1)*x + Metric(3,2)*y + Metric(3,3)*z
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE Cross
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE DivCheck(Ur,Uz,Up,FlowPerm,Brv,Bzv,Bpv,MagPerm,EB,EMagPerm)
!------------------------------------------------------------------------------
    IMPLICIT NONE

    DOUBLE PRECISION :: Ur(:),Uz(:),Up(:),Brv(:),Bpv(:),Bzv(:),EB(:)
    INTEGER :: FlowPerm(:),MagPerm(:),EMagPerm(:)

!

    TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff
    TYPE(Element_t), POINTER :: Element
    TYPE(Nodes_t) :: Nodes
    INTEGER :: N_Integ
    DOUBLE PRECISION, DIMENSION(:), POINTER :: U_Integ,V_Integ,W_Integ,S_Integ
    INTEGER, POINTER :: NodeIndexes(:)
    DOUBLE PRECISION :: Basis(27),dBasisdx(27,3)
    DOUBLE PRECISION :: u,v,w,SqrtElementMetric,r,s
    DOUBLE PRECISION :: Vr,Vp,Vz,dVdx(3,3),Br,Bp,Bz,dBdx(3,3),divb,vdivb
    DOUBLE PRECISION :: iBr,iBp,iBz,eBr,eBp,eBz,idBdx(3,3),edBdx(3,3)
    DOUBLE PRECISION :: idivb,edivb,eref,iref
!    double precision, allocatable :: dive(:)
    INTEGER :: t,i,n,j,p,q
    LOGICAL :: stat

!

    ALLOCATE(Nodes%x(27),Nodes%y(27),Nodes%z(27) &
!        ,dive(CurrentModel%NumberofNodes))
        )


    iref=0
    eref=0
    vdivb=0

!    open(10)

!    dive=0

    DO t=1,CurrentModel % NumberOfBulkElements
      Element => CurrentModel % Elements(t)
      n = Element % TYPE % NumberOfNodes
      NodeIndexes => Element % NodeIndexes

      IF ( ANY(FlowPerm(NodeIndexes)==0) .OR. ANY(MagPerm(NodeIndexes)==0) &
          .OR. ANY(EMagPerm(NodeIndexes)==0) ) THEN
        CYCLE
      END IF

      Nodes % x(1:n) = CurrentModel % Nodes % x(NodeIndexes)
      Nodes % y(1:n) = CurrentModel % Nodes % y(NodeIndexes)
      Nodes % z(1:n) = CurrentModel % Nodes % z(NodeIndexes)
      
      IntegStuff = GaussPoints( Element )
      U_Integ => IntegStuff % u
      V_Integ => IntegStuff % v
      W_Integ => IntegStuff % w
      S_Integ => IntegStuff % s
      N_Integ =  IntegStuff % n

!----------------------

#if 0
      WRITE (10,*) t
      WRITE (10,*) MagPerm(NodeIndexes)
   DO p=1,n

     q = MagPerm(NodeIndexes(p))
     u = Element % TYPE % NodeU(p)
     v = Element % TYPE % NodeV(p)

     IF ( Element % TYPE % DIMENSION == 3 ) THEN
       w = Element % TYPE % NodeW(p)
     ELSE
       w = 0.0D0
     END IF

     stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
         Basis,dBasisdx )

     r = SUM(Basis(1:n)*nodes % x(1:n))

     dive(q) = dive(q) + SUM(dBasisdx(1:n,1)*Brv(MagPerm(NodeIndexes))) &
!         + SUM(dBasisdx(1:n,3)*Aphi(MagPerm(NodeIndexes))) &
         + SUM(dBasisdx(1:n,2)*Bzv(MagPerm(NodeIndexes)))

     IF (r > 1d-10) THEN
       dive(q) = dive(q) + SUM(Basis(1:n)*Brv(MagPerm(NodeIndexes)))/r
     ELSE
       dive(q) = dive(q) + SUM(dBasisdx(1:n,1)*Brv(MagPerm(NodeIndexes)))
     END IF
     WRITE (10,*) q
     WRITE (10,*) SUM(Basis(1:n)*Brv(MagPerm(NodeIndexes)))/r &
         + SUM(dBasisdx(1:n,1)*Brv(MagPerm(NodeIndexes))) &
         + SUM(dBasisdx(1:n,2)*Bzv(MagPerm(NodeIndexes)))


   END DO
!   write (10,*) SUM(Basis(1:n)*Brv(MagPerm(NodeIndexes)))
!   write (10,*) SUM(dBasisdx(1:n,1)*Brv(MagPerm(NodeIndexes)))
!   write (10,*) SUM(dBasisdx(1:n,2)*Bzv(MagPerm(NodeIndexes)))
    WRITE (10,*) 'div',dive(MagPerm(NodeIndexes))
#endif

!--------------------

      DO i=1,N_Integ

        u = U_Integ(i)
        v = V_Integ(i)
        w = W_Integ(i)
      
        stat = ElementInfo( Element,Nodes,u,v,w,SqrtElementMetric, &
            Basis,dBasisdx )

        r = SUM( Basis(1:n)*nodes%x(1:n) )
        s = r * SqrtElementMetric * S_Integ(i)

        iBr = SUM(Basis(1:n)*Brv(MagPerm(NodeIndexes))) 
        eBr = SUM(Basis(1:n)*EB(3*EMagPerm(NodeIndexes)-2))
        Br = iBr + eBr

        iBp = SUM(Basis(1:n)*Bpv(MagPerm(NodeIndexes))) 
        eBp = SUM(Basis(1:n)*EB(3*EMagPerm(NodeIndexes)-0))
        Bp = iBp + eBp

        iBz = SUM(Basis(1:n)*Bzv(MagPerm(NodeIndexes))) 
        eBz = SUM(Basis(1:n)*EB(3*EMagPerm(NodeIndexes)-1))
        Bz = iBz + eBz

        Vr = SUM(Basis(1:n)*Ur(FlowPerm(NodeIndexes)))
        Vp = SUM(Basis(1:n)*Up(FlowPerm(NodeIndexes)))
        Vz = SUM(Basis(1:n)*Uz(FlowPerm(NodeIndexes)))

!        PRINT *,'---------'
!        PRINT *, Br,Bp,Bz
!        PRINT *, Vr,Vp,Vz
!        PRINT *,'---------'

        DO j=1,3
          idBdx(1,j) = SUM(dBasisdx(1:n,j)*Brv(MagPerm(NodeIndexes)))
          edBdx(1,j) = SUM(dBasisdx(1:n,j)*EB(3*EMagPerm(NodeIndexes)-2))

          idBdx(2,j) = SUM(dBasisdx(1:n,j)*Bzv(MagPerm(NodeIndexes))) 
          edBdx(2,j) = SUM(dBasisdx(1:n,j)*EB(3*EMagPerm(NodeIndexes)-1))

          idBdx(3,j) = SUM(dBasisdx(1:n,j)*Bpv(MagPerm(NodeIndexes))) 
          edBdx(3,j) = SUM(dBasisdx(1:n,j)*EB(3*EMagPerm(NodeIndexes)-0))

          dVdx(1,j) = SUM(dBasisdx(1:n,j)*Ur(FlowPerm(NodeIndexes)))
          dVdx(2,j) = SUM(dBasisdx(1:n,j)*Uz(FlowPerm(NodeIndexes)))
          dVdx(3,j) = r * SUM( dBasisdx(1:n,j)*Up(FlowPerm(NodeIndexes)))
        END DO

        dBdx = idBdx + edBdx

!        print *, '--------------'
!        print *, eBr,eBp,eBz
!        print *, iBr,iBp,iBz
!        print *, r
!        print *, '--------------'

        dVdx(3,1) = Vp + dVdx(3,1)
        Vp = r * Vp

        iref=iref+s*( &
            (dVdx(1,2)*iBz+dVdx(1,1)*iBr-Vz*idBdx(1,2)-Vr*idBdx(1,1))**2 &
            + (dVdx(3,2)*iBz+dVdx(3,1)*iBr-Vz*idBdx(3,2)-Vr*idBdx(3,1) &
            + (Vr*iBp-Vp*iBr)/r)**2 &
            + (dVdx(2,1)*iBr+iBz*dVdx(2,2)-Vz*idBdx(2,2)-Vr*idBdx(2,1))**2 )

        eref=eref+s*( &
            (dVdx(1,2)*eBz+dVdx(1,1)*eBr-Vz*edBdx(1,2)-Vr*edBdx(1,1))**2 &
            + (dVdx(3,2)*eBz+dVdx(3,1)*eBr-Vz*edBdx(3,2)-Vr*edBdx(3,1) &
            + (Vr*eBp-Vp*eBr)/r)**2 &
            + (dVdx(2,1)*eBr+eBz*dVdx(2,2)-Vz*edBdx(2,2)-Vr*edBdx(2,1))**2 )

#if 0        

eref=eref+s*( &
    +(Vp*eBz-Vz*eBp)**2+(Vr*eBz-Vz*eBr)**2+(Vr*eBp-Vp*eBr)**2)
iref=iref+s*( &
    +(Vp*iBz-Vz*iBp)**2+(Vr*iBz-Vz*iBr)**2+(Vr*iBp-Vp*iBr)**2)

#endif     
        idivb = iBr/r + idBdx(1,1) + idBdx(2,2)
        edivb = eBr/r + edBdx(1,1) + edBdx(2,2)
        divb = idivb + edivb

!        PRINT *,'idivb, edivb',idivb,edivb
        

        vdivb=vdivb+s*( (Vr**2+Vp**2+Vz**2)*idivb**2 )
!        vdivb=vdivb+s*( (Vr**2+Vz**2)*idivb**2 )

      END DO

    END DO

!    close(10)

    eref = SQRT(eref)
    iref = SQRT(iref)
    vdivb = SQRT(vdivb)

    OPEN(10,status='UNKNOWN',position='APPEND')

    WRITE(10,*)  '   '
    WRITE(10,*)  '*********************************************************'
    WRITE(10,*)  'Divcheck'
    WRITE(10,*)  eref,iref,vdivb
    WRITE(10,*)  '*********************************************************'
    WRITE(10,*)  '   '

    CLOSE(10)

!------------------------------------------------------------------------------
  END SUBROUTINE DivCheck
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!  Compute dot product of given vectors
!------------------------------------------------------------------------------
  FUNCTION Dot( Ax,Ay,Az,Bx,By,Bz,n ) RESULT(L)
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: Ax,Ay,Az,Bx,By,Bz
    REAL(KIND=dp) :: L
!------------------------------------------------------------------------------
    INTEGER :: i,j,k,n
    REAL(KIND=dp) :: SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3),x,y,z
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
!     Compute the dot product
!------------------------------------------------------------------------------
    IF ( CurrentCoordinateSystem() == Cartesian ) THEN
      L =  Ax*Bx + Ay*By + Az*Bz
    ELSE
      x = CurrentModel % Nodes % x(n)
      y = CurrentModel % Nodes % y(n)
      z = CurrentModel % Nodes % z(n)
      CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,x,y,z )
!
!  NOTE: this is for orthogonal coordinates only
!
      L = Ax*Bx / Metric(1,1) + Ay*By / Metric(2,2) + Az*Bz / Metric(3,3)
    END IF
!------------------------------------------------------------------------------
  END FUNCTION Dot
!------------------------------------------------------------------------------

END MODULE Differentials
