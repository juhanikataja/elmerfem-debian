!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Module for projecting results in structured 3d mesh to a 2d surface.
! *  The procedure is limited structured meshes where nodes are aligned with 
! *  a given coordinate direction. 
! *
! ******************************************************************************
! *
! *  Authors: Peter Råback
! *  Email:   Peter.Raback@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 3.3.2008
! *
! *****************************************************************************/

!------------------------------------------------------------------------------
SUBROUTINE StructuredProjectToPlane( Model,Solver,dt,Transient )
!------------------------------------------------------------------------------

  USE CoordinateSystems
  USE DefUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
!******************************************************************************
!
!  This solver assumes that the mesh is structural so that it could have 
!  been obtained by extrusion in the direction of interest. For the given 
!  direction the corresponding top and bottom node is computed for every node
!  and this information is used to perform projection to the top or bottom
!  plane.
!
!  ARGUMENTS:
!
!  TYPE(Model_t) :: Model,  
!     INPUT: All model information (mesh,materials,BCs,etc...)
!
!  TYPE(Solver_t) :: Solver
!     INPUT: Linear equation solver options
!
!  REAL(KIND=dp) :: dt,
!     INPUT: Timestep size for time dependent simulations (NOTE: Not used
!            currently)
!
!******************************************************************************

  TYPE(Model_t)  :: Model
  TYPE(Solver_t), TARGET :: Solver
  LOGICAL ::  Transient
  REAL(KIND=dp) :: dt
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------
  TYPE(ValueList_t),POINTER :: SolverParams
  TYPE(Solver_t), POINTER :: PSolver
  CHARACTER(LEN=MAX_NAME_LEN) :: VarName, Name, Oper, LevelsetName, TargetName
  INTEGER :: i,j,k,l,n,dim,DOFs,itop,ibot,iup,jup,ii,jj,Rounds,nsize,layer, &
      ActiveDirection,elem,TopNodes,NoVar
  INTEGER, POINTER :: MaskPerm(:),TopPointer(:),&
      BotPointer(:),UpPointer(:),DownPointer(:),NodeIndexes(:),&
      Perm2d(:),Perm3d(:),LevelsetPerm(:),TopPerm(:)
  LOGICAL :: GotIt, Found, Visited = .FALSE., Initialized = .FALSE.,&
      Debug, MaskExist, GotVar, GotOper
  REAL(KIND=dp) :: dx,UnitVector(3),ElemVector(3),DotPro,Eps,Length,Level,val
  REAL(KIND=dp) :: at0,at1,at2,CPUTime,RealTime
  REAL(KIND=dp), POINTER :: Field2d(:), Field3d(:), Levelset(:), Coord(:)
  TYPE(Variable_t), POINTER :: Var, OldVar
  TYPE(Element_t), POINTER :: Element
  TYPE(Nodes_t) :: Nodes
  TYPE(ValueList_t),POINTER :: BC

  
  SAVE Visited,Nodes,Initialized,UnitVector,Coord,MaskExist,MaskPerm,TopPointer,BotPointer,&
      UpPointer,DownPointer,Field2d,Field3d,TopNodes,TopPerm
 
  CALL Info( 'StructuredProjectToPlane','------------------------------------------',Level=4 )
  CALL Info( 'StructuredProjectToPlane','Performing projection on a structured mesh ',Level=4 )
  CALL Info( 'StructuredProjectToPlane','------------------------------------------',Level=4 )

!------------------------------------------------------------------------------
!   Initialize the pointers to top and bottom nodes 
!------------------------------------------------------------------------------

  Debug = .FALSE.
  SolverParams => GetSolverParams()
  PSolver => Solver

  IF( .NOT. Initialized ) THEN

    IF(Debug) CALL Info('StructuredProjectToPlane','start init')
    at0 = CPUTime()

    ! Choose active direction coordinate and set corresponding unit vector
    !---------------------------------------------------------------------
    DIM = CoordinateSystemDimension()
    ActiveDirection = GetInteger(SolverParams,'Active Coordinate')
    IF(ActiveDirection == 1) THEN
      Var => VariableGet( Solver % Mesh % Variables,'Coordinate 1')
    ELSE IF(ActiveDirection == 2) THEN
      Var => VariableGet( Solver % Mesh % Variables,'Coordinate 2')
    ELSE IF(ActiveDirection == 3) THEN 
      Var => VariableGet( Solver % Mesh % Variables,'Coordinate 3')
    ELSE 
      CALL Fatal('StructuredProjectToPlane','Invalid value for Active Coordinate')
    END IF
    Coord => Var % Values
    nsize = SIZE( Coord )
    UnitVector = 0.0_dp
    UnitVector(ActiveDirection) = 1.0_dp

    IF( GetLogical(SolverParams,'Project To Bottom',GotIt) ) &
        UnitVector = -1.0_dp * UnitVector

    ! Allocate pointers to top and bottom, and temporary pointers up and down
    !------------------------------------------------------------------------
    ALLOCATE(TopPointer(nsize),UpPointer(nsize),&
        BotPointer(nsize),DownPointer(nsize),&
        TopPerm(nsize))
    DO i=1,nsize
      TopPointer(i) = i
      UpPointer(i) = i
      BotPointer(i) = i
      DownPointer(i) = i
    END DO

    ! If mask variable is provided only those nodes will be moved
    !-----------------------------------------------------------   
    VarName = GetString(SolverParams,'Projection Mask Variable',GotIt )
    MaskExist = .FALSE.
    IF(GotIt) THEN
      Var => VariableGet( Model % Variables,  VarName )
      IF(ASSOCIATED(Var)) THEN
        MaskPerm => Var % Perm
        MaskExist = ASSOCIATED(MaskPerm)
      END IF
    END IF

    ! Determine the pointer up and down using dot product as criterion
    !-----------------------------------------------------------------
    Eps = GetConstReal(SolverParams,'Dot Product Tolerance',GotIt)
    IF(.NOT. GotIt) Eps = 0.01_dp

    IF(Debug) CALL Info('StructuredProjectToPlane','determine up and down pointers')

    DO elem = 1,Solver % Mesh % NumberOfBulkElements      
      Element => Solver % Mesh % Elements(elem)
      NodeIndexes => Element % NodeIndexes
      Model % CurrentElement => Element
      CALL GetElementNodes( Nodes )
      n  = GetElementNOFNodes()

      IF (Element % PartIndex .NE. Parenv % Mype) CYCLE

      IF( MaskExist ) THEN
        IF( ANY(MaskPerm(NodeIndexes) == 0) ) CYCLE
      END IF

      DO i=1,n
        ii = NodeIndexes(i)
        DO j=i+1,n
          jj = NodeIndexes(j)

          ElemVector(1) = Nodes % x(j) - Nodes % x(i)
          ElemVector(2) = Nodes % y(j) - Nodes % y(i)
          ElemVector(3) = Nodes % z(j) - Nodes % z(i)
          Length = SQRT(SUM(ElemVector*ElemVector))
          DotPro = SUM(ElemVector * UnitVector) / Length
          
          IF(DotPro > 1.0_dp - Eps) THEN
            UpPointer(ii) = jj
            DownPointer(jj) = ii
          ELSE IF(DotPro < Eps - 1.0_dp) THEN
            DownPointer(ii) = jj
            UpPointer(jj) = ii
          END IF
        END DO
      END DO
    END DO
    
    ! Pointer to top and bottom are found recursively using up and down
    !------------------------------------------------------------------
    IF(Debug) CALL Info('StructuredProjectToPlane','determine top and bottom pointers')

    Found = .TRUE.
    Rounds = 0
    DO WHILE(Found) 
      Found = .FALSE.
      DO i=1,nsize
        IF( MaskExist ) THEN
          IF( MaskPerm(i) == 0) CYCLE
        END IF
        j = UpPointer(i)
        IF( TopPointer(i) /= TopPointer( j ) ) THEN
          Found = .TRUE.
          TopPointer(i) = TopPointer( j )
        END IF
        j = DownPointer(i)
        IF( BotPointer(i) /= BotPointer( j ) ) THEN
          Found = .TRUE.
          BotPointer(i) = BotPointer( j )
        END IF
      END DO
      IF( Found ) Rounds = Rounds + 1
    END DO

    TopNodes = 0
    TopPerm = 0
    DO i=1,nsize
      IF(TopPointer(i) == i) THEN
        TopNodes = TopNodes + 1
        TopPerm(i) = TopNodes
      END IF
    END DO

    at1 = CPUTime()  
    WRITE(Message,* ) 'Top and bottom pointer init rounds: ',Rounds
    CALL Info('StructuredProjectToPlane',Message)
    WRITE(Message,* ) 'Number of nodes at the surface: ',TopNodes
    CALL Info('StructuredProjectToPlane',Message)
    WRITE(Message,* ) 'Top and bottom pointer init time: ',at1-at0
    CALL Info('StructuredProjectToPlane',Message)

    Initialized = .TRUE.
  END IF
  at0 = CPUTime()


  ! End of initialization
  !-------------------------------------------------------

  !------------------------------------------------------------------------------
  ! Go through the variables and compute the desired projections
  !------------------------------------------------------------------------------
  GotVar  = .TRUE.
  GotOper = .FALSE.
  NULLIFY(OldVar)
  NoVar = 0
  
  DO WHILE(GotVar .OR. GotOper)

    NoVar = NoVar + 1    
    IF(Debug) PRINT *,'NoVar',NoVar

    WRITE (Name,'(A,I0)') 'Variable ',NoVar
    VarName = ListGetString( Solver % Values, TRIM(Name), GotVar )
    NULLIFY(Var)    
    IF(GotVar) THEN
      Var => VariableGet( Model % Variables, TRIM(VarName) )
      IF ( .NOT. ASSOCIATED( Var ) )  THEN
        Var => OldVar
        IF ( .NOT. ASSOCIATED( Var ) ) THEN
          CALL Warn('StructuredProjectToPlane','The desired variable does not exist!')
          CYCLE
        END IF
      END IF
    ELSE
      IF(ASSOCIATED(OldVar)) Var => OldVar
    END IF    
    IF(.NOT. ASSOCIATED(Var)) CYCLE 
    OldVar => Var        
    Field3d => Var % Values
    Perm3d => Var % Perm
   
    WRITE (Name,'(A,I0)') 'Operator ',NoVar
    Oper = ListGetString(Solver % Values,TRIM(Name),GotOper)
    IF(.NOT. GotOper) CYCLE 

    IF(Oper == 'isosurface') THEN
      WRITE (Name,'(A,I0)') 'Isosurface Field ',NoVar
      LevelsetName = ListGetString(Solver % Values,TRIM(Name),GotIt )
      IF(GotIt) THEN
        Var => VariableGet( Model % Variables, TRIM(LevelsetName) )
        Levelset => Var % Values
        LevelsetPerm => Var % Perm
      ELSE       
        Levelset => Coord
        NULLIFY(LevelsetPerm)
      END IF
      
      WRITE (Name,'(A,I0)') 'Isosurface Value ',NoVar
      Level = ListGetConstReal(Solver % Values,TRIM(Name),GotIt)
    END IF

    ! Create the projected variable if needed
    !-----------------------------------------------
    IF(debug) PRINT *,'check target variables'
    TargetName = TRIM(Oper) // ' ' // TRIM(VarName) 
    Var => VariableGet( Model % Variables, TRIM(TargetName) )
    IF ( .NOT. ASSOCIATED( Var ) )  THEN      
      NULLIFY(Field2d)
      ALLOCATE( Field2d(TopNodes) )
      Field2d = 0.0_dp
      CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, PSolver, &
          TargetName, 1, Field2D, TopPerm)           
      NULLIFY(Field2d)
      Var => VariableGet( Model % Variables, TRIM(TargetName) )
    END IF
    Field2d => Var % Values
    Perm2d => Var % Perm
   

    ! Map the 3d data into the 2d plane 
    !-----------------------------------------------
    IF(debug) PRINT *,'Operator:',TRIM(Oper)
    SELECT CASE(Oper)      
      
    CASE ('sum')      
      DO i=1,nsize
        itop = TopPointer(i)
        j = i
        IF(ASSOCIATED(Perm3d)) j = Perm3d(i)
        IF(j == 0) CYCLE
        val = Field3d(j)
        Field2d(Perm2d(itop)) = Field2d(Perm2d(itop)) + val 
      END DO
      
    CASE ('min')      
      Field2d = HUGE(Field2d)
      DO i=1,nsize
        itop = TopPointer(i)
        j = i
        IF(ASSOCIATED(Perm3d)) j = Perm3d(i)
        IF(j == 0) CYCLE
        Field2d(Perm2d(itop)) = MIN( Field3d(j), Field2d(Perm2d(itop)) )
      END DO
      
    CASE ('max')      
      Field2d = -HUGE(Field2d)
      DO i=1,nsize
        itop = TopPointer(i)
        j = i
        IF(ASSOCIATED(Perm3d)) j = Perm3d(i)
        IF(j == 0) CYCLE
        Field2d(Perm2d(itop)) = MAX( Field3d(j), Field2d(Perm2d(itop)) )
      END DO
      
    CASE ('bottom')
      DO i=1,nsize
        IF( i == BotPointer(i) ) THEN
          j = i
          IF(ASSOCIATED(Perm3d)) j = Perm3d(i)
          Field2d(Perm2d(TopPointer(i))) = Field3d(j)
        END IF
      END DO

    CASE ('layer')
      layer = GetInteger( Solver % Values, 'Mesh Layer', GotIt )
      IF (.NOT.GotIt) &
           CALL FATAL('StructuredProjectToPlane','no >Mesh Layer< indicated for output')
      DO i=1,nsize
        IF( i == TopPointer(i) ) THEN
           l = i
           DO k=1,layer
              l = DownPointer(l)
           END DO
           IF(ASSOCIATED(Perm3d)) l = Perm3d(l)
           Field2d(Perm2d(i)) = Field3d(l)
        END IF
      END DO
      
    CASE ('isosurface')
      DO i=1,nsize
        iup = UpPointer(i)
        j = i
        jup = iup
        IF(ASSOCIATED(LevelsetPerm)) THEN
          j = LevelsetPerm(j)
          jup = LevelsetPerm(jup)
        END IF
        IF(j == 0 .OR. jup == 0) CYCLE

        IF( (Levelset(jup) - Level) * (Levelset(j) - Level) <= 0.0_dp ) THEN
          itop = TopPointer(i)           
          dx = ABS(Levelset(jup) - Levelset(j))           
          IF(ASSOCIATED(Perm3d)) THEN
            Field2d(Perm2d(itop)) = &
                ABS(Levelset(jup)-Level) * Field3d(Perm3d(i)) / dx + &
                ABS(Level-Levelset(j)) * Field3d(Perm3d(iup)) / dx 
          ELSE
            Field2d(Perm2d(itop)) = &
                ABS(Levelset(jup)-Level) * Field3d(i) / dx + &
                ABS(Level-Levelset(j)) * Field3d(iup) / dx            
          END IF
        END IF
      END DO
      
    CASE ('int')
      DO i=1,nsize
        itop = TopPointer(i)
        dx = 0.5*(Coord(UpPointer(i)) - Coord(DownPointer(i)))
        j = i
        IF(ASSOCIATED(Perm3d)) j = Perm3d(i) 
        Field2d(Perm2d(itop)) = Field2d(Perm2d(itop)) + dx * Field3d(j)
      END DO
      
    CASE default
      CALL Warn('StructuredProjectToPlane','Unknown operator: '//TRIM(Oper))

    END SELECT
    
  END DO

  at1 = CPUTime()

  WRITE(Message,* ) 'Projection time: ',at1-at0
  CALL Info('StructuredProjectToPlane',Message)

!------------------------------------------------------------------------------
END SUBROUTINE StructuredProjectToPlane
!------------------------------------------------------------------------------
