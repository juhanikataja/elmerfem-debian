!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Subroutines for saving scalar data and line data to files
! *
! ******************************************************************************
! *
! *  Authors: Peter Råback
! *  Email:   Peter.Raback@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 20 Nov 2001
! *
! *****************************************************************************/

!------------------------------------------------------------------------------
SUBROUTINE SaveScalars( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
!******************************************************************************
!
!  This subroutine saves scalar values to a matrix.
!
!  ARGUMENTS:
!
!  TYPE(Model_t) :: Model,  
!     INPUT: All model information (mesh, materials, BCs, etc...)
!
!  TYPE(Solver_t) :: Solver
!     INPUT: Linear & nonlinear equation solver options
!
!  REAL(KIND=dp) :: dt,
!     INPUT: Timestep size for time dependent simulations
!
!  LOGICAL :: TransientSimulation
!     INPUT: Steady state or transient simulation
!
!******************************************************************************
  USE DefUtils
  USE Interpolation

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t), TARGET :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  CHARACTER(LEN=MAX_NAME_LEN), PARAMETER :: DefaultScalarsFile = 'scalars.dat'

  TYPE(Solver_t), POINTER :: ParSolver
  TYPE(ValueList_t), POINTER :: Lst
  TYPE(Variable_t), POINTER :: Var, OldVar
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Element_t),POINTER :: CurrentElement
  TYPE(Nodes_t) :: ElementNodes
  LOGICAL :: SubroutineVisited=.FALSE.,MovingMesh, GotCoeff, &
      GotIt, GotOper, GotVar, ExactCoordinates, VariablesExist, &
      ComplexEigen, Parallel, LiveGraph, FileAppend, SaveEigenValue, &
      SaveEigenFreq, CheckNorm, IsInteger
  LOGICAL, POINTER :: ValuesInteger(:)

  REAL (KIND=DP) :: Minimum, Maximum, AbsMinimum, AbsMaximum, &
      Mean, Variance, Dist, x, y, z, Deviation, Vol, Intmean, intvar, &
      KineticEnergy, PotentialEnergy, FieldEnergy, & 
      IntSquare, LocalCoords(3), TempCoordinates(3), Value, &
      Change, Norm = 0.0_dp, PrevNorm
  REAL (KIND=DP), ALLOCATABLE :: Values(:), CoordinateDist(:), &
      CoordinatesBasis(:,:), ElementValues(:), BoundaryFluxes(:),BoundaryAreas(:)
  REAL (KIND=DP), POINTER :: PointCoordinates(:,:), LineCoordinates(:,:)
  INTEGER, ALLOCATABLE :: BoundaryHits(:)
  INTEGER, POINTER :: PointIndex(:), CoordinateIndex(:), CoordinatesElemNo(:), &
      NodeIndexes(:)
  CHARACTER(LEN=MAX_NAME_LEN), ALLOCATABLE :: ValueNames(:)
  CHARACTER(LEN=MAX_NAME_LEN) :: ScalarsFile, ScalarNamesFile, DateStr, &
      VariableName, ResultPrefix, Oper, Name, CoefficientName, ScalarParFile
  INTEGER :: i,j,k,l,q,n,No,NoPoints,NoCoordinates,NoLines,NumberOfVars,&
      NoDims, NoDofs, NoOper, NoElements, NoVar, NoValues, PrevNoValues=0, DIM, &
      MaxVars, NoEigenValues, Ind, EigenDofs, LineInd, NormInd
  REAL (KIND=DP) :: CPUTime, CPUMemory

  SAVE SubroutineVisited, NumberOfVars, &
      NoPoints, PointIndex, CoordinateIndex, CoordinateDist, ResultPrefix, &
      Values, ValueNames, ValuesInteger, NoCoordinates, ScalarsFile, ScalarNamesFile, &
      ExactCoordinates, CoordinatesElemNo, NoElements, ElementNodes, &
      ElementValues, CoordinatesBasis, PointCoordinates, NoDims, &
      BoundaryFluxes, BoundaryAreas, BoundaryHits, VariablesExist, NoLines, &
      LineCoordinates, ScalarParFile, Parallel, ParSolver, PrevNoValues, &
      LiveGraph, CheckNorm, Norm

!------------------------------------------------------------------------------

  Mesh => Model % Meshes
  DO WHILE( ASSOCIATED(Mesh) )
    IF ( Mesh % OutputActive ) EXIT 
    Mesh => Mesh % Next
  END DO
  CALL SetCurrentMesh( Model, Mesh )

  DIM = CoordinateSystemDimension()
 

  IF(.NOT.SubroutineVisited) THEN
    
    FileAppend = ListGetLogical( Solver % Values,'File Append',GotIt)

    CheckNorm = ListGetLogical( Solver % Values,'Show norm',GotIt )

    ScalarsFile = ListGetString(Solver % Values,'Filename',GotIt )
    IF(.NOT. GotIt) ScalarsFile = DefaultScalarsFile

    IF(ListGetLogical(Solver % Values,'Filename Numbering',GotIt)) THEN
      ScalarsFile = NextFreeFilename( ScalarsFile ) 
    END IF
    
    ScalarNamesFile = TRIM(ScalarsFile) // '.' // TRIM("names")
    
    ResultPrefix = ListGetString(Solver % Values,'Scalars Prefix',GotIt )
    IF(.NOT. gotIt) ResultPrefix = 'res:'

    LiveGraph = ListGetLogical(Solver % Values,'Live Graph',GotIt) 
    
    NoLines = 0
    LineCoordinates => ListGetConstRealArray(Solver % Values,'Polyline Coordinates',gotIt)
    IF(gotIt) THEN
      NoLines = SIZE(LineCoordinates,1) / 2
      NoDims = SIZE(LineCoordinates,2)
    END IF

    NoPoints = 0
    PointIndex => ListGetIntegerArray( Solver % Values,'Save Points',GotIt)
    IF ( gotIt ) NoPoints = SIZE(PointIndex)
    
    NoCoordinates = 0
    NoElements = 0
    PointCoordinates => ListGetConstRealArray(Solver % Values,'Save Coordinates',gotIt)
    IF(gotIt) THEN
      NoDims = SIZE(PointCoordinates,2)
      ExactCoordinates = ListGetLogical(Solver % Values,'Exact Coordinates',GotIt )      
      IF(ExactCoordinates) THEN
        NoElements = SIZE(PointCoordinates,1)
        n = Mesh % MaxElementNodes
        ALLOCATE( CoordinatesElemNo(NoElements), ElementValues(n), &
            CoordinatesBasis(NoElements,n) )
      ELSE
        NoCoordinates = SIZE(PointCoordinates,1)
        ALLOCATE(CoordinateIndex(NoCoordinates), CoordinateDist(NoCoordinates))
      END IF
    END IF

    Parallel = .FALSE.
    DO i = 1, Model % NumberOfSolvers
      ParSolver => Model % Solvers(i)
      IF ( .NOT. ASSOCIATED( ParSolver % Matrix ) )  CYCLE
      IF ( ASSOCIATED( ParSolver % Matrix % ParMatrix ) ) THEN
        IF ( ParSolver %  Matrix % ParMatrix % ParEnv % PEs > 1 )  THEN
          Parallel = .TRUE.
          EXIT
        END IF
      END IF
    END DO

!------------------------------------------------------------------------------
    n = Mesh % MaxElementNodes
    ALLOCATE( ElementNodes % x(n), ElementNodes % y(n), ElementNodes % z(n))

    n = MAX( Model % NumberOfBodies, MAX(Model % NumberOfBCs, NoLines))
    ALLOCATE( BoundaryFluxes(n), BoundaryAreas(n), BoundaryHits(n) )

  END IF


  ComplexEigen = ListGetLogical(Solver % Values,'Complex Eigen Vectors',GotIt)
  MovingMesh = ListGetLogical(Solver % Values,'Moving Mesh',GotIt )
  
  IF(.NOT.SubroutineVisited .OR. MovingMesh) THEN
    
    ! Find the indexes of minimum distances
    IF(NoCoordinates > 0) THEN
      
      CoordinateDist = HUGE(Dist)
      DO i=1,Model % NumberOfNodes
        x = Mesh % Nodes % x(i)
        y = Mesh % Nodes % y(i)
        z = Mesh % Nodes % z(i)
        
        DO j=1,NoCoordinates
          Dist = (x-PointCoordinates(j,1))**2 + &
              (y-PointCoordinates(j,2))**2
          IF(NoDims == 3) THEN
            Dist = Dist + (z-PointCoordinates(j,3))**2
          END IF
          IF(Dist < CoordinateDist(j)) THEN
            CoordinateDist(j) = Dist
            CoordinateIndex(j) = i
          END IF
        END DO
      END DO
    END IF


    ! Write the value at the given coordinate points, really.
    ! Thus, find the point j's element and the local coordinates

    IF(NoElements > 0) THEN

      CoordinatesBasis = 0.0d0
      
      DO j=1,NoElements

        ! Go through all old model bulk elements (could use quadrant tree!)
        DO k=1,Mesh % NumberOfBulkElements

          CurrentElement => Mesh % Elements(k)
          n = CurrentElement % TYPE % NumberOfNodes
          NodeIndexes => CurrentElement % NodeIndexes
          
          ElementNodes % x(1:n) = Mesh % Nodes % x(NodeIndexes)
          ElementNodes % y(1:n) = Mesh % Nodes % y(NodeIndexes)
          ElementNodes % z(1:n) = Mesh % Nodes % z(NodeIndexes)
          
          TempCoordinates = 0.0d0
          DO i = 1, NoDims
            TempCoordinates(i) = PointCoordinates(j,i)
          END DO

          IF ( PointInElement( CurrentElement, ElementNodes, &
              TempCoordinates, LocalCoords ) ) EXIT
        END DO       
        
        IF ( k > Mesh % NumberOfBulkElements ) THEN
          WRITE( Message, * ) 'Coordinate was not found in any of the elements!',j
          CALL Warn( 'SaveScalars', Message )
          CoordinatesElemNo(j) = 1          
          CoordinatesBasis(j,:) = 0.0d0
        ELSE
          CoordinatesElemNo(j) = k
          ElementValues(1:n) = 0.0d0
          DO q=1,N
            ElementValues(q) = 1.0d0
            CoordinatesBasis(j,q) = InterpolateInElement( CurrentElement, ElementValues, &
                LocalCoords(1), LocalCoords(2), LocalCoords(3) )
            ElementValues(q) = 0.0d0
          END DO
        END IF
        
      END DO
    END IF
  END IF
    

  CALL Info( 'SaveScalars', '-----------------------------------------', Level=4 )
  WRITE( Message, * ) 'Saving scalar values to file ', TRIM(ScalarsFile)
  CALL Info( 'SaveScalars', Message, Level=4 )
  CALL Info( 'SaveScalars', '-----------------------------------------', Level=4 )

  NoValues = 0

  !------------------------------------------------------------------------------
  ! Read the scalars defined in other modules
  !------------------------------------------------------------------------------
  Lst => Model % Simulation
  DO WHILE( ASSOCIATED( Lst ) )    
    IF ( Lst % Name(1:4) == TRIM(ResultPrefix) ) THEN
      CALL AddToSaveList(Lst % Name, Lst % Fvalues(1,1,1))
    END IF
    Lst => Lst % Next
  END DO

  !------------------------------------------------------------------------------
  !   Add eigenvalues on the list if told to
  !------------------------------------------------------------------------------

  SaveEigenValue = ListGetLogical( Solver % Values, 'Save Eigenvalues', GotIt )
  SaveEigenFreq = ListGetLogical( Solver % Values, 'Save Eigenfrequencies', GotIt )
  IF(.NOT. GotIt) &
    SaveEigenFreq = ListGetLogical( Solver % Values, 'Save Eigen Frequencies', GotIt ) 

  IF ( SaveEigenValue .OR. SaveEigenFreq ) THEN
    DO i = 1, Model % NumberOfSolvers       
      IF ( Model % Solvers(i) % NOFEigenValues > 0 ) THEN
        DO j = 1, Model % Solvers(i) % NOFEigenValues
          
          k = Model % Solvers(i) % NOFEigenValues - j + 1
          Value = Model % Solvers(i) % Variable % EigenValues(k)
          
          IF ( SaveEigenValue ) THEN
            WRITE( Name, '("eigen: value ", I2)' ) k
            CALL AddToSaveList(TRIM(Name), Value)
          END IF 

          IF ( SaveEigenFreq ) THEN
            WRITE( Name, '("eigen: frequency ", I2, " [Hz]")' ) k
            IF ( REAL( Model % Solvers(i) % Variable % EigenValues(k)) > 0 ) THEN
              Value = SQRT(REAL(Value)) / (2*PI)
            ELSE
              Value = -1.0d0
            END IF
            CALL AddToSaveList(TRIM(Name), Value)
          END IF

        END DO
      END IF
    END DO
  END IF
    
  !------------------------------------------------------------------------------
  ! Go through the variables and compute the desired statistical data
  !------------------------------------------------------------------------------
  GotVar  = .TRUE.
  GotOper = .FALSE.
  NULLIFY(OldVar)
  NoVar = 0
  
  DO WHILE(GotVar .OR. GotOper)
    
    GotOper = .FALSE.
    NULLIFY(Var)
    
    NoVar = NoVar + 1
    
    IF(NoVar < 10) THEN 
      WRITE (Name,'(A,I2)') 'Variable',NoVar
    ELSE
      WRITE (Name,'(A,I3)') 'Variable',NoVar
    END IF
      
    VariableName = ListGetString( Solver % Values, TRIM(Name), GotVar )

    IF(GotVar) THEN      
      ! Check first two special case with no variables on the list
      IF(TRIM(VariableName) == 'cpu time') THEN
        CALL AddToSaveList('value: cpu time from start (s)',CPUTime())
        CYCLE        
      END IF
      
      IF(TRIM(VariableName) == 'cpu memory') THEN
        CALL AddToSaveList('value: maximum memory usage (kb)',CPUMemory())
        CYCLE        
      END IF

      Var => VariableGet( Model % Variables, TRIM(VariableName) )
      IF ( .NOT. ASSOCIATED( Var ) )  THEN
        Var => OldVar
        IF ( .NOT. ASSOCIATED( Var ) ) THEN
          CALL Warn('SaveData','The desired variable does not exist!')
          CYCLE
        END IF
      END IF    
    ELSE
      IF(ASSOCIATED(OldVar)) Var => OldVar
    END IF
    
    IF(.NOT. ASSOCIATED(Var)) CYCLE 

    
    IF(SIZE(Var % Values) == Var % Dofs) THEN
      IF(.NOT. GotVar) CYCLE
      IsInteger = .FALSE.
      IF( VariableName == 'nonlin iter' ) IsInteger = .TRUE.
      IF( VariableName == 'coupled iter' ) IsInteger = .TRUE.

      IF( Var % Dofs == 1 ) THEN
        CALL AddToSaveList('value: '//TRIM(VariableName)//' scalar variable', &
                            Var % Values(1), IsInteger )
      ELSE
        DO j=1,Var % DOfs
          CALL AddToSaveList('value: '//ComponentName(VariableName,j)//' scalar variable', Var % Values(j))          
        END DO
      END IF
      CYCLE
    END IF
    
    OldVar => Var        
    NoOper = NoVar 
    
    IF(NoOper < 10) THEN
      WRITE (Name,'(A,I2)') 'Operator',NoOper
    ELSE
      WRITE (Name,'(A,I3)') 'Operator',NoOper    
    END IF
    Oper = ListGetString(Solver % Values,TRIM(Name),GotOper)
    
    IF(NoOper < 10) THEN
      WRITE (Name,'(A,I2)') 'Coefficient',NoOper
    ELSE
      WRITE (Name,'(A,I3)') 'Coefficient',NoOper    
    END IF
    CoefficientName = ListGetString(Solver % Values,TRIM(Name),GotCoeff )

    IF ( GotOper ) THEN

      SELECT CASE(Oper)

      CASE ('norm')
        Value = Var % Norm
        CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName),Value)

      CASE ('nonlin change')
        Value = Var % NonlinChange
        CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName),Value)

      CASE ('steady state change')
        Value = Var % SteadyChange
        CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName),Value)

      CASE ('nonlin iter')
        Value = Var % NonlinIter
        CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName),Value,.TRUE.)

      CASE ('nonlin converged')
        Value = 1.0_dp * Var % NonlinConverged
        CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName),Value,.TRUE.)

      CASE ('steady converged')
        Value = 1.0_dp * Var % SteadyConverged
        CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName),Value,.TRUE.)

      CASE ('nodes')
        Value = 1.0_dp * Solver % Mesh % NumberOfNodes
        CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName),Value,.TRUE.)

      CASE ('elements')
        Value = 1.0_dp * Solver % Mesh % NumberOfBulkElements
        CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName),Value,.TRUE.)

      CASE ('dofs')
        Value = 1.0_dp * SIZE(Var % Values)
        CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName),Value,.TRUE.)

      CASE ('sum','max','min','max abs','min abs','mean','variance') 
        Value = VectorStatistics(Var,Oper)
        CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName),Value)
        
      CASE ('deviation')
        Value = VectorMeanDeviation(Var,Oper)
        CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName), Value)
        
      CASE ('int','int mean','int variance','volume',&
        'potential energy','diffusive energy','convective energy')

        Value = BulkIntegrals(Var, Oper, GotCoeff, CoefficientName)
        IF(GotCoeff) THEN
          CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName)//' with '//TRIM(CoefficientName), Value)
        ELSE
          CALL AddToSaveList(TRIM(Oper)//': '//TRIM(VariableName), Value)
        END IF

      CASE('boundary sum','boundary dofs','boundary mean','boundary max','boundary min',&
          'boundary max abs','boundary min abs')
        BoundaryHits = 0
        BoundaryFluxes = 0.0_dp         
        CALL BoundaryStatistics(Var, Oper, GotCoeff, &
            CoefficientName, BoundaryFluxes, BoundaryHits)
        DO j=1,Model % NumberOfBCs
          IF( ListGetLogical(Model % BCs(j) % Values,'Flux Integrate',gotIt ) .OR. &
              ListGetLogical(Model % BCs(j) % Values,'Save Scalars',gotIt ) ) THEN
            WRITE (Name,'(A,A,A,A,I2)') TRIM(Oper),': ',TRIM(VariableName),' over bc',j
            CALL AddToSaveList( TRIM(Name), BoundaryFluxes(j))
          END IF
        END DO
        
      CASE ('boundary int','boundary int mean','area','diffusive flux','convective flux')
        BoundaryHits = 0
        BoundaryFluxes = 0.0_dp
        BoundaryAreas = 0.0_dp      
        Minimum = 0.0_dp
        Maximum = 0.0_dp

        CALL BoundaryIntegrals(Var, Oper, GotCoeff, CoefficientName,&
            BoundaryFluxes,BoundaryAreas,BoundaryHits)

        DO j=1,Model % NumberOfBCs
          IF( BoundaryHits(j) > 0 ) THEN
            IF( TRIM(Oper) == 'boundary int mean' ) THEN
              BoundaryFluxes(j) = BoundaryFluxes(j) / BoundaryAreas(j)
            END IF
            WRITE (Name,'(A,A,A,A,I2)') TRIM(Oper),': ',TRIM(VariableName),' over bc',j
            CALL AddToSaveList( TRIM(Name), BoundaryFluxes(j))
          END IF
        END DO
        
        IF(TRIM(Oper) == 'diffusive flux' .OR. TRIM(Oper) == 'convective flux') THEN
          IF( ANY (BoundaryHits > 0) ) THEN
            WRITE (Name,'(A,A,A,A)') 'min ',TRIM(Oper),': ',TRIM(VariableName)
            CALL AddToSaveList( TRIM(Name), Minimum)
            
            WRITE (Name,'(A,A,A,A)') 'max ',TRIM(Oper),': ',TRIM(VariableName)
            CALL AddToSaveList( TRIM(Name), Maximum)
          END IF
        END IF
        
        IF(NoLines > 0) THEN
          BoundaryHits = 0
          BoundaryFluxes = 0.0_dp
          BoundaryAreas = 0.0_dp
          
          CALL PolylineIntegrals(Var, Oper, GotCoeff, CoefficientName,&
              BoundaryFluxes,BoundaryAreas, BoundaryHits)
          
          DO j=1,NoLines
            IF(BoundaryHits(j) > 0 .OR. Parallel) THEN
              IF( TRIM(Oper) == 'boundary int mean' ) THEN
                BoundaryFluxes(j) = BoundaryFluxes(j) / BoundaryAreas(j)
              END IF
              WRITE (Name,'(A,A,A,A,I2)') TRIM(Oper),': ',TRIM(VariableName),' over polyline',j
              CALL AddToSaveList( TRIM(Name), BoundaryFluxes(j))
            END IF
          END DO
        END IF
        
      CASE DEFAULT 
        
        WRITE (Message,'(A,A)') 'Unknown operator: ',TRIM(Oper)
        CALL WARN('SaveScalars',Message)
        
      END SELECT
      
    END IF
  END DO


  
  !------------------------------------------------------------------------------
  ! Get the info at node points
  !------------------------------------------------------------------------------
  DO k=1,NoPoints+NoCoordinates
    
    IF(k <= NoPoints) THEN
      l = PointIndex(k)
    ELSE
      l = CoordinateIndex(k-NoPoints)
    END IF
    

    Var => Model % Variables

    DO WHILE( ASSOCIATED( Var ) )
      
      IF ( .NOT. Var % Output .OR. SIZE(Var % Values) == Var % DOFs ) THEN
        
        CONTINUE

      ELSE IF (ASSOCIATED (Var % EigenVectors)) THEN

        NoEigenValues = SIZE(Var % EigenValues) 
        EigenDofs = SIZE( Var % EigenVectors(1,:) ) / SIZE( Var % Perm )

        IF(EigenDofs == Var % DOFs) THEN
          DO j=1,NoEigenValues
            DO i=1,Var % DOFs              
              Ind = Var % Perm(l)              
              IF( Ind > 0 ) THEN
                IF(Var % DOFs == 1) THEN
                  WRITE(Name,'("value: Eigen",I2," ",A," at node ",I7)') j,TRIM(Var % Name),l
                ELSE
                  WRITE(Name,'("value: Eigen",I2," ",A,I2," at node ",I7)') j,TRIM(Var % Name),i,l
                END IF
                IF(ComplexEigen) THEN
                  Value = ABS( Var % EigenVectors(j, Var%Dofs*(Ind-1)+i) )
                ELSE
                  Value = REAL( Var % EigenVectors(j, Var%Dofs*(Ind-1)+i) )                  
                END IF
                CALL AddToSaveList( TRIM(Name), Value)
              END IF
            END DO
          END DO
        END IF

      ELSE IF( Var % Dofs == 1) THEN          
        ! The variables exist always also as scalars, therefore omit vectors. 

        Ind = l
        IF(ASSOCIATED(Var % Perm)) Ind = Var % Perm(l)

        IF(Ind > 0) THEN
          WRITE(Name,'("value: ",A," at node ",I7)') TRIM( Var % Name ), l
          CALL AddToSaveList( TRIM(Name), Var % Values(Ind))        
        END IF

      END IF

      Var => Var % Next      
    END DO
  END DO

  
  !------------------------------------------------------------------------------
  ! Get the info at exact coordinates within elements
  !------------------------------------------------------------------------------
  DO k=1,NoElements        
    l = CoordinatesElemNo(k)
    CurrentElement => Mesh % Elements(l)
    n = CurrentElement % TYPE % NumberOfNodes
    NodeIndexes => CurrentElement % NodeIndexes
    
    Var => Model % Variables
    DO WHILE( ASSOCIATED( Var ) )

      IF ( .NOT. Var % Output .OR. SIZE(Var % Values) == Var % DOFs) THEN
        CONTINUE 
      
      ELSE IF (ASSOCIATED (Var % EigenVectors)) THEN
        NoEigenValues = SIZE(Var % EigenValues) 
        EigenDofs = SIZE( Var % EigenVectors(1,:) ) / SIZE( Var % Perm )

        IF(EigenDofs == Var % DOFs) THEN
          DO j=1,NoEigenValues
            DO i=1,Var % DOFs
              IF( ALL(Var % Perm(NodeIndexes(1:n)) > 0)) THEN
                IF(ComplexEigen) THEN
                  ElementValues(1:n) = ABS( Var % EigenVectors(j,Var%Dofs*(Var % Perm(NodeIndexes(1:n))-1)+i) )
                ELSE
                  ElementValues(1:n) = REAL( Var % EigenVectors(j,Var%Dofs*(Var % Perm(NodeIndexes(1:n))-1)+i) )
                END IF
                Value = SUM( CoordinatesBasis(k,1:n) * ElementValues(1:n) )             
                IF(Var % DOFs == 1) THEN
                  WRITE(Name,'("value: Eigen",I2," ",A," in element ",I7)') j,TRIM(Var % Name),l
                ELSE
                  WRITE(Name,'("value: Eigen",I2," ",A,I2," in element ",I7)') j,TRIM(Var % Name),i,l
                END IF
                CALL AddToSaveList(TRIM(Name), Value)
              END IF
            END DO
          END DO
        END IF

      ELSE IF(Var % Dofs == 1) THEN          
        IF(ASSOCIATED(Var % Perm)) THEN
          IF( ALL(Var % Perm(NodeIndexes(1:n)) > 0)) THEN            
            ElementValues(1:n) = Var % Values(Var % Perm(NodeIndexes(1:n)))
            Value = SUM( CoordinatesBasis(k,1:n) * ElementValues(1:n) ) 
            WRITE(Name,'("value: ",A," in element ",I7)') TRIM(Var % Name),l
            CALL AddToSaveList(TRIM(Name), Value)                   
          END IF
        ELSE
          ElementValues(1:n) = Var % Values(NodeIndexes(1:n))
          Value = SUM( CoordinatesBasis(k,1:n) * ElementValues(1:n) ) 
          WRITE(Name,'("value: ",A," in element ",I7)') TRIM(Var % Name),l
          CALL AddToSaveList(TRIM(Name), Value)        
        END IF
      END IF

      Var => Var % Next      

    END DO
  END DO

  !------------------------------------------------------------------------------
  ! Finally save all the scalars into a file 
  !------------------------------------------------------------------------------
   LineInd = ListGetInteger( Solver % Values,'Line Marker',GotIt)

   IF(NoValues /= PrevNoValues) THEN 
    IF(SubroutineVisited) THEN
      WRITE ( Message,'(A,I2,I2)') 'Number of scalar values differ from previous time:',&
          NoValues,PrevNoValues
      CALL Warn('SaveScalars',Message)
    END IF

    OPEN (10, FILE=ScalarNamesFile)
    Message = ListGetString(Model % Simulation,'Comment',GotIt)
    IF( GotIt ) THEN
      WRITE(10,'(A)') TRIM(Message)
    END IF
    Message = ListGetString(Solver % Values,'Comment',GotIt)
    IF( GotIt ) THEN
      WRITE(10,'(A)') TRIM(Message)
    END IF
    DateStr = FormatDate()
    WRITE( 10,'(A,A)') 'File started at: ',TRIM(DateStr)
    WRITE(10,*) 'Variables in columns of matrix: '//TRIM(ScalarsFile)
    IF( LineInd /= 0 ) THEN
      i = 1
      WRITE(10,'(I4,": ",A)') 1,'Line Marker'
    ELSE
      i = 0
    END IF 	
    DO No=1,NoValues 
      WRITE(10,'(I4,": ",A)') No+i,TRIM(ValueNames(No))
    END DO
    CLOSE(10)
  END IF

  !------------------------------------------------------------------------------
  ! In parallel case save the data in different files
  !------------------------------------------------------------------------------
  IF ( Parallel ) THEN
    DO i=1,MAX_NAME_LEN
      IF ( ScalarsFile(i:i) == ' ' ) EXIT
      ScalarParFile(i:i) = ScalarsFile(i:i)
    END DO
    ScalarParFile(i:i) = '.'

    IF ( ParSolver % Matrix % ParMatrix % ParEnv % MyPE < 10 ) THEN
      WRITE( ScalarParFile(i+1:), '(i1)' ) &
          ParSolver % Matrix % ParMatrix % ParEnv % MyPE
    ELSE IF ( ParSolver % Matrix % ParMatrix % ParEnv % MyPE < 100 ) THEN
      WRITE( ScalarParFile(i+1:), '(i2)' ) &
          ParSolver % Matrix % ParMatrix % ParEnv % MyPE
    ELSE
      WRITE( ScalarParFile(i+1:), '(i3)' ) &
          ParSolver % Matrix % ParMatrix % ParEnv % MyPE
    END IF

    IF(SubroutineVisited .OR. FileAppend) THEN 
      OPEN (10, FILE=ScalarParFile,POSITION='APPEND')
    ELSE 
      OPEN (10,FILE=ScalarParFile)
    END IF
  ELSE
    IF(SubroutineVisited .OR. FileAppend) THEN 
      OPEN (10, FILE=ScalarsFile,POSITION='APPEND')
    ELSE 
      OPEN (10,FILE=ScalarsFile)
    END IF
  END IF

  IF(NoValues > 0) THEN
    ! If there are multiple lines it may be a good idea to mark each by an index
    IF( LineInd /= 0) THEN
      WRITE (10,'(I6)',advance='no') LineInd
    END IF
    DO No=1,NoValues-1
      IF( ValuesInteger(No) ) THEN
        WRITE (10,'(I10)',advance='no') NINT(Values(No))
      ELSE
        WRITE (10,'(ES22.12E3)',advance='no') Values(No)
      END IF
    END DO
      IF( ValuesInteger(NoValues) ) THEN
        WRITE (10,'(I10)') NINT(Values(NoValues))
      ELSE
        WRITE (10,'(ES22.12E3)') Values(NoValues)
      END IF
  END IF
  CLOSE(10)

  !------------------------------------------------------------------------------
  ! Save comments by line in a metadata file
  !------------------------------------------------------------------------------
  IF( .NOT. SubroutineVisited .AND. FileAppend .AND. LineInd /= 0 ) THEN
    Message = ListGetString(Solver % Values,'Comment',GotIt)
    Name = TRIM(ScalarsFile) // '.' // TRIM("marker")
    IF( GotIt ) THEN
      OPEN (10, FILE=Name,POSITION='APPEND')
      WRITE(10,'(I6,A,A)') LineInd,': ',TRIM(Message)
    END IF 
  END IF



  !------------------------------------------------------------------------------
  ! Save data in livegraph format
  !------------------------------------------------------------------------------

  IF(LiveGraph) THEN
  ! Save data as comma-separated-values (cvs-file)
    IF(SubroutineVisited .OR. FileAppend) THEN 
      OPEN (10, FILE=TRIM(ScalarsFile)//'.csv',POSITION='APPEND')      
    ELSE 
      OPEN (10, FILE=TRIM(ScalarsFile)//'.csv')
      DO No=1,NoValues-1
        WRITE (10,'(A)',advance='no') TRIM(ValueNames(No))//","
      END DO
      WRITE (10,'(A)') TRIM(ValueNames(NoValues))
    END IF

    DO No=1,NoValues-1
      WRITE (10,'(ES22.12E3,A)',advance='no') Values(No),","
    END DO
    WRITE (10,'(ES22.12E3)') Values(NoValues)
    CLOSE(10)
  END IF

  !------------------------------------------------------------------------------
  ! Add data to the Simulation block for possible future use
  !------------------------------------------------------------------------------
  DO No=1,NoValues
    CALL ListAddConstReal(Model % Simulation,TRIM(ValueNames(No)),Values(No))
  END DO

  !------------------------------------------------------------------------------
  ! For consistancy checks one may print out a value: here its the 1st value
  !------------------------------------------------------------------------------




  IF( CheckNorm ) THEN
    NormInd = ListGetInteger( Solver % Values,'Show Norm Index',GotIt)
    IF(NormInd < 1 .OR. NormInd > NoValues ) NormInd = 1
    PrevNorm = Norm
    Norm = Values( NormInd )
    IF( ABS( Norm ) + ABS( PrevNorm ) > 0.0_dp ) THEN
      Change = 2.0*(ABS(Norm-PrevNorm))/(ABS(Norm)+ABS(PrevNorm))
    ELSE
      Change = 0.0_dp
    END IF

    Name = ListGetString( Solver % Values, 'Equation',GotIt)
    IF(.NOT. GotIt) Name = Solver % Variable % Name

    ! Here the name is ComputeChange in order to get the change also to ElmerGUI
    WRITE( Message, '(a,g15.8,g15.8,a)') &
       'SS (ITER='//TRIM(i2s(n))//') (NRM,RELC): (',Norm, Change,&
          ' ) :: '//TRIM( Name )
      CALL Info( 'ComputeChange', Message, Level=3 )

!    WRITE( Message, '(a,g15.8)') 'Check NRM= ',Values(1)
!    CALL Info( 'SaveScalars', Message, Level=3 )
  END IF


  PrevNoValues = NoValues
  SubroutineVisited = .TRUE.


!------------------------------------------------------------------------------


CONTAINS


    SUBROUTINE AddToSaveList(Name, Value, ValueIsInteger )

    INTEGER :: n
    CHARACTER(LEN=*) :: Name
    REAL(KIND=dp) :: Value
    LOGICAL, OPTIONAL :: ValueIsInteger
    REAL, ALLOCATABLE :: TmpValues(:)
    CHARACTER(LEN=MAX_NAME_LEN), ALLOCATABLE :: TmpValueNames(:)
    LOGICAL, POINTER :: TmpValuesInteger(:)     

    SAVE TmpValues, TmpValueNames


    ! For the first time allocate some space
    IF(.NOT. ALLOCATED(Values)) THEN
      n = 20
      ALLOCATE( Values(n), ValueNames(n), ValuesInteger(n) )
    END IF

    n = NoValues

    ! If vectors are too small make some more room in a rather dummy way
    IF(n >= SIZE(Values) ) THEN
      ALLOCATE(TmpValues(n), TmpValueNames(n), TmpValuesInteger(n))
      TmpValues(1:n) = Values(1:n)
      TmpValuesInteger(1:n) = ValuesInteger(1:n)
      TmpValueNames(1:n) = ValueNames(1:n)
      DEALLOCATE(Values,ValueNames)

      ALLOCATE(Values(n+10), ValueNames(n+10))
      Values(1:n) = TmpValues(1:n)
      ValuesInteger(1:n) = TmpValuesInteger(1:n)
      ValueNames(1:n) = TmpValueNames(1:n)

      DEALLOCATE(TmpValues,TmpValueNames,TmpValuesInteger)
    END IF

    n = n + 1
    Values(n) = Value
    ValueNames(n) = TRIM(Name)
    IF( PRESENT( ValueIsInteger ) ) THEN
      ValuesInteger(n) = ValueIsInteger
    ELSE
      ValuesInteger(n) = .FALSE.
    END IF
    NoValues = n

  END SUBROUTINE AddToSaveList




  FUNCTION VectorStatistics(Var,OperName) RESULT (operx)

    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=MAX_NAME_LEN) :: OperName
    REAL(KIND=dp) :: operx
    REAL(KIND=dp) :: Minimum, Maximum, AbsMinimum, AbsMaximum, &
        Mean, Variance, sumx, sumxx, x, Variance2
    INTEGER :: Nonodes, i, j, k, l, NoDofs, sumi
    LOGICAL :: Initialized 

    Initialized = .FALSE.
    sumi = 0
    sumx = 0.0
    sumxx = 0.0

    NoDofs = Var % Dofs
    IF(ASSOCIATED (Var % Perm)) THEN
      Nonodes = SIZE(Var % Perm) 
    ELSE
      Nonodes = SIZE(Var % Values) / NoDofs
    END IF

    DO i=1,Nonodes
      j = i
      IF(ASSOCIATED(Var % Perm)) j = Var % Perm(i)
      IF(j > 0) THEN
        IF(NoDofs <= 1) THEN
          x = Var % Values(j)
        ELSE
          x = 0.0d0
          DO l=1,NoDofs
            x = x + Var % Values(NoDofs*(j-1)+l) ** 2
          END DO
          x = SQRT(x)
        END IF
        IF(.NOT. Initialized) THEN
          Initialized = .TRUE.
          Maximum = x
          Minimum = x
          AbsMaximum = x
          AbsMinimum = x
        END IF
        sumi = sumi + 1
        sumx = sumx + x
        sumxx = sumxx + x*x
        Maximum = MAX(x,Maximum)
        Minimum = MIN(x,Minimum)
        IF(ABS(x) > ABS(AbsMaximum) ) AbsMaximum = x
        IF(ABS(x) < ABS(AbsMinimum) ) AbsMinimum = x
      END IF
    END DO

    ! If there are no dofs avoid division by zero
    IF(sumi == 0) THEN
      operx = 0.0d0
      RETURN
    END IF

    Mean = sumx / sumi

    Variance2 = sumxx/sumi-Mean*Mean
    IF(Variance2 > 0.0d0) THEN
      Variance = SQRT(Variance2) 
    ELSE
      Variance = 0.0d0
    END IF

    SELECT CASE(OperName)
      
    CASE ('sum')
      operx = sumx
      
    CASE ('max')
      operx = Maximum
      
    CASE ('min')
      operx = Minimum
      
    CASE ('max abs')
      operx = AbsMaximum
      
    CASE ('min abs')
      operx = AbsMinimum
      
    CASE ('mean')
      operx = Mean
      
    CASE ('variance')
      operx = Variance
      
    CASE DEFAULT 
      CALL Warn('SaveScalars','Unknown statistical operator')

    END SELECT
      

  END FUNCTION VectorStatistics

!------------------------------------------------------------------------------

  FUNCTION VectorMeanDeviation(Var,OperName) RESULT (Deviation)

    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=MAX_NAME_LEN) :: OperName
    REAL(KIND=dp) :: Mean, Deviation
    REAL(KIND=dp) :: sumx, sumdx, x, dx
    INTEGER :: Nonodes, i, j, k, NoDofs, sumi

    NoDofs = Var % Dofs
    NoDofs = Var % Dofs
    IF(ASSOCIATED (Var % Perm)) THEN
      Nonodes = SIZE(Var % Perm) 
    ELSE
      Nonodes = SIZE(Var % Values) / NoDofs
    END IF

    sumi = 0
    sumx = 0.0
    Deviation = 0.0

    DO i=1,Nonodes
      j = i
      IF(ASSOCIATED(Var % Perm)) j = Var % Perm(i)
      IF(j > 0) THEN
        IF(NoDofs <= 1) THEN
          x = Var % Values(j)
        ELSE
          x = 0.0d0
          DO k=1,NoDofs
            x = x + Var % Values(NoDofs*(j-1)+k) ** 2
          END DO
          x = SQRT(x)
        END IF
        sumi = sumi + 1
        sumx = sumx + x
      END IF
    END DO

    IF(sumi == 0) RETURN

    Mean = sumx / sumi
    sumi = 0
    sumdx = 0.0
    DO i=1,Nonodes
      j = i
      IF(ASSOCIATED(Var % Perm)) j = Var % Perm(i)
      IF(j > 0) THEN
        IF(NoDofs <= 1) THEN
          x = Var % Values(j)
        ELSE
          x = 0.0d0
          DO k=1,NoDofs
            x = x + Var % Values(NoDofs*(j-1)+k) ** 2
          END DO
          x = SQRT(x)
        END IF
        dx = ABS(x-Mean)
        sumi = sumi + 1
        sumdx = sumdx + dx
      END IF
    END DO
    Deviation = sumdx / sumi

  END FUNCTION VectorMeanDeviation

!------------------------------------------------------------------------------

  FUNCTION BulkIntegrals(Var, OperName, GotCoeff, CoeffName) RESULT (operx)
    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=MAX_NAME_LEN) :: OperName, CoeffName
    LOGICAL :: GotCoeff
    REAL(KIND=dp) :: operx, vol
    
    INTEGER :: t, hits
    TYPE(Element_t), POINTER :: Element
 
    REAL(KIND=dp) :: SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3)
    REAL(KIND=dp) :: Basis(Model % MaxElementNodes), dBasisdx(Model % MaxElementNodes,3)
    REAL(KIND=dp) :: EnergyTensor(3,3,Model % MaxElementNodes),&
        EnergyCoeff(Model % MaxElementNodes) 
    REAL(KIND=dp) :: SqrtElementMetric,U,V,W,S,A,L,C(3,3),x,y,z
    REAL(KIND=dp) :: func, coeff, integral1, integral2, Grad(3), CoeffGrad(3)
    REAL(KIND=DP), POINTER :: Pwrk(:,:,:)
    LOGICAL :: Stat
    
    INTEGER :: i,j,k,p,q,DIM,NoDofs
    
    TYPE(GaussIntegrationPoints_t) :: IntegStuff

    hits = 0
    integral1 = 0._dp
    integral2 = 0._dp
    vol = 0._dp
    EnergyCoeff = 1.0d0

    NoDofs = Var % Dofs

    DIM = CoordinateSystemDimension()


    DO t = 1, Mesh % NumberOfBulkElements + Mesh % NumberOfBoundaryElements

      IF(t == Mesh % NumberOfBulkElements + 1 .AND. hits > 0) GOTO 10

      Element => Mesh % Elements(t)
      Model % CurrentElement => Mesh % Elements(t)
      n = Element % TYPE % NumberOfNodes
      NodeIndexes => Element % NodeIndexes
      
      IF ( Element % TYPE % ElementCode == 101 ) CYCLE
      IF ( ANY(Var % Perm(NodeIndexes(1:n)) == 0) ) CYCLE
      
      hits = hits + 1
      
      ElementNodes % x(1:n) = Mesh % Nodes % x(NodeIndexes(1:n))
      ElementNodes % y(1:n) = Mesh % Nodes % y(NodeIndexes(1:n))
      ElementNodes % z(1:n) = Mesh % Nodes % z(NodeIndexes(1:n))


      SELECT CASE(OperName)

        CASE('diffusive energy') 
        k = ListGetInteger( Model % Bodies( Element % BodyId ) % Values, &
            'Material', GotIt, minv=1, maxv=Model % NumberOfMaterials )

        EnergyTensor = 0.0d0
        IF(GotCoeff) THEN
          CALL ListGetRealArray( Model % Materials(k) % Values, &
              TRIM(CoeffName), Pwrk, n, NodeIndexes )

          IF ( SIZE(Pwrk,1) == 1 ) THEN
            DO i=1,3
              EnergyTensor( i,i,1:n ) = Pwrk( 1,1,1:n )
            END DO
          ELSE IF ( SIZE(Pwrk,2) == 1 ) THEN
            DO i=1,MIN(3,SIZE(Pwrk,1))
              EnergyTensor(i,i,1:n) = Pwrk(i,1,1:n)
            END DO
          ELSE
            DO i=1,MIN(3,SIZE(Pwrk,1))
              DO j=1,MIN(3,SIZE(Pwrk,2))
                EnergyTensor( i,j,1:n ) = Pwrk(i,j,1:n)
              END DO
            END DO
          END IF
        ELSE 
          DO i=1,3          
            EnergyTensor(i,i,1:n) = 1.0d0
          END DO
        END IF

        CASE ('potential energy','convective energy','volume')
        k = ListGetInteger( Model % Bodies( Element % BodyId ) % Values, &
            'Material', GotIt, minv=1, maxv=Model % NumberOfMaterials )

        IF(GotCoeff) THEN
          EnergyCoeff = ListGetReal( Model % Materials(k) % Values, &
              TRIM(CoeffName), n, NodeIndexes(1:n) )
        ELSE
          EnergyCoeff(1:n) = 1.0d0
        END IF

      END SELECT

!------------------------------------------------------------------------------
!    Numerical integration
!------------------------------------------------------------------------------
      IntegStuff = GaussPoints( Element )
      
      DO i=1,IntegStuff % n
        U = IntegStuff % u(i)
        V = IntegStuff % v(i)
        W = IntegStuff % w(i)
!------------------------------------------------------------------------------
!        Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
        stat = ElementInfo( Element,ElementNodes,U,V,W,SqrtElementMetric, &
            Basis,dBasisdx )
!------------------------------------------------------------------------------
!      Coordinatesystem dependent info
!------------------------------------------------------------------------------
        s = 1.0
        IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
          x = SUM( ElementNodes % x(1:n)*Basis(1:n) )
          y = SUM( ElementNodes % y(1:n)*Basis(1:n) )
          z = SUM( ElementNodes % z(1:n)*Basis(1:n) )
          s = 2*PI
        END IF
        
        CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,x,y,z )
        
        s = s * SqrtMetric * SqrtElementMetric * IntegStuff % s(i)
        vol =  vol + S

        SELECT CASE(OperName)
          
          CASE ('volume')
          coeff = SUM( EnergyCoeff(1:n) * Basis(1:n))
          integral1 = integral1 + coeff * S

          CASE ('int','int mean')
          func = SUM( Var % Values(Var % Perm(NodeIndexes(1:n))) * Basis(1:n) )
          integral1 = integral1 + S * func 

          CASE ('int variance')
          func = SUM( Var % Values(Var % Perm(NodeIndexes(1:n))) * Basis(1:n) )
          integral1 = integral1 + S * func 
          integral2 = integral2 + S * func**2 

          CASE ('diffusive energy')
          CoeffGrad = 0.0d0
          DO j = 1, DIM
            Grad(j) = SUM( dBasisdx(1:n,j) *  Var % Values(Var % Perm(NodeIndexes(1:n))) )
            DO k = 1, DIM
              CoeffGrad(j) = CoeffGrad(j) + SUM( EnergyTensor(j,k,1:n) * Basis(1:n) ) * &
                  SUM( dBasisdx(1:n,k) * Var % Values(Var % Perm(NodeIndexes(1:n))) )
            END DO
          END DO
          
          integral1 = integral1 + s * SUM( Grad(1:DIM) * CoeffGrad(1:DIM) )

          CASE ('convective energy')
          func = SUM( Var % Values(Var % Perm(NodeIndexes(1:n))) * Basis(1:n) )
          coeff = SUM( EnergyCoeff(1:n) * Basis(1:n))

          IF(NoDofs == 1) THEN
            func = SUM( Var % Values(Var % Perm(NodeIndexes(1:n))) * Basis(1:n) )
            integral1 = integral1 + s * coeff * func**2
          ELSE
            func = 0.0d0
            DO j=1,MIN(DIM,NoDofs)
              func = SUM( Var % Values(NoDofs*(Var % Perm(NodeIndexes(1:n))-1)+j) * Basis(1:n) )
              integral1 = integral1 + s * coeff * func**2
            END DO
          END IF

          CASE ('potential energy')

          func = SUM( Var % Values(Var % Perm(NodeIndexes(1:n))) * Basis(1:n) )
          coeff = SUM( EnergyCoeff(1:n) * Basis(1:n))
          integral1 = integral1 + s * coeff * func

        CASE DEFAULT 
          CALL Warn('SaveScalars','Unknown statistical operator')

        END SELECT

      END DO

    END DO


10  CONTINUE 
    
    operx = 0.0d0
    IF(hits == 0) RETURN

    SELECT CASE(OperName)
      
      CASE ('volume')
      operx = integral1

      CASE ('int')
      operx = integral1
      
      CASE ('int mean')
      operx = integral1 / vol        

      CASE ('int variance')
      operx = SQRT(integral2/vol-(integral1/vol)**2)

      CASE ('diffusive energy')
      operx = 0.5d0 * integral1

      CASE ('convective energy')
      operx = 0.5d0 * integral1

      CASE ('potential energy')
      operx = integral1
      
    END SELECT


  END FUNCTION BulkIntegrals
!------------------------------------------------------------------------------


  SUBROUTINE BoundaryIntegrals(Var, OperName, GotCoeff, &
      CoeffName, fluxes, areas, fluxescomputed)

    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=MAX_NAME_LEN) :: OperName, CoeffName
    LOGICAL :: GotCoeff
    REAL(KIND=dp) :: fluxes(:), areas(:)
    INTEGER :: fluxescomputed(:)
    
    INTEGER :: t, FluxBody, LBody, RBody
    TYPE(Element_t), POINTER :: Element, Parent    
    TYPE(ValueList_t), POINTER :: Material
    REAL(KIND=dp) :: SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3)
    REAL(KIND=dp) :: Basis(Model % MaxElementNodes),dBasisdx(Model % MaxElementNodes,3),&
        ParentBasis(Model % MaxElementNodes),&
        ParentdBasisdx(Model % MaxElementNodes,3),EnergyTensor(3,3,Model % MaxElementNodes),&
        EnergyCoeff(Model % MaxElementNodes)
    REAL(KIND=dp) :: SqrtElementMetric,U,V,W,up,vp,wp,S,A,L,C(3,3),x,y,z
    REAL(KIND=dp) :: func, coeff, Normal(3), Flow(3), flux
    REAL(KIND=DP), POINTER :: Pwrk(:,:,:)
    INTEGER, POINTER :: ParentIndexes(:), PermIndexes(:)

    LOGICAL :: Stat, Permutated    
    INTEGER :: i,j,k,p,q,DIM,bc,NoDofs,pn,hits
    TYPE(GaussIntegrationPoints_t) :: IntegStuff
    TYPE(Nodes_t) :: ParentNodes

    n = Model % MaxElementNodes

    DIM = CoordinateSystemDimension()

    ALLOCATE(ParentNodes % x(n), ParentNodes % y(n), ParentNodes % z(n), PermIndexes(n) )

    Minimum = HUGE(minimum)
    Maximum = -HUGE(maximum)

    NoDofs = Var % Dofs
    Permutated = ASSOCIATED(Var % Perm)
    DO i=1,3          
      EnergyTensor(i,i,:) = 1.0d0
    END DO

    SELECT CASE(OperName)
      
      CASE('diffusive flux') 
      IF(NoDofs /= 1) THEN
        CALL Warn('SaveScalars','diffusive flux & NoDofs /= 1?')
        RETURN
      END IF

      CASE ('convective flux')
      IF(NoDofs /= 1 .AND. NoDofs < DIM) THEN
        CALL Warn('SaveScalars','convective flux & NoDofs < DIM?')
        RETURN
      END IF
      
      CASE ('area','boundary int','boundary int mean')

    CASE DEFAULT 
      CALL Warn('SaveScalars','Unknown statistical operator')

    END SELECT

    fluxes = 0.0_dp
    areas = 0.0_dp
    coeff = 1.0_dp


    DO t = Mesh % NumberOfBulkElements+1, Mesh % NumberOfBulkElements &
        + Mesh % NumberOfBoundaryElements

      Element => Mesh % Elements(t)
      Model % CurrentElement => Mesh % Elements(t)

      IF ( Element % TYPE % ElementCode == 101 ) CYCLE

      n = Element % TYPE % NumberOfNodes
      NodeIndexes => Element % NodeIndexes

      IF(Permutated) THEN
        PermIndexes(1:n) = Var % Perm(NodeIndexes(1:n))
        IF (ANY( PermIndexes(1:n) == 0)) CYCLE
      ELSE
        PermIndexes(1:n) = NodeIndexes(1:n)        
      END IF


      DO bc=1, Model % NumberOfBCs

        IF ( Model % BCs(bc) % Tag /= Element % BoundaryInfo % Constraint ) CYCLE

        IF(.NOT. ListGetLogical(Model % BCs(bc) % Values,'Flux Integrate',gotIt ) .AND. &
            .NOT. ListGetLogical(Model % BCs(bc) % Values,'Save Scalars',gotIt ) ) CYCLE
                 
        ElementNodes % x(1:n) = Mesh % Nodes % x(NodeIndexes(1:n))
        ElementNodes % y(1:n) = Mesh % Nodes % y(NodeIndexes(1:n))
        ElementNodes % z(1:n) = Mesh % Nodes % z(NodeIndexes(1:n))



        SELECT CASE(OperName)
          
        CASE('diffusive flux') 
          
          FluxBody = ListGetInteger( Model % BCs(bc) % Values, &
              'Flux Integrate Body', gotIt ) 
          IF ( GotIt ) THEN
            IF ( ASSOCIATED( Element  % BoundaryInfo % Left ) ) &
                Lbody = Element % BoundaryInfo % Left % BodyId
            IF ( ASSOCIATED( Element  % BoundaryInfo % Right ) ) &
                Rbody = Element % BoundaryInfo % Right % BodyId
            
            IF ( Lbody == FluxBody ) THEN
              Parent => Element % BoundaryInfo % Left
            ELSEIF ( Rbody == FluxBody ) THEN
              Parent => Element % BoundaryInfo % Right
            ELSE
              WRITE( Message, * ) 'No such flux integrate body on bc ', &
                  Element % BoundaryInfo % Constraint
              CALL Fatal( 'SaveScalars', Message )
            END IF
          ELSE        
            Parent => ELement % BoundaryInfo % Left
            stat = ASSOCIATED( Parent )
            
            IF(Permutated) THEN
              IF(stat) stat = ALL(Var % Perm(Parent % NodeIndexes) > 0)
              
              IF ( .NOT. stat ) THEN
                Parent => ELement % BoundaryInfo % Right              
                stat = ASSOCIATED( Parent )
                IF(stat) stat = ALL(Var % Perm(Parent % NodeIndexes) > 0)
              END IF
            END IF
            IF ( .NOT. stat )  CALL Fatal( 'SaveScalars',&
                'No solution available for specified boundary' )
          END IF                   
          
          pn = Parent % TYPE % NumberOfNodes
          ParentIndexes => Parent % NodeIndexes
          i = ListGetInteger( Model % Bodies(Parent % BodyId) % Values, 'Material', &
              minv=1, maxv=Model % NumberOFMaterials )
          Material => Model % Materials(i) % Values

          ParentNodes % x(1:pn) = Mesh % Nodes % x(ParentIndexes(1:pn))
          ParentNodes % y(1:pn) = Mesh % Nodes % y(ParentIndexes(1:pn))
          ParentNodes % z(1:pn) = Mesh % Nodes % z(ParentIndexes(1:pn))

          EnergyTensor = 0._dp

          IF(GotCoeff) THEN
            CALL ListGetRealArray( Material, CoeffName, Pwrk, pn, ParentIndexes )

            IF ( SIZE(Pwrk,1) == 1 ) THEN
              DO i=1,3
                EnergyTensor( i,i,1:pn ) = Pwrk( 1,1,1:pn )
              END DO
            ELSE IF ( SIZE(Pwrk,2) == 1 ) THEN
              DO i=1,MIN(3,SIZE(Pwrk,1))
                EnergyTensor(i,i,1:pn) = Pwrk(i,1,1:pn)
              END DO
            ELSE
              DO i=1,MIN(3,SIZE(Pwrk,1))
                DO j=1,MIN(3,SIZE(Pwrk,2))
                  EnergyTensor( i,j,1:pn ) = Pwrk(i,j,1:pn)
                END DO
              END DO
            END IF
          ELSE
            DO i=1,3          
              EnergyTensor(i,i,1:pn) = 1.0d0
            END DO
          END IF
          EnergyCoeff(1:n) = 1.0D00
          fluxescomputed(bc) = fluxescomputed(bc) + 1


        CASE ('convective flux')

          FluxBody = ListGetInteger( Model % BCs(bc) % Values, &
              'Flux Integrate Body', gotIt ) 
          IF ( GotIt ) THEN
            IF ( ASSOCIATED( Element  % BoundaryInfo % Left ) ) &
                Lbody = Element % BoundaryInfo % Left % BodyId
            IF ( ASSOCIATED( Element  % BoundaryInfo % Right ) ) &
                Rbody = Element % BoundaryInfo % Right % BodyId
            
            IF ( Lbody == FluxBody ) THEN
              Parent => Element % BoundaryInfo % Left
            ELSEIF ( Rbody == FluxBody ) THEN
              Parent => Element % BoundaryInfo % Right
            ELSE
              WRITE( Message, * ) 'No such flux integrate body on bc ', &
                  Element % BoundaryInfo % Constraint
              CALL Fatal( 'SaveScalars', Message )
            END IF
          ELSE        
            Parent => ELement % BoundaryInfo % Left
            stat = ASSOCIATED( Parent )
            
            IF(Permutated) THEN
              IF(stat) stat = ALL(Var % Perm(Parent % NodeIndexes) > 0)
              
              IF ( .NOT. stat ) THEN
                Parent => ELement % BoundaryInfo % Right              
                stat = ASSOCIATED( Parent )
                IF(stat) stat = ALL(Var % Perm(Parent % NodeIndexes) > 0)
              END IF
            END IF
            IF ( .NOT. stat )  CALL Fatal( 'SaveScalars',&
                'No solution available for specified boundary' )
          END IF                   
          
          pn = Parent % TYPE % NumberOfNodes
          ParentIndexes => Parent % NodeIndexes
          i = ListGetInteger( Model % Bodies(Parent % BodyId) % Values, 'Material', &
              minv=1, maxv=Model % NumberOFMaterials )
          Material => Model % Materials(i) % Values

          ParentNodes % x(1:pn) = Mesh % Nodes % x(ParentIndexes(1:pn))
          ParentNodes % y(1:pn) = Mesh % Nodes % y(ParentIndexes(1:pn))
          ParentNodes % z(1:pn) = Mesh % Nodes % z(ParentIndexes(1:pn))

          IF(GotCoeff) THEN
            EnergyCoeff(1:n) = ListGetReal( Material, CoeffName, n, NodeIndexes )
          ELSE
            EnergyCoeff(1:n) = 1.0d0
          END IF          
          fluxescomputed(bc) = fluxescomputed(bc) + 1

        CASE ('area','boundary int','boundary int mean')
           IF(GotCoeff) THEN
             i = ListGetInteger( Model % Bodies(Element % BodyId) % Values, 'Material', &
                 minv=1, maxv=Model % NumberOFMaterials )
             Material => Model % Materials(i) % Values
             EnergyCoeff(1:n) = ListGetReal( Material, CoeffName, n, NodeIndexes )
          ELSE
            EnergyCoeff(1:n) = 1.0d0
          END IF
          fluxescomputed(bc) = fluxescomputed(bc) + 1


        END SELECT

!------------------------------------------------------------------------------
!    Numerical integration
!------------------------------------------------------------------------------
        IntegStuff = GaussPoints( Element )
        
        DO i=1,IntegStuff % n
          U = IntegStuff % u(i)
          V = IntegStuff % v(i)
          W = IntegStuff % w(i)
!------------------------------------------------------------------------------
!        Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
          stat = ElementInfo( Element,ElementNodes,U,V,W,SqrtElementMetric, &
              Basis,dBasisdx )
!------------------------------------------------------------------------------
!      Coordinatesystem dependent info
!------------------------------------------------------------------------------
          x = SUM( ElementNodes % x(1:n)*Basis(1:n) )
          y = SUM( ElementNodes % y(1:n)*Basis(1:n) )
          z = SUM( ElementNodes % z(1:n)*Basis(1:n) )

          s = 1.0d0

          IF(.FALSE.) THEN
            IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
              s = 2.0d0 * PI 
            END IF
            CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,x,y,z )
            s = s * SqrtMetric * SqrtElementMetric * IntegStuff % s(i)
          ELSE
            IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
              s = 2.0d0 * PI * x 
            END IF
            s = s * SqrtElementMetric * IntegStuff % s(i)
          END IF
          
          Normal = NormalVector( Element,ElementNodes,U,V,.TRUE. )

          
          SELECT CASE(OperName)
            
          CASE ('diffusive flux')
            
            CALL GetParentUVW( Element, n, Parent, pn, Up, Vp, Wp, Basis)
            
            stat = ElementInfo( Parent,ParentNodes,Up,Vp,Wp,SqrtElementMetric, &
                ParentBasis,ParentdBasisdx )
            
            Flow = 0.0d0
            DO j = 1, DIM
              DO k = 1, DIM
                IF(Permutated) THEN
                  Flow(j) = Flow(j) + SUM( EnergyTensor(j,k,1:pn) * ParentBasis(1:pn) ) * &
                      SUM( ParentdBasisdx(1:pn,k) * Var % Values(Var % Perm(ParentIndexes(1:pn))) )
                ELSE
                  Flow(j) = Flow(j) + SUM( EnergyTensor(j,k,1:pn) * ParentBasis(1:pn) ) * &
                      SUM( ParentdBasisdx(1:pn,k) * Var % Values(ParentIndexes(1:pn)) ) 
                END IF
              END DO
            END DO
            
            flux = SUM(Normal(1:DIM) * Flow(1:DIM))
            Minimum = MIN(flux,Minimum)
            Maximum = MAX(flux,Maximum)
            
            fluxes(bc) = fluxes(bc) + s * flux
            
          CASE ('convective flux')
            
            coeff = SUM( EnergyCoeff(1:n) * Basis(1:n))
            
            IF(NoDofs == 1) THEN
              func = SUM( Var % Values(PermIndexes(1:n)) * Basis(1:n) )
              fluxes(bc) = fluxes(bc) + s * coeff * func
              Minimum = MIN(Minimum, coeff*func)
              Maximum = MAX(Maximum, coeff*func)
            ELSE 
              DO j=1,DIM
                Flow(j) = coeff * SUM( Var % Values(NoDofs*(PermIndexes(1:n)-1)+j) * Basis(1:n) )
              END DO
              fluxes(bc) = fluxes(bc) + s *  SUM(Normal * Flow)
              Minimum = MIN(Minimum,  SUM(Normal * Flow))
              Maximum = MAX(Maximum,  SUM(Normal * Flow))
            END IF
            
          CASE ('boundary int','boundary int mean')
            
            coeff = SUM( EnergyCoeff(1:n) * Basis(1:n))
            
            IF(NoDofs == 1) THEN
              func = SUM( Var % Values(PermIndexes(1:n)) * Basis(1:n) )
              flux = coeff * func 
              fluxes(bc) = fluxes(bc) + s * flux
            ELSE 
              flux = 0.0_dp
              DO j=1,NoDofs
                flux = flux + SUM( Var % Values(NoDofs*(PermIndexes(1:n)-1)+j) * Basis(1:n) )**2
              END DO
              flux = coeff * SQRT( flux )
              fluxes(bc) = fluxes(bc) + s *  flux
            END IF
     
          CASE ('area')
            coeff = SUM( EnergyCoeff(1:n) * Basis(1:n))
            fluxes(bc) = fluxes(bc) + s * coeff 
            
         END SELECT
          
         areas(bc) = areas(bc) + s * coeff

        END DO

      END DO

    END DO

    DEALLOCATE( ParentNodes % x, ParentNodes % y, ParentNodes % z, PermIndexes )

  END SUBROUTINE BoundaryIntegrals


!------------------------------------------------------------------------------
! Take nodal sum over given boundaries
!------------------------------------------------------------------------------

  SUBROUTINE BoundaryStatistics(Var, OperName, GotCoeff, &
      CoeffName, fluxes, fluxescomputed)

    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=MAX_NAME_LEN) :: OperName, CoeffName
    LOGICAL :: GotCoeff, FindMinMax
    REAL(KIND=dp) :: fluxes(:)
    INTEGER :: fluxescomputed(:)
    LOGICAL, ALLOCATABLE :: nodescomputed(:)    
    TYPE(Element_t), POINTER :: Element, Parent    
    TYPE(ValueList_t), POINTER :: Material
    INTEGER, POINTER :: PermIndexes(:)

    LOGICAL :: Stat, Permutated    
    INTEGER :: i,j,k,p,q,t,DIM,bc,n,hits


    ALLOCATE(NodesComputed(SIZE(Var % Perm)))
    NodesComputed = .FALSE.
    hits = 0

    NoDofs = Var % Dofs
    Permutated = ASSOCIATED(Var % Perm)
    FindMinMax = .FALSE.

    SELECT CASE(OperName)
      
    CASE('boundary sum','boundary dofs','boundary mean') 
      IF(NoDofs /= 1) THEN
        CALL Warn('SaveScalars','boundary sum & NoDofs /= 1?')
        RETURN
      END IF

    CASE('boundary min','boundary max','boundary min abs','boundary max abs') 
      IF(NoDofs /= 1) THEN
        CALL Warn('SaveScalars','boundary sum & NoDofs /= 1?')
        RETURN
      END IF
      FindMinMax = .TRUE.
      
    CASE DEFAULT 
      CALL Warn('SaveScalars','Unknown statistical operator')
      
    END SELECT

    fluxes = 0.0d0


    DO t = Mesh % NumberOfBulkElements+1, Mesh % NumberOfBulkElements &
        + Mesh % NumberOfBoundaryElements

      Element => Mesh % Elements(t)
      Model % CurrentElement => Mesh % Elements(t)

      n = Element % TYPE % NumberOfNodes
      NodeIndexes => Element % NodeIndexes

      DO bc=1, Model % NumberOfBCs

        IF ( Model % BCs(bc) % Tag /= Element % BoundaryInfo % Constraint ) CYCLE
        IF(.NOT. ListGetLogical(Model % BCs(bc) % Values,'Save Scalars',gotIt ) ) CYCLE

        hits = hits + 1
        
        DO i=1,n
          j = NodeIndexes(i)
          IF( Permutated ) j = Var % Perm(j)
          
          IF( j == 0) CYCLE            
          IF( nodescomputed(j) ) CYCLE

          IF(FindMinMax) THEN
            IF(fluxescomputed(bc) == 0) THEN
              fluxes(bc) = Var % Values(j)
            ELSE
              SELECT CASE(OperName)              
              CASE('boundary min')
                fluxes(bc) = MIN( Var % Values(j), fluxes(bc) )
              CASE('boundary max')
                fluxes(bc) = MAX( Var % Values(j), fluxes(bc) )
              CASE('boundary min abs')
                IF(ABS(fluxes(bc)) < ABS( Var % Values(j))) fluxes(bc) = Var % Values(j)
              CASE('boundary max abs')
                IF(ABS(fluxes(bc)) > ABS( Var % Values(j))) fluxes(bc) = Var % Values(j)
              END SELECT
            END IF
          ELSE
            fluxes(bc) = fluxes(bc) + Var % Values(j)
          END IF
          nodescomputed(j) = .TRUE.         
          fluxescomputed(bc) = fluxescomputed(bc) + 1          
        END DO        
      END DO
    END DO


    SELECT CASE(OperName)
      
    CASE('boundary sum')             
    CASE('boundary dofs') 
      fluxes = 1.0 * fluxescomputed
    CASE('boundary mean') 
      fluxes = fluxes / fluxescomputed            
      
    END SELECT

  END SUBROUTINE BoundaryStatistics
  

!------------------------------------------------------------------------------


  SUBROUTINE PolylineIntegrals(Var, OperName, GotCoeff, &
      CoeffName, fluxes, areas, fluxescomputed)

    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=MAX_NAME_LEN) :: OperName, CoeffName
    LOGICAL :: GotCoeff
    REAL(KIND=dp) :: fluxes(:),areas(:)
    INTEGER :: fluxescomputed(:)
    
    INTEGER :: t
    TYPE(Element_t), TARGET :: SideElement
    TYPE(Element_t), POINTER :: Element, Parent    
    TYPE(ValueList_t), POINTER :: Material
    REAL(KIND=dp) :: SqrtMetric,Metric(3,3),Symb(3,3,3),dSymb(3,3,3,3),LocalCoordinates(3),Point(3)
    REAL(KIND=dp) :: Basis(Model % MaxElementNodes),dBasisdx(Model % MaxElementNodes,3),&
        ParentBasis(Model % MaxElementNodes),&
        ParentdBasisdx(Model % MaxElementNodes,3),EnergyTensor(3,3,Model % MaxElementNodes),&
        EnergyCoeff(Model % MaxElementNodes) 
    REAL(KIND=dp) :: SqrtElementMetric,U,V,W,up,vp,wp,S,A,L,C(3,3),x,y,z,dx,dy,dz,ds,dsmax
    REAL(KIND=dp) :: func, coeff, Normal(3), Flow(3), x0, y0, z0, pos(2), flux
    REAL(KIND=DP), POINTER :: Pwrk(:,:,:)
    INTEGER, POINTER :: ParentIndexes(:), PermIndexes(:), SideIndexes(:), OnLine(:,:)

    LOGICAL :: Stat, Permutated, Inside    
    INTEGER :: i,j,k,p,q,DIM,bc,NoDofs,pn,Line, NoSides, Side, NodeNumber, LineNode(2)
    TYPE(GaussIntegrationPoints_t) :: IntegStuff
    TYPE(Nodes_t) :: ParentNodes, LineNodes, SideNodes


    n = Model % MaxElementNodes

    ALLOCATE(ParentNodes % x(n), ParentNodes % y(n), ParentNodes % z(n), PermIndexes(n) )
    ALLOCATE(SideNodes % x(n), SideNodes % y(n), SideNodes % z(n), SideIndexes(n)  )
    ALLOCATE(LineNodes % x(n), LineNodes % y(n), LineNodes % z(n)  )
    ALLOCATE(OnLine(Mesh % NumberOfNodes,2))


    CALL Info('PolylineIntegrals','Operator: '//TRIM(OperName))

    areas = 0.0_dp
    coeff = 1.0_dp   

    NoDofs = Var % Dofs
    Permutated = ASSOCIATED(Var % Perm)
    DO i=1,3          
      EnergyTensor(i,i,:) = 1.0d0
    END DO

    SELECT CASE(OperName)
      
      CASE('diffusive flux') 
      IF(NoDofs /= 1) THEN
        CALL Warn('SaveScalars','diffusive flux & NoDofs /= 1?')
        RETURN
      END IF

      CASE ('convective flux')
      IF(NoDofs /= 1 .AND. NoDofs < DIM) THEN
        CALL Warn('SaveScalars','convective flux & NoDofs < DIM?')
        RETURN
      END IF
      
      CASE ('area','boundary int','boundary int mean')

    CASE DEFAULT 
      CALL Warn('SaveScalars','Unknown physical operator')

    END SELECT

    DIM = CoordinateSystemDimension()
    IF(DIM < 3) THEN
      LineNodes % z = 0.0d0
      SideNodes % z(1:2) = 0.0d0
    END IF

    fluxes = 0.0d0
    SideElement % TYPE => GetElementType( 202, .FALSE.)
    SideElement % Bdofs = 0
    Element => SideElement

!   /* Go through the line segments */
    DO Line = 1,NoLines 

      LineNodes % x(1:2) = LineCoordinates(2*Line-1:2*Line,1) 
      LineNodes % y(1:2) = LineCoordinates(2*Line-1:2*Line,2) 
      IF(DIM == 3) LineNodes % z(1:2) = LineCoordinates(2*Line-1:2*Line,3) 
      OnLine = 0

      DO t = 1, Mesh % NumberOfBulkElements 
        
        Parent => Mesh % Elements(t)
        Model % CurrentElement => Mesh % Elements(t)

        NoSides = Parent % TYPE % ElementCode / 100  
        IF(NoSides < 3 .OR. NoSides > 4) CYCLE
        
        pn = Parent % TYPE % NumberOfNodes
        ParentIndexes => Parent % NodeIndexes

        ParentNodes % x(1:pn) = Mesh % Nodes % x(ParentIndexes(1:pn))
        ParentNodes % y(1:pn) = Mesh % Nodes % y(ParentIndexes(1:pn))
        ParentNodes % z(1:pn) = Mesh % Nodes % z(ParentIndexes(1:pn))          
        
        IF(Permutated) THEN
          PermIndexes(1:pn) = Var % Perm(ParentIndexes(1:pn))
          IF (ANY( PermIndexes(1:pn) == 0)) CYCLE
        ELSE
          PermIndexes(1:pn) = ParentIndexes(1:pn)        
        END IF

        NodeNumber = 0

        DO Side = 1, NoSides

          SideIndexes(1) = ParentIndexes(Side)
          SideIndexes(2) = ParentIndexes(MOD(Side,NoSides)+1)
          
          SideNodes % x(1:2) = Mesh % Nodes % x(SideIndexes(1:2))
          SideNodes % y(1:2) = Mesh % Nodes % y(SideIndexes(1:2))
          IF(DIM == 3) SideNodes % z(1:2) = Mesh % Nodes % z(SideIndexes(1:2))
  
          CALL LineIntersectionCoords(SideNodes,LineNodes,Inside,x0,y0,z0,u)

          IF(.NOT. Inside) CYCLE

          NodeNumber = NodeNumber + 1        
          ElementNodes % x(NodeNumber) = x0
          ElementNodes % y(NodeNumber) = y0
          ElementNodes % z(NodeNumber) = z0
          pos(NodeNumber) = u

        END DO

        IF(NodeNumber == 0) CYCLE

        IF(NodeNumber > 2) THEN
          CALL Warn('PolylineIntergrals','There should not be more than 2 intersections!')
          CYCLE
        END IF

        !---------------------------------------------------------------------------
        ! If there is only one intersection the other end of the node must lie
        ! inside the element. Assuming that the line is long compared to the 
        ! element the correct end of the line segment may be easily deduced.
        !---------------------------------------------------------------------------
        IF(NodeNumber == 1) THEN
          IF(pos(1) < 0.5d0) THEN
            i = 1
            pos(2) = 0.0
          ELSE
            i = 2
            pos(2) = 1.0
          END IF
          x0 = LineNodes % x(i)
          y0 = LineNodes % y(i)
          z0 = LineNodes % z(i)            

          ElementNodes % x(2) = LineNodes % x(i)
          ElementNodes % y(2) = LineNodes % y(i)
          ElementNodes % z(2) = LineNodes % z(i)            
        END IF

        IF(ABS(pos(1)-pos(2)) < 1.0d-8) CYCLE

        !-----------------------------------------------------------------------------
        ! Change the order of nodes so that the normal always points to the same direction          
        !-----------------------------------------------------------------------------
        IF(pos(1) < pos(2)) THEN
          ElementNodes % x(2) = ElementNodes % x(1)
          ElementNodes % y(2) = ElementNodes % y(1)
          ElementNodes % z(2) = ElementNodes % z(1)
          ElementNodes % x(1) = x0
          ElementNodes % y(1) = y0
          ElementNodes % z(1) = z0           
        END IF
        
        !--------------------------------------------------------------------------------
        ! The following avoids the cases where the line goes exactly at the element 
        ! interface and therefore the flux would be computed twice
        !--------------------------------------------------------------------------------
        dx = ElementNodes % x(1) - ElementNodes % x(2)
        dy = ElementNodes % y(1) - ElementNodes % y(2)
        dsmax = SQRT(dx*dx+dy*dy)
        LineNode = 0


        DO i=1,Parent % TYPE % ElementCode / 100 
          DO j=1,2
            dx = ParentNodes % x(i) - ElementNodes % x(j)
            dy = ParentNodes % y(i) - ElementNodes % y(j)
            ds = SQRT(dx*dx+dy*dy)
            IF(ds < 1.0d-4 * dsmax) LineNode(j) = ParentIndexes(i)
          END DO
        END DO

        IF(ALL(LineNode(1:2) > 0)) THEN
          IF(ANY(OnLine(LineNode(1),:) == LineNode(2))) CYCLE
          IF(ANY(OnLine(LineNode(2),:) == LineNode(1))) CYCLE

          IF(OnLine(LineNode(1),1) == 0) THEN
            OnLine(LineNode(1),1) = LineNode(2)
          ELSE IF(OnLine(LineNode(1),2) == 0) THEN
            OnLine(LineNode(1),2) = LineNode(2)
          ELSE
            CALL Warn('PolylineIntegrate','This should never happen')
          END IF
          
          IF(OnLine(LineNode(2),1) == 0) THEN
            OnLine(LineNode(2),1) = LineNode(1)
          ELSE IF(OnLine(LineNode(2),2) == 0) THEN
            OnLine(LineNode(2),2) = LineNode(1)
          ELSE
            CALL Warn('PolylineIntegrate','This should never happen')
          END IF
        END IF


        
        i = ListGetInteger( Model % Bodies(Parent % BodyId) % Values, 'Material', &
            minv=1, maxv=Model % NumberOFMaterials )
        Material => Model % Materials(i) % Values
        fluxescomputed(Line) = fluxescomputed(Line) + 1
        
        
        SELECT CASE(OperName)
          
          CASE('diffusive flux') 
          
          IF(GotCoeff) THEN
            CALL ListGetRealArray( Material, CoeffName, Pwrk, &
                pn, ParentIndexes, gotIt )
            
            EnergyTensor = 0._dp
            IF(GotIt) THEN
              IF ( SIZE(Pwrk,1) == 1 ) THEN
                DO i=1,3
                  EnergyTensor( i,i,1:pn ) = Pwrk( 1,1,1:pn )
                END DO
              ELSE IF ( SIZE(Pwrk,2) == 1 ) THEN
                DO i=1,MIN(3,SIZE(Pwrk,1))
                  EnergyTensor(i,i,1:pn) = Pwrk(i,1,1:pn)
                END DO
              ELSE
                DO i=1,MIN(3,SIZE(Pwrk,1))
                  DO j=1,MIN(3,SIZE(Pwrk,2))
                    EnergyTensor( i,j,1:pn ) = Pwrk(i,j,1:pn)
                  END DO
                END DO
              END IF
            ELSE 
              DO i=1,3          
                EnergyTensor(i,i,1:pn) = 1.0d0
              END DO
            END IF
          END IF
          
          CASE ('convective flux','area')
          EnergyCoeff(1:n) = ListGetReal( Material, CoeffName, pn, ParentIndexes, gotIt )
          IF(.NOT. GotIt) EnergyCoeff(1:pn) = 1.0d0
          
        END SELECT

!------------------------------------------------------------------------------
!    Numerical integration
!------------------------------------------------------------------------------

        IntegStuff = GaussPoints( Element, 2 )
        
        DO i=1,IntegStuff % n
          U = IntegStuff % u(i)
          V = IntegStuff % v(i)
          W = IntegStuff % w(i)

!------------------------------------------------------------------------------
!        Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
          stat = ElementInfo( Element,ElementNodes,U,V,W,SqrtElementMetric, &
              Basis,dBasisdx )
          
          x = SUM( ElementNodes % x(1:n) * Basis(1:n) )
          y = SUM( ElementNodes % y(1:n) * Basis(1:n) )
          z = SUM( ElementNodes % z(1:n) * Basis(1:n) )

!------------------------------------------------------------------------------
!      Coordinatesystem dependent info
!------------------------------------------------------------------------------

          s = 1.0d0

          IF(.FALSE.) THEN
            IF(CurrentCoordinateSystem() /= Cartesian ) s = 2.0 * PI 
            CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,x,y,z )
            s = s * SqrtMetric * SqrtElementMetric * IntegStuff % s(i)
          ELSE
            IF(CurrentCoordinateSystem() /= Cartesian ) s = 2.0 * PI * x
            s = s * SqrtElementMetric * IntegStuff % s(i)            
          END IF
     
          Normal = NormalVector( Element,ElementNodes,U,V,.FALSE. )

!------------------------------------------------------------------------------
!      Because the intersection nodes do not really exist the field variables 
!      must be avaluated using the nodes of the parent element.
!------------------------------------------------------------------------------
            
          Point(1) = x
          Point(2) = y
          Point(3) = z
          
          IF( .NOT. PointInElement( Parent, ParentNodes, Point, LocalCoordinates ) ) THEN
            CALL Warn('PolylineIntegrals','The node should be in the element by construction!')
            CYCLE
          END IF
          
          Up = LocalCoordinates(1)
          Vp = LocalCoordinates(2)
          Wp = LocalCoordinates(3)
          
          
          stat = ElementInfo( Parent,ParentNodes,Up,Vp,Wp,SqrtElementMetric, &
              ParentBasis,ParentdBasisdx )
          
  
          SELECT CASE(OperName)
            
            CASE ('diffusive flux')           
              Flow = 0.0d0
              DO j = 1, DIM
                DO k = 1, DIM
                  Flow(j) = Flow(j) + SUM( EnergyTensor(j,k,1:pn) * ParentBasis(1:pn) ) * &
                      SUM( ParentdBasisdx(1:pn,k) * Var % Values(PermIndexes(1:pn)) ) 
                END DO
              END DO
              fluxes(Line) = fluxes(Line) + s * SUM(Normal(1:DIM) * Flow(1:DIM))
            
            
            CASE ('convective flux')            
              coeff = SUM( EnergyCoeff(1:pn) * ParentBasis(1:pn))              
              IF(NoDofs == 1) THEN
                func = SUM( Var % Values(PermIndexes(1:pn)) * ParentBasis(1:pn) )                
                fluxes(Line) = fluxes(Line) + s * coeff * func
              ELSE 
                DO j=1,DIM
                  Flow(j) = coeff * &
                      SUM( Var % Values(NoDofs*(PermIndexes(1:pn)-1)+j) * ParentBasis(1:pn) )
                END DO
                fluxes(Line) = fluxes(Line) + s * coeff * SUM(Normal * Flow)
              END IF
 
           CASE ('boundary int','boundary int mean')            
              coeff = SUM( EnergyCoeff(1:pn) * ParentBasis(1:pn))              
              IF(NoDofs == 1) THEN
                func = SUM( Var % Values(PermIndexes(1:pn)) * ParentBasis(1:pn) )                
                fluxes(Line) = fluxes(Line) + s * coeff * func
              ELSE 
                flux = 0.0_dp
                DO j=1,NoDofs
                  flux = flux + &
                      SUM( Var % Values(NoDofs*(PermIndexes(1:pn)-1)+j) * ParentBasis(1:pn) )**2
                END DO
                flux = coeff * SQRT(flux) 
                fluxes(Line) = fluxes(Line) + s * flux
              END IF
                         
            CASE ('area')                        
              coeff = SUM( EnergyCoeff(1:pn) * Basis(1:pn))
              fluxes(Line) = fluxes(Line) + s * coeff 
              
            END SELECT

            areas(Line) = areas(Line) + s * coeff

        END DO

      END DO

    END DO

    DEALLOCATE( ParentNodes % x, ParentNodes % y, ParentNodes % z, PermIndexes, &
        SideNodes % x, SideNodes % y, SideNodes % z, SideIndexes, &
        LineNodes % x, LineNodes % y, LineNodes % z, OnLine)

  END SUBROUTINE 
!------------------------------------------------------------------------------


  SUBROUTINE LineIntersectionCoords(Plane,Line,Inside,x0,y0,z0,frac)
! This subroutine tests whether the line segment goes through the current
! face of the element. 

    TYPE(Nodes_t) :: Plane, Line
    LOGICAL :: Inside
    REAL (KIND=dp) :: x0, y0, z0, frac

    REAL (KIND=dp) :: A(3,3),B(3),C(3),eps=1.0d-6,detA,absA

    Inside = .FALSE.
    
    ! In 2D the intersection is between two lines
    A(1,1) = Line % x(2) - Line % x(1)
    A(2,1) = Line % y(2) - Line % y(1)
    A(1,2) = Plane % x(1) - Plane % x(2)
    A(2,2) = Plane % y(1) - Plane % y(2)

    detA = A(1,1)*A(2,2)-A(1,2)*A(2,1)
    absA = SUM(ABS(A(1,1:2))) * SUM(ABS(A(2,1:2)))
    
    IF(ABS(detA) <= eps * absA + 1.0d-20) RETURN
    
    B(1) = Plane % x(1) - Line % x(1) 
    B(2) = Plane % y(1) - Line % y(1) 
    
    CALL InvertMatrix( A,2 )
    C(1:2) = MATMUL(A(1:2,1:2),B(1:2))
    
    IF(ANY(C(1:2) < 0.0) .OR. ANY(C(1:2) > 1.0d0)) RETURN
    
    Inside = .TRUE.
    frac = C(1)
    X0 = Line % x(1) + C(1) * (Line % x(2) - Line % x(1))
    Y0 = Line % y(1) + C(1) * (Line % y(2) - Line % y(1))
    Z0 = Line % z(1) + C(1) * (Line % z(2) - Line % z(1))
    
  END SUBROUTINE LineIntersectionCoords
  
!------------------------------------------------------------------------------
END SUBROUTINE SaveScalars
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
! Saves line data in different formats.
! 1) Saves the 1D boundaries with keyword 'Save Line'
! 2) Saves the principle axis (This might be obsolite)
! 3) Saves polyline defined by coordinates in 2D or 3D  
!------------------------------------------------------------------------------

SUBROUTINE SaveLine( Model,Solver,dt,TransientSimulation )

  USE Types
  USE Lists
  USE Integration
  USE ElementDescription
  USE ElementUtils
  USE SolverUtils
  USE MeshUtils
  USE BandwidthOptimize
  USE DefUtils


  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  CHARACTER(LEN=MAX_NAME_LEN), PARAMETER :: DefaultSideFile = 'sides.dat'

  REAL (KIND=DP), ALLOCATABLE ::  Values(:), Basis(:)
  REAL (KIND=dp) :: daxisx, daxisy, daxisz, x, y, z, eps, IntersectEpsilon, f1, f2, fn, weight
  REAL (KIND=DP), POINTER :: PointCoordinates(:,:), PointFluxes(:,:), PointWeight(:)
  LOGICAL :: Stat, GotIt, SubroutineVisited = .FALSE., FileAppend, CalculateFlux, &
      SaveAxis(3), Inside, MovingMesh, IntersectEdge, OptimizeOrder, Found, GotVar
  INTEGER :: i,j,k,l,n,m,t,DIM,mat_id, TimesVisited=0, SaveThis, PrevDoneTime=-1, &
      Side, SaveNodes, SaveNodes2, node, NoResults, LocalNodes, NoVar, &
      No, axis, maxboundary, NoDims, NoLines, NoAxis, Line, NoFaces, &
      NoEigenValues, IntersectCoordinate, ElemCorners, ElemDim, FluxBody
  INTEGER, POINTER :: NodeIndexes(:), SavePerm(:), InvPerm(:), BoundaryIndex(:)
  TYPE(Solver_t), POINTER :: ParSolver
  TYPE(Variable_t), POINTER :: Var
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(ValueList_t), POINTER :: Material
  TYPE(Nodes_t) :: ElementNodes, LineNodes
  TYPE(Element_t), POINTER   :: CurrentElement
  CHARACTER(LEN=MAX_NAME_LEN) :: SideFile, SideNamesFile, VarName, Name, CondName, &
       TempName, MaskName, PrevMaskName, SideParFile, DateStr
  CHARACTER(LEN=MAX_NAME_LEN), ALLOCATABLE :: ValueNames(:)


  LOGICAL, POINTER :: LineTag(:)
  LOGICAL :: cand, Parallel, InitializePerm

  SAVE SubroutineVisited, TimesVisited, SavePerm, SaveNodes, ElementNodes, LineNodes, &
      Basis, NoResults, NoEigenValues, Values, PrevDoneTime, Parallel, &
      ParSolver, SideParFile, PrevMaskName

!------------------------------------------------------------------------------

  Mesh => Model % Meshes
  DO WHILE( ASSOCIATED(Mesh) )
    IF (Mesh % OutputActive) EXIT 
    Mesh => Mesh % Next
  END DO

  CALL SetCurrentMesh( Model, Mesh )

  IF(.NOT. SubroutineVisited) THEN
     n = Mesh % MaxElementNodes
     ALLOCATE( ElementNodes % x(n), ElementNodes % y(n), ElementNodes % z(n), &
          LineNodes % x(2), LineNodes % y(2), LineNodes % z(2), &
          Basis(n), SavePerm(Mesh % NumberOfNodes) )
     
     Parallel = .FALSE.
     DO i = 1, Model % NumberOfSolvers
        ParSolver => Model % Solvers(i)
        IF ( .NOT. ASSOCIATED( ParSolver % Matrix ) )  CYCLE
        IF ( ASSOCIATED( ParSolver % Matrix % ParMatrix ) ) THEN
           IF ( ParSolver %  Matrix % ParMatrix % ParEnv % PEs > 1 )  THEN
              Parallel = .TRUE.
              EXIT
           END IF
        END IF
     END DO
  END IF

  DIM = CoordinateSystemDimension()

  IF(TransientSimulation .AND. PrevDoneTime /= Solver % DoneTime) THEN
     PrevDoneTime = Solver % DoneTime
     TimesVisited = 0
  END IF

  TimesVisited = TimesVisited + 1
  

  SideFile = ListGetString(Solver % Values,'Filename',GotIt )
  IF(.NOT. GotIt) SideFile = DefaultSideFile
  
  IF(ListGetLogical(Solver % Values,'Filename Numbering',GotIt)) THEN
    SideFile = NextFreeFilename( SideFile ) 
  END IF
  
  FileAppend = ListGetLogical(Solver % Values,'File Append',GotIt )
  MovingMesh = ListGetLogical(Solver % Values,'Moving Mesh',GotIt )
 
  IntersectEdge = ListGetLogical(Solver % Values,'Intersect Edge',GotIt )
  IF(IntersectEdge) THEN
     IntersectCoordinate = ListGetInteger(Solver % Values,'Intersect Coordinate')
     IntersectEpsilon = ListGetConstReal(Solver % Values,'Intersect Epsilon')
  ELSE 
     IntersectCoordinate = 0
  END IF
  
  CalculateFlux = ListGetLogical(Solver % Values,'Save Heat Flux',GotIt )
  IF(.NOT. CalculateFlux) THEN
     CalculateFlux = ListGetLogical(Solver % Values,'Save Flux',GotIt )
  END IF
  
  IF(CalculateFlux) THEN
     TempName = ListGetString(Solver % Values,'Flux Variable',GotIt )
     IF(.NOT. gotIt) TempName = TRIM('Temperature')
     CondName = ListGetString(Solver % Values,'Flux Coefficient',GotIt )
     IF(.NOT. gotIt) CondName = TRIM('Heat Conductivity')
  END IF
  
  SaveAxis(1) = ListGetLogical(Solver % Values,'Save Axis',GotIt)
  IF(GotIt) THEN
     SaveAxis(2:3) = SaveAxis(1)
  ELSE
     SaveAxis(1) = ListGetLogical(Solver % Values,'Save Axis 1',GotIt)
     SaveAxis(2) = ListGetLogical(Solver % Values,'Save Axis 2',GotIt)
     SaveAxis(3) = ListGetLogical(Solver % Values,'Save Axis 3',GotIt)    
  END IF
  NoAxis = DIM
  
  PointCoordinates => ListGetConstRealArray(Solver % Values,'Polyline Coordinates',gotIt)
  IF(gotIt) THEN
     NoLines = SIZE(PointCoordinates,1) / 2
     NoDims = SIZE(PointCoordinates,2)
  ELSE 
     NoLines = 0
  END IF
  

!----------------------------------------------
! Calculate the number of given entries, if any
!---------------------------------------------- 
  NoVar = 0  
  DO i = 1,99
     NULLIFY(Var)    
     IF(i < 10) THEN 
        WRITE (Name,'(A,I2)') 'Variable',i
     ELSE
        WRITE (Name,'(A,I3)') 'Variable',i
     END IF
     VarName = ListGetString( Solver % Values, TRIM(Name), Found )
     IF(.NOT. Found) EXIT
     Var => VariableGet( Model % Variables, TRIM(VarName) )
     IF ( .NOT. ASSOCIATED( Var ) )  EXIT
     NoVar = i
  END DO

!----------------------------------------------
! Calculate the number of entries for each node
!---------------------------------------------- 
  NoResults = 0
  Var => Model % Variables
  DO WHILE( ASSOCIATED( Var ) )            
     IF ( .NOT. Var % Output .OR. SIZE(Var % Values) == 1 .OR. &
          (Var % DOFs /= 1 .AND. .NOT. ASSOCIATED(Var % EigenVectors)) ) THEN
        Var => Var % Next        
        CYCLE
     END IF
     IF(NoVar > 0) THEN
        Found = .FALSE.
        DO i = 1,NoVar
           IF(i < 10) THEN 
              WRITE (Name,'(A,I2)') 'Variable',i
           ELSE
              WRITE (Name,'(A,I3)') 'Variable',i
           END IF
           VarName = ListGetString( Solver % Values, TRIM(Name) )
           IF( TRIM(VarName) == TRIM(Var % Name) ) THEN
              Found = .TRUE.
              EXIT 
           END IF
        END DO
        IF(.NOT. Found) THEN
           Var => Var % Next        
           CYCLE
        END IF
     END IF
     IF (ASSOCIATED (Var % EigenVectors)) THEN
        NoEigenValues = SIZE(Var % EigenValues) 
        NoResults = NoResults + Var % Dofs * NoEigenValues
     ELSE 
        NoResults = NoResults + 1
     END IF
     Var => Var % Next      
  END DO
  IF ( CalculateFlux ) NoResults = NoResults + 3
     
  ALLOCATE( Values(NoResults) )
 
  CALL Info( 'SaveLine', '------------------------------------------', Level=4 )
  WRITE( Message, * ) 'Saving line data to file ', TRIM(SideFile)
  CALL Info( 'SaveLine', Message, Level=4 )
  CALL Info( 'SaveLine', '------------------------------------------', Level=4 )

!------------------------------------------------------------------------------
! Open files for saving
!------------------------------------------------------------------------------
  IF ( Parallel ) THEN
     
     DO i=1,MAX_NAME_LEN
        IF ( SideFile(i:i) == ' ' ) EXIT
        SideParFile(i:i) = SideFile(i:i)
     END DO
     SideParFile(i:i) = '.'
     
     IF ( ParSolver % Matrix % ParMatrix % ParEnv % MyPE < 10 ) THEN
        WRITE( SideParFile(i+1:), '(i1)' ) &
             ParSolver % Matrix % ParMatrix % ParEnv % MyPE
     ELSE IF ( ParSolver % Matrix % ParMatrix % ParEnv % MyPE < 100 ) THEN
        WRITE( SideParFile(i+1:), '(i2)' ) &
             ParSolver % Matrix % ParMatrix % ParEnv % MyPE
     ELSE
        WRITE( SideParFile(i+1:), '(i3)' ) &
             ParSolver % Matrix % ParMatrix % ParEnv % MyPE
     END IF
     
     IF(SubroutineVisited .OR. FileAppend) THEN 
        OPEN (10, FILE=SideParFile,POSITION='APPEND')
     ELSE 
        OPEN (10,FILE=SideParFile)
     END IF
  ELSE
     IF(SubroutineVisited .OR. FileAppend) THEN 
        OPEN (10, FILE=SideFile, POSITION='APPEND')
     ELSE 
        OPEN (10,FILE=SideFile)
     END IF
  END IF

!------------------------------------------------------------------------------
! Find out which nodes should be saved and optimize their order 
!------------------------------------------------------------------------------

  MaskName = ListGetString(Solver % Values,'Save Mask',GotIt) 
  IF(.NOT. GotIt) MaskName = 'Save Line'

  IF( SubroutineVisited ) THEN
     InitializePerm = ( MaskName /= PrevMaskName ) 
     InitializePerm = InitializePerm .OR. Solver % Mesh % Changed
  ELSE
     InitializePerm = .TRUE.
  END IF

  IF( InitializePerm ) THEN
     SavePerm = 0
     SaveNodes = 0

     OptimizeOrder = ListGetLogical(Solver % Values,'Optimize Node Ordering',GotIt)
     IF(.NOT. GotIt) OptimizeOrder = .TRUE.

     CALL MakePermUsingMask( Model,Solver,Mesh,MaskName, &
          OptimizeOrder, SavePerm, SaveNodes )

     WRITE( Message, * ) 'Number of nodes in specified boundary ', SaveNodes
     CALL Info('SaveLine',Message)
  END IF
  PrevMaskName = MaskName

!------------------------------------------------------------------------------
! If nodes found, then go through the sides and compute the fluxes if requested 
!------------------------------------------------------------------------------

  maxboundary = 0
  IF( SaveNodes > 0 ) THEN

     ALLOCATE( InvPerm(SaveNodes), BoundaryIndex(SaveNodes) )
     BoundaryIndex = 0
     InvPerm = 0
     DO i=1,SIZE(SavePerm)
        IF (SavePerm(i)>0) THEN
           ! Error check for something that should never happen
           IF( InvPerm( SavePerm(i)) > 0) THEN
              WRITE( Message, *) 'Node multiple times in permutation',i,SavePerm(i)
              CALL Warn('SaveLine',Message)
           END IF
           InvPerm(SavePerm(i)) = i
        END IF
     END DO

     IF(CalculateFlux) THEN
        ALLOCATE(PointFluxes(SaveNodes,3),PointWeight(SaveNodes))    
        PointFluxes = 0.0d0
        PointWeight = 0.0d0
     END IF
     
     ! Go through the elements and register the boundary index and fluxes if asked
     DO t = 1,  Mesh % NumberOfBulkElements + Mesh % NumberOfBoundaryElements        
        
        CurrentElement => Mesh % Elements(t)
        Model % CurrentElement => CurrentElement
        n = CurrentElement % TYPE % NumberOfNodes
        NodeIndexes => CurrentElement % NodeIndexes
        
        IF( .NOT. ALL(SavePerm(NodeIndexes) > 0)) CYCLE 
        
        Found = .FALSE.
        IF(t <= Mesh % NumberOfBulkElements) THEN
           k = CurrentElement % BodyId           
           IF( ListGetLogical( Model % Bodies(k) % Values,'Flux Integrate Body', gotIt )) THEN
              Found = .TRUE.
              FluxBody = ListGetInteger( Model % Bodies(k) % Values,'Flux Integrate Body', gotIt ) 
           END IF
        ELSE
           DO k=1, Model % NumberOfBCs
              IF ( Model % BCs(k) % Tag /= CurrentElement % BoundaryInfo % Constraint ) CYCLE
              IF( ListCheckPresent(Model % BCs(k) % Values, MaskName ) ) THEN
                 Found = .TRUE.
                 FluxBody = ListGetInteger( Model % BCs(k) % Values,'Flux Integrate Body', gotIt )         
                 EXIT
              END IF
           END DO
        END IF
        IF(.NOT. Found) CYCLE

        BoundaryIndex( SavePerm(NodeIndexes) ) = k
        
        IF( .NOT. CalculateFlux ) CYCLE
        
        ElemCorners = CurrentElement % TYPE % ElementCode / 100
        IF(ElemCorners > 4 .OR. ElemCorners < 2) CYCLE
        
        ElementNodes % x(1:n) = Mesh % Nodes % x(NodeIndexes)
        ElementNodes % y(1:n) = Mesh % Nodes % y(NodeIndexes)
        ElementNodes % z(1:n) = Mesh % Nodes % z(NodeIndexes)
        
        DO i=1,n
           node = NodeIndexes(i)
           
           CALL BoundaryFlux( Model, node, TempName,  &
                CondName, f1, f2, fn, weight, Mesh % MaxElementDOFs ) 

           j = SavePerm(node) 

           PointFluxes(j,1) = PointFluxes(j,1) + weight * f1
           PointFluxes(j,2) = PointFluxes(j,2) + weight * f2
           PointFluxes(j,3) = PointFluxes(j,3) + weight * fn
           PointWeight(j) = PointWeight(j) + weight
        END DO        
     END DO


     ! Normalize flux by division with the integration weight
     IF( CalculateFlux ) THEN
        DO i = 1, SaveNodes
           PointFluxes(i,1) = PointFluxes(i,1) / PointWeight(i)
           PointFluxes(i,2) = PointFluxes(i,2) / PointWeight(i)
           PointFluxes(i,3) = PointFluxes(i,3) / PointWeight(i)
        END DO
        DEALLOCATE(PointWeight)
     END IF
     MaxBoundary = MAXVAL(BoundaryIndex)
     
     
     ! Save the nodes      
     !---------------
     
     DO t = 1,  SaveNodes    
        
        node = InvPerm(t)
        IF( NoVar == 0) THEN
           IF(TransientSimulation) WRITE(10,'(I6)',ADVANCE='NO') Solver % DoneTime
           WRITE(10,'(I6,I4,I8)',ADVANCE='NO') TimesVisited,BoundaryIndex(t),node
        END IF

        No = 0
        Values = 0.0d0
        
        Var => Model % Variables      
        DO WHILE( ASSOCIATED( Var ) )
           
           IF ( .NOT. Var % Output .OR. SIZE(Var % Values) == 1 .OR. &
                (Var % DOFs /= 1 .AND. .NOT. ASSOCIATED(Var % EigenVectors)) ) THEN
              Var => Var % Next        
              CYCLE
           END IF
           IF(NoVar > 0) THEN
              Found = .FALSE.
              DO i = 1,NoVar
                 IF(i < 10) THEN 
                    WRITE (Name,'(A,I2)') 'Variable',i
                 ELSE
                    WRITE (Name,'(A,I3)') 'Variable',i
                 END IF
                 VarName = ListGetString( Solver % Values, TRIM(Name) )
                 IF( TRIM(VarName) == TRIM(Var % Name) ) THEN
                    Found = .TRUE.
                    EXIT 
                 END IF
              END DO
              IF(.NOT. Found) THEN
                 Var => Var % Next        
                 CYCLE
              END IF
           END IF
           
           l = node
           IF (ASSOCIATED (Var % EigenVectors)) THEN
              NoEigenValues = SIZE(Var % EigenValues) 
              DO j=1,NoEigenValues
                 DO i=1,Var % DOFs
                    IF ( ASSOCIATED(Var % Perm) ) l = Var % Perm(l)
                    IF(l > 0) THEN 
                       Values(No+(j-1)*Var%Dofs+i) = &
                            Var % EigenVectors(j,Var%Dofs*(l-1)+i)
                    END IF
                 END DO
              END DO
              No = No + Var % Dofs * NoEigenValues
           ELSE           
              No = No + 1
              IF ( ASSOCIATED(Var % Perm) ) l = Var % Perm(l)
              IF(l > 0) Values(No) = Var % Values(l)          
           END IF
           Var => Var % Next          
        END DO
        
        IF(CalculateFlux) THEN
           Values(No+1:No+3) = PointFluxes(t,1:3)
        END IF
        
        IF(NoResults > 0) THEN
           DO i=1,NoResults-1
              WRITE(10,'(ES21.12E3)',ADVANCE='NO') Values(i)
           END DO
           WRITE(10,'(ES21.12E3)') Values(NoResults)
        END IF
     END DO
     
     DEALLOCATE(InvPerm, BoundaryIndex)
     IF(CalculateFlux) DEALLOCATE(PointFluxes)
  END IF


  !---------------------------------------------------------------------------
  ! Save data in the intersections of line segments defined by two coordinates
  ! and element faces, or save any of the principal axis.
  !---------------------------------------------------------------------------
  SaveNodes2 = 0
  IF(NoLines > 0  .OR. ANY(SaveAxis(1:DIM)) ) THEN
     
     ALLOCATE( LineTag(Mesh % NumberOfNodes) )
     
     IF(.NOT. SubroutineVisited) THEN 
        CALL FindMeshEdges( Mesh, .FALSE.)
     END IF
     
     IF(DIM == 2 .OR. IntersectEdge) THEN
        NoFaces = Mesh % NumberOfEdges
     ELSE 
        NoFaces = Mesh % NumberOfFaces
     END IF
     
     DO Line = 1,NoLines + NoAxis
        
        LineTag = .FALSE.

        IF(Line <= NoLines) THEN
           LineNodes % x(1:2) = PointCoordinates(2*Line-1:2*Line,1) 
           LineNodes % y(1:2) = PointCoordinates(2*Line-1:2*Line,2) 
           IF(DIM == 3) THEN
              LineNodes % z(1:2) = PointCoordinates(2*Line-1:2*Line,3) 
           ELSE
              LineNodes % z(1:2) = 0.0d0
           END IF
        ELSE 
           IF(.NOT. SaveAxis(Line-NoLines)) CYCLE
           ! Define the lines for principal axis
           IF(Line-NoLines == 1) THEN
              LineNodes % x(1) = MINVAL(Mesh % Nodes % x)
              LineNodes % x(2) = MAXVAL(Mesh % Nodes % x)
              LineNodes % y(1:2) = 0.0d0
              LineNodes % z(1:2) = 0.0d0
           ELSE IF(Line-NoLines == 2) THEN
              LineNodes % x(1:2) = 0.0d0
              LineNodes % y(1) = MINVAL(Mesh % Nodes % y)
              LineNodes % y(2) = MAXVAL(Mesh % Nodes % y)
              LineNodes % z(1:2) = 0.0d0
           ELSE          
              LineNodes % x(1:2) = 0.0d0
              LineNodes % y(1:2) = 0.0d0
              LineNodes % z(1) = MINVAL(Mesh % Nodes % z)
              LineNodes % z(2) = MAXVAL(Mesh % Nodes % z)
           END IF
        END IF
        
        
        DO t = 1,NoFaces
           
           IF(DIM == 2 .OR. IntersectEdge) THEN
              CurrentElement => Mesh % Edges(t)
           ELSE 
              CurrentElement => Mesh % Faces(t)
           END IF
           
           n = CurrentElement % TYPE % NumberOfNodes
           NodeIndexes => CurrentElement % NodeIndexes
           
           ElementNodes % x(1:n) = Mesh % Nodes % x(NodeIndexes)
           ElementNodes % y(1:n) = Mesh % Nodes % y(NodeIndexes)
           IF(DIM == 3) THEN
              ElementNodes % z(1:n) = Mesh % Nodes % z(NodeIndexes)
           ELSE
              ElementNodes % z(1:n) = 0.0d0
           END IF
           
           CALL GlobalToLocalCoords(CurrentElement,ElementNodes,n,LineNodes, &
                Inside,Basis,i)
           
           IF(.NOT. Inside) CYCLE
           
           ! When the line goes through a node it might be saved several times 
           ! without this checking
           IF(1.0d0-MAXVAL(Basis(1:n)) < 1.0d-3) THEN
              IF( LineTag(NodeIndexes(i)) ) CYCLE
              LineTag(NodeIndexes(i)) = .TRUE.
           END IF
           
           SaveNodes2 = SaveNodes2 + 1
           
           IF( NoVar == 0) THEN
              IF(TransientSimulation) WRITE(10,'(I6)',ADVANCE='NO') Solver % DoneTime
              WRITE(10,'(I6,I4,I8)',ADVANCE='NO') TimesVisited,maxboundary+Line,NodeIndexes(i)
           END IF

           Var => Model % Variables
           No = 0
           Values = 0.0d0
           
           DO WHILE( ASSOCIATED( Var ) )
              
              IF ( .NOT. Var % Output .OR. SIZE(Var % Values) == 1 .OR. &
                   (Var % DOFs /= 1 .AND. .NOT. ASSOCIATED(Var % EigenVectors)) ) THEN
                 Var => Var % Next        
                 CYCLE
              END IF
              
              IF(NoVar > 0) THEN
                 Found = .FALSE.
                 DO i = 1,NoVar
                    IF(i < 10) THEN 
                       WRITE (Name,'(A,I2)') 'Variable',i
                    ELSE
                       WRITE (Name,'(A,I3)') 'Variable',i
                    END IF
                    VarName = ListGetString( Solver % Values, TRIM(Name) )
                    IF( TRIM(VarName) == TRIM(Var % Name) ) THEN
                       Found = .TRUE.
                       EXIT 
                    END IF
                 END DO
                 IF(.NOT. Found) THEN
                    Var => Var % Next        
                    CYCLE
                 END IF
              END IF
              
              IF (ASSOCIATED (Var % EigenVectors)) THEN
                 NoEigenValues = SIZE(Var % EigenValues) 
                 DO j=1,NoEigenValues
                    DO i=1,Var % DOFs
                       DO k=1,n
                          l = NodeIndexes(k)
                          IF ( ASSOCIATED(Var % Perm) ) l = Var % Perm(l)
                          IF(l > 0) THEN 
                             Values(No+(j-1)*Var%Dofs+i) = Values(No+(j-1)*Var%Dofs+i) + &
                                  Basis(k) * (Var % EigenVectors(j,Var%Dofs*(l-1)+i))
                          END IF
                       END DO
                    END DO
                 END DO
                 No = No + Var % Dofs * NoEigenValues
              ELSE                  
                 No = No + 1
                 DO k=1,n
                    l = NodeIndexes(k)
                    IF ( ASSOCIATED(Var % Perm) ) l = Var % Perm(l)
                    IF(l > 0) Values(No) = Values(No) + Basis(k) * (Var % Values(l))
                 END DO
              END IF
              
              Var => Var % Next          
           END DO
           
           IF ( CalculateFlux ) Values(No+1:No+3) = 0.0
           
           IF(NoResults > 0) THEN
              DO i=1,NoResults
                 WRITE(10,'(ES20.11E3)',ADVANCE='NO') Values(i)
              END DO
              WRITE(10,'(ES20.11E3)') Values(NoResults)
           END IF
           
        END DO
     END DO

     DEALLOCATE( LineTag )

     WRITE( Message, * ) 'Number of nodes in specified lines ', SaveNodes2
     CALL Info('SaveLine',Message)
  END IF
  CLOSE(10)
  DEALLOCATE( Values )


  ! Finally save the names of the variables to help to identify the 
  ! columns in the result matrix.
  IF(.NOT. SubroutineVisited) THEN
     ALLOCATE( ValueNames(NoResults) )
   
     No = 0
     Var => Model % Variables
     DO WHILE( ASSOCIATED( Var ) )    
        
        IF ( .NOT. Var % Output .OR. SIZE(Var % Values) == 1 .OR. &
             (Var % DOFs /= 1 .AND. .NOT. ASSOCIATED(Var % EigenVectors)) ) THEN
           Var => Var % Next         
           CYCLE
        END IF
        IF(NoVar > 0) THEN
           Found = .FALSE.
           DO i = 1,NoVar
              IF(i < 10) THEN 
                 WRITE (Name,'(A,I2)') 'Variable',i
              ELSE
                 WRITE (Name,'(A,I3)') 'Variable',i
              END IF
              VarName = ListGetString( Solver % Values, TRIM(Name) )
              IF( TRIM(VarName) == TRIM(Var % Name) ) THEN
                 Found = .TRUE.
                 EXIT 
              END IF
           END DO
           IF(.NOT. Found) THEN
              Var => Var % Next        
              CYCLE
           END IF
        END IF
          
        IF (ASSOCIATED (Var % EigenVectors)) THEN
           NoEigenValues = SIZE(Var % EigenValues) 
           DO j=1,NoEigenValues
              DO i=1,Var % DOFs
                 IF(i==1) THEN
                    WRITE(ValueNames(No+(j-1)*Var%Dofs+i),'(A,I2,A,A,I2,A,2ES20.11E3)') &
                         "Eigen",j," ",TRIM(Var%Name),i,"   EigenValue = ",Var % EigenValues(j)
                 ELSE 
                    WRITE(ValueNames(No+(j-1)*Var%Dofs+i),'(A,I2,A,A,I2)') &
                         "Eigen",j," ",TRIM(Var%Name),i
                 END IF
              END DO
           END DO
           No = No + Var % Dofs * NoEigenValues
        ELSE 
           No = No + 1
           ValueNames(No) = TRIM(Var % Name)
        END IF
        Var => Var % Next      
     END DO

     IF ( CalculateFlux ) THEN
        ValueNames(No+1) = 'Flux 1'
        ValueNames(No+2) = 'Flux 2'
        ValueNames(No+3) = 'Flux normal'      
     END IF

  
     SideNamesFile = TRIM(SideFile) // '.' // TRIM("names")
     OPEN (10, FILE=SideNamesFile)

     Message = ListGetString(Model % Simulation,'Comment',GotIt)
     IF( GotIt ) THEN
       WRITE(10,'(A)') TRIM(Message)
     END IF
     Message = ListGetString(Solver % Values,'Comment',GotIt)
     IF( GotIt ) THEN
       WRITE(10,'(A)') TRIM(Message)
     END IF 
     WRITE(10,'(A,A)') 'Variables in file: ',TRIM(SideFile)

     DateStr = FormatDate()
     WRITE( 10,'(A,A)') 'File started at: ',TRIM(DateStr)

     WRITE(10,'(I7,A)') SaveNodes,' boundary nodes for each step'
     WRITE(10,'(I7,A)') SaveNodes2,' polyline nodes for each step'
     j = 0
     IF( NoVar == 0 ) THEN
        IF(TransientSimulation) THEN
           WRITE(10,'(I3,": ",A)') 1,'Time step'
           j = 1
        END IF
        WRITE(10,'(I3,": ",A)') 1+j,'Iteration step'
        WRITE(10,'(I3,": ",A)') 2+j,'Boundary condition'
        WRITE(10,'(I3,": ",A)') 3+j,'Node index'
        j = j + 3
     END IF
     DO i=1,NoResults
        WRITE(10,'(I3,": ",A)') i+j,TRIM(ValueNames(i))
     END DO
     CLOSE(10)
     DEALLOCATE( ValueNames )
  END IF

  SubroutineVisited = .TRUE.

  CALL Info('SaveLine','All done')

CONTAINS


  SUBROUTINE GlobalToLocalCoords(Element,Plane,n,Line, &
      Inside,Weights,maxind)
!---------------------------------------------------------------------------
! This subroutine tests whether the line segment goes through the current
! face of the element. If true the weights and index to the closest node 
! are returned. 
!---------------------------------------------------------------------------

    TYPE(Nodes_t) :: Plane, Line
    TYPE(Element_t), POINTER   :: Element
    INTEGER :: n, maxind
    REAL (KIND=dp) :: Weights(:)
    LOGICAL :: Inside

    REAL (KIND=dp) :: A(3,3),A0(3,3),B(3),C(3),Eps,Eps2,detA,absA,ds
    INTEGER :: split, i, corners, visited=0
    REAL(KIND=dp) :: Basis(2*n),dBasisdx(2*n,3)
    REAL(KIND=dp) :: SqrtElementMetric,U,V,W=0.0d0

    SAVE visited
    visited = visited + 1

    Inside = .FALSE.
    corners = MIN(n,4)

    Eps = 1.0d-6
    Eps2 = SQRT(TINY(Eps2))    

    ! In 2D the intersection is between two lines
    IF(DIM == 2) THEN
      A(1,1) = Line % x(2) - Line % x(1)
      A(2,1) = Line % y(2) - Line % y(1)
      A(1,2) = Plane % x(1) - Plane % x(2)
      A(2,2) = Plane % y(1) - Plane % y(2)
      A0 = A

      detA = A(1,1)*A(2,2)-A(1,2)*A(2,1)
      absA = SUM(ABS(A(1,1:2))) * SUM(ABS(A(2,1:2)))

      ! Lines are almost parallel => no intersection possible
      IF(ABS(detA) <= eps * absA + Eps2) RETURN

      B(1) = Plane % x(1) - Line % x(1) 
      B(2) = Plane % y(1) - Line % y(1) 

      CALL InvertMatrix( A,2 )
      C(1:2) = MATMUL(A(1:2,1:2),B(1:2))
     
      IF(ANY(C(1:2) < 0.0) .OR. ANY(C(1:2) > 1.0d0)) RETURN

      Inside = .TRUE.
      u = -1.0d0 + 2.0d0 * C(2)
    END IF


    IF(DIM == 3 .AND. IntersectCoordinate /= 0) THEN
      IF(IntersectCoordinate == 1) THEN
        A(1,1) = Line % y(2) - Line % y(1)
        A(2,1) = Line % z(2) - Line % z(1)
        A(1,2) = Plane % y(1) - Plane % y(2)
        A(2,2) = Plane % z(1) - Plane % z(2)
      ELSE IF(IntersectCoordinate == 2) THEN
        A(1,1) = Line % x(2) - Line % x(1)
        A(2,1) = Line % z(2) - Line % z(1)
        A(1,2) = Plane % x(1) - Plane % x(2)
        A(2,2) = Plane % z(1) - Plane % z(2)
      ELSE IF(IntersectCoordinate == 3) THEN
        A(1,1) = Line % x(2) - Line % x(1)
        A(2,1) = Line % y(2) - Line % y(1)
        A(1,2) = Plane % x(1) - Plane % x(2)
        A(2,2) = Plane % y(1) - Plane % y(2)
      ELSE
        PRINT *,'Intersect',IntersectCoordinate
        CALL Fatal('GlobalToLocalCoords','Impossible value for parameter IntersectCoordinate')
      END IF

      A0 = A
      
      detA = A(1,1)*A(2,2)-A(1,2)*A(2,1)
      absA = SUM(ABS(A(1,1:2))) * SUM(ABS(A(2,1:2)))

      IF(ABS(detA) <= eps * absA + Eps2) RETURN
     
      B(1) = Plane % x(1) - Line % x(1) 
      B(2) = Plane % y(1) - Line % y(1) 

      CALL InvertMatrix( A,2 )
      C(1:2) = MATMUL(A(1:2,1:2),B(1:2))

!      PRINT *,'C',C(1:2)
!      PRINT *,'xp=',Plane % x(1) + C(2) * (Plane % x(2) - Plane % x(1)) 
!      PRINT *,'xl=',Line % x(1) + C(1) * (Line % x(2) - Line % x(1)) 
!      PRINT *,'yp=',Plane % y(1) + C(2) * (Plane % y(2) - Plane % y(1)) 
!      PRINT *,'yl=',Line % y(1) + C(1) * (Line % y(2) - Line % y(1)) 

      IF(ANY(C(1:2) < 0.0) .OR. ANY(C(1:2) > 1.0d0)) RETURN

      IF(IntersectCoordinate == 1) THEN
        ds = Line % x(1) + C(1)* (Line % x(2) - Line % x(1))  &
            - Plane % x(1) - C(2) * (Plane % x(1) - Plane % x(2))
      ELSE IF(IntersectCoordinate == 2) THEN
        ds = Line % y(1) + C(1)* (Line % y(2) - Line % y(1))  &
            - Plane % y(1) - C(2) * (Plane % y(1) - Plane % y(2))
      ELSE 
        ds = Line % z(1) + C(1)* (Line % z(2) - Line % z(1))  &
            - Plane % z(1) - C(2) * (Plane % z(1) - Plane % z(2))      
      END IF

      IF(ABS(ds) > IntersectEpsilon) RETURN

      Inside = .TRUE.
      u = -1.0d0 + 2.0d0 * C(2)
    END IF   

    
    ! In 3D rectangular faces are treated as two triangles
    IF(DIM == 3 .AND. IntersectCoordinate == 0) THEN

      DO split=0,corners-3
         
        A(1,1) = Line % x(2) - Line % x(1)
        A(2,1) = Line % y(2) - Line % y(1)
        A(3,1) = Line % z(2) - Line % z(1)

        IF(split == 0) THEN
          A(1,2) = Plane % x(1) - Plane % x(2)
          A(2,2) = Plane % y(1) - Plane % y(2)
          A(3,2) = Plane % z(1) - Plane % z(2)
        ELSE 
          A(1,2) = Plane % x(1) - Plane % x(4)
          A(2,2) = Plane % y(1) - Plane % y(4)
          A(3,2) = Plane % z(1) - Plane % z(4)
        END IF

        A(1,3) = Plane % x(1) - Plane % x(3)
        A(2,3) = Plane % y(1) - Plane % y(3)
        A(3,3) = Plane % z(1) - Plane % z(3)
        
        ! Check for linearly dependent vectors
        detA = A(1,1)*(A(2,2)*A(3,3)-A(2,3)*A(3,2)) &
             - A(1,2)*(A(2,1)*A(3,3)-A(2,3)*A(3,1)) &
             + A(1,3)*(A(2,1)*A(3,2)-A(2,2)*A(3,1))
        absA = SUM(ABS(A(1,1:3))) * SUM(ABS(A(2,1:3))) * SUM(ABS(A(3,1:3))) 

        IF(ABS(detA) <= eps * absA + Eps2) CYCLE
!        print *,'detA',detA

        B(1) = Plane % x(1) - Line % x(1)
        B(2) = Plane % y(1) - Line % y(1)
        B(3) = Plane % z(1) - Line % z(1)
        
        CALL InvertMatrix( A,3 )
        C(1:3) = MATMUL( A(1:3,1:3),B(1:3) )
        
        IF( ANY(C(1:3) < 0.0) .OR. ANY(C(1:3) > 1.0d0) ) CYCLE
        IF(C(2)+C(3) > 1.0d0) CYCLE

        Inside = .TRUE. 

        ! Relate the point of intersection to local coordinates
        IF(corners < 4) THEN
          u = C(2)
          v = C(3)
        ELSE IF(corners == 4 .AND. split == 0) THEN
          u = 2*(C(2)+C(3))-1
          v = 2*C(3)-1
        ELSE 
          ! For the 2nd split of the rectangle the local coordinates switched
          v = 2*(C(2)+C(3))-1
          u = 2*C(3)-1        
        END IF

        IF(Inside) EXIT
        
      END DO
    END IF

    IF(.NOT. Inside) RETURN

    stat = ElementInfo( Element, Plane, U, V, W, SqrtElementMetric, &
        Basis, dBasisdx )
    
    ! This check seems to work only for linear elements
    ! and seems to be futile probably there too.
    ! IF( n == Element % TYPE % ElementCode / 100 ) THEN
    !  IF(MAXVAL(Basis(1:n)-1.0) > eps .OR. MINVAL(Basis(1:n)) < -eps) THEN
    !    Inside = .FALSE.
    !    RETURN
    !  END IF
    !END IF

    Weights(1:n) = Basis(1:n)
    MaxInd = 1
    DO i=2,n
      IF(Weights(MaxInd) < Weights(i)) MaxInd = i
    END DO

  END SUBROUTINE GlobalToLocalCoords
  

   
  SUBROUTINE BoundaryFlux( Model, Node, VarName, CoeffName, f1, f2, fn, weight, MaxN) 
    USE Types
    USE Lists
    USE ElementDescription
    
    TYPE(Model_t) :: Model
    INTEGER :: dimno,i,j,n,node,lbody,rbody,MaxN
    CHARACTER(LEN=MAX_NAME_LEN) :: VarName, CoeffName
    REAL(KIND=dp) :: f1, f2, fn, weight
    
    TYPE(Variable_t), POINTER :: Tvar
    TYPE(Element_t), POINTER :: Parent, Element, OldCurrentElement
    TYPE(Nodes_t) :: Nodes
    TYPE(ValueList_t), POINTER :: Material
    REAL(KIND=dp) :: r,u,v,w,ub, &
         Basis(MaxN), dBasisdx(MaxN,3),DetJ, Normal(3)
    REAL(KIND=dp), TARGET :: x(MaxN), y(MaxN), z(MaxN)
    LOGICAL :: stat, Permutated
    INTEGER :: body_id, k
    REAL(KIND=dp) :: Conductivity(Model % Mesh % MaxElementNodes)
    REAL(KIND=DP), POINTER :: Pwrk(:,:,:)
    REAL(KIND=DP) :: CoeffTensor(3,3,Model % MaxElementNodes), Flow(3)

!-----------------------------------------------------------------------
!   Note that normal flux is calculated on the nodal points only
!   using a single boundary element. The direction of the normal
!   may be different on the nodal point when calculated using 
!   a neighboring boundary element.
!   Thus normal flow calculation is useful only when the boundary 
!   is relatively smooth. Also quadratic elements are recommended.
!   ( added by Antti )
!-----------------------------------------------------------------------

    Tvar => VariableGet( Model % Variables, TRIM(VarName) )

    Permutated = ASSOCIATED(Tvar % Perm)
    Element => Model % CurrentElement
    
    IF ( FluxBody > 0 ) THEN
      lbody = 0
      IF ( ASSOCIATED( Element % BoundaryInfo % Left ) ) &
        lbody = Element % BoundaryInfo % Left % BodyId

      rbody = 0
      IF ( ASSOCIATED( Element % BoundaryInfo % Right ) ) &
        rbody = Element % BoundaryInfo % Right % BodyId

      IF ( LBody == FluxBody ) THEN
        Parent => Element % BoundaryInfo % Left
      ELSEIF ( RBody == FluxBody ) THEN
        Parent => Element % BoundaryInfo % Right
      ELSE
        WRITE( Message, * ) 'No such flux integrate body on bc ', &
            Element % BoundaryInfo % Constraint
        CALL Fatal( 'SaveLine', Message )
      END IF
    ELSE        
      Parent => Element % BoundaryInfo % Left
      stat = ASSOCIATED( Parent )

      IF(Permutated) THEN
        IF(stat) stat = ALL(TVar % Perm(Parent % NodeIndexes) > 0)
        
        IF ( .NOT. stat ) THEN
          Parent => ELement % BoundaryInfo % Right
          
          stat = ASSOCIATED( Parent )
          IF(stat) stat = ALL(TVar % Perm(Parent % NodeIndexes) > 0)
        END IF
      END IF
      IF ( .NOT. stat )  CALL Fatal( 'SaveLine',&
          'No solution available for specified boundary' )
    END IF
    
    OldCurrentElement => Element
    Model % CurrentElement => Parent

    n = Parent % TYPE % NumberOfNodes
    
    Nodes % x => x
    Nodes % y => y
    Nodes % z => z
    Nodes % x(1:n) = Model % Nodes % x(Parent % NodeIndexes)
    Nodes % y(1:n) = Model % Nodes % y(Parent % NodeIndexes)
    Nodes % z(1:n) = Model % Nodes % z(Parent % NodeIndexes)
    
    DO j=1,n
      IF ( node == Parent % NodeIndexes(j) ) EXIT
    END DO

    IF ( node /= Parent % NodeIndexes(j) ) THEN
      CALL Warn('SaveLine','Side node not in parent element!')
    END IF

    CALL GlobalToLocal( u, v ,w , x(j), y(j), z(j), Parent, Nodes )

    stat = ElementInfo( Parent, Nodes, u, v, w, detJ, &
        Basis, dBasisdx )
    weight = detJ
   
    ! Compute the normal of the surface for the normal flux
    DO j = 1, Element % TYPE % NumberOfNodes
      IF ( node == Element % NodeIndexes(j) ) EXIT
    END DO

    IF ( j == 1 ) THEN
      ub = -1.0d0
    ELSEIF ( j == 2 ) THEN
      ub = 1.0d0
    ELSE
      ub = 0.0d0
    END IF

    Normal = Normalvector( Element, ElementNodes, ub, 0.0d0, .TRUE. )

    body_id = Parent % Bodyid
    k = ListGetInteger( Model % Bodies(body_id) % Values,'Material', &
            minv=1, maxv=Model % NumberOFMaterials )
    Material => Model % Materials(k) % Values


    CALL ListGetRealArray( Material, TRIM(CoeffName), Pwrk, n, &
        Parent % NodeIndexes, GotIt )

    CoeffTensor = 0.0d0
    IF(GotIt) THEN
      IF ( SIZE(Pwrk,1) == 1 ) THEN
        DO i=1,3
          CoeffTensor( i,i,1:n ) = Pwrk( 1,1,1:n )
        END DO
      ELSE IF ( SIZE(Pwrk,2) == 1 ) THEN
        DO i=1,MIN(3,SIZE(Pwrk,1))
          CoeffTensor(i,i,1:n) = Pwrk(i,1,1:n)
        END DO
      ELSE
        DO i=1,MIN(3,SIZE(Pwrk,1))
          DO j=1,MIN(3,SIZE(Pwrk,2))
            CoeffTensor( i,j,1:n ) = Pwrk(i,j,1:n)
          END DO
        END DO
      END IF
    END IF
    
    Flow = 0.0d0
    DO j = 1, DIM
      DO k = 1, DIM
        IF(Permutated) THEN
          Flow(j) = Flow(j) + SUM( CoeffTensor(j,k,1:n) * Basis(1:n) ) * &
              SUM( dBasisdx(1:n,k) * TVar % Values(TVar % Perm(Parent % NodeIndexes(1:n))) )
        ELSE
          Flow(j) = Flow(j) + SUM( CoeffTensor(j,k,1:n) * Basis(1:n) ) * &
              SUM( dBasisdx(1:n,k) * TVar % Values(Parent % NodeIndexes(1:n)) ) 
        END IF
      END DO
    END DO

    f1 = Flow(1)
    f2 = Flow(2)
    fn = SUM(Normal(1:DIM) * Flow(1:DIM))

    Model % CurrentElement => OldCurrentElement

  END SUBROUTINE BoundaryFlux



!------------------------------------------------------------------------------
END SUBROUTINE SaveLine
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
! Additional routine for saving material parameters. 
! Written by Thomas Zwinger 
!------------------------------------------------------------------------------

SUBROUTINE SaveMaterials( Model,Solver,dt,TransientSimulation )
  USE Types
  USE Lists
  USE Integration
  USE ElementDescription
  USE SolverUtils

  IMPLICIT NONE
! Types
!------------------------------------------------------------------------------
  TYPE(Solver_t), TARGET :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  TYPE(Solver_t), POINTER :: PointerToSolver
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Element_t),POINTER :: CurrentElement
  TYPE(ValueList_t), POINTER :: Material
  TYPE(Variable_t), POINTER :: Var
  INTEGER :: NoParams, DIM, ParamNo, istat, LocalNodes, body_id, material_id,&
       n, j, i, elementNumber, FieldNodes
  INTEGER, POINTER :: NodeIndexes(:), FieldPerm(:)=>NULL()
  REAL(KIND=dp), POINTER :: LocalParam(:), Field(:)
  CHARACTER(LEN=MAX_NAME_LEN) ::  ParamName(199), Name
  LOGICAL :: SubroutineVisited=.FALSE.,FirstTime=.TRUE., GotCoeff, &
       GotIt, GotOper, GotVar, ExactCoordinates, ParamsExist

  SAVE SubroutineVisited, DIM, LocalNodes, ParamName, NoParams, LocalParam


  CALL Info('SaveMaterials','Saving selected parameters as dofs')


  !-----------------------------------
  ! get pointers to Solver information
  !-----------------------------------
  PointerToSolver => Solver
  IF ( .NOT. ASSOCIATED( PointerToSolver ) ) THEN
    CALL FATAL('SaveMaterials', ' No Solver Pointer associated')
  END IF

  !----------------------------------------
  ! Do these things for the first time only
  !----------------------------------------
  IF(.NOT.SubroutineVisited) THEN
     DIM = CoordinateSystemDimension()
     LocalNodes = Model % NumberOfNodes

     n = Solver % Mesh % MaxElementNodes
     ALLOCATE( LocalParam(n) )

     ! Find out how many variables should we saved
     NoParams = 0
     GotVar = .TRUE.
     ParamsExist = .FALSE.

     DO WHILE(GotVar)  
       NoParams = NoParams + 1
       IF(NoParams < 10) THEN
         WRITE (Name,'(A,I2)') 'Parameter',NoParams
       ELSE IF(NoParams < 100) THEN
         WRITE (Name,'(A,I3)') 'Parameter',NoParams    
       ELSE
         CALL FATAL('SaveMaterials','Number of parameters cannot exceed 99')
       END IF
       ParamName(NoParams) = ListGetString( Solver % Values, TRIM(Name), GotVar )
       IF(GotVar) THEN
         WRITE(Message,'(A,A,A)') TRIM(Name),': ', ParamName(NoParams)
         CALL INFO('SaveMaterials',Message,Level=3)
       END IF
     END DO
     NoParams = NoParams-1

     IF( NoParams == 0) THEN
       CALL WARN( 'SaveMaterials', 'No valid parameters found. Nothing will be written')       
       RETURN
     END IF     
     
     !------------------
     ! Add new Variables
     ! -----------------
     DO ParamNo = 1, NoParams
       Var => VariableGet( Model % Variables, TRIM(ParamName(ParamNo)), .TRUE.)     
       IF(.NOT. ASSOCIATED( Var ) ) THEN
         ALLOCATE(Field(LocalNodes))
         Field = 0._dp
         CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, PointerToSolver, &
             TRIM(ParamName(ParamNo)), 1, Field, FieldPerm )         
         NULLIFY( Field ) 
       END IF
     END DO

    !------------------------------------------------
    ! Check that parameter is given in some material
    !------------------------------------------------
     DO i=1,NoParams
       GotIt = .FALSE.
       DO j=1,Model % NumberOfMaterials
         Material => Model % Materials(j) % Values
         IF( ListCheckPresent( Material, TRIM(ParamName(i)) ) ) THEN
           GotIt = .TRUE.
           EXIT
         END IF
       END DO
       IF(.NOT. GotIt) THEN
         CALL Warn('SaveMaterials','Parameter '//TRIM(ParamName(i))//' not present in any material')
       ELSE
         ParamsExist = .TRUE.
       END IF
     END DO

     IF( .NOT. ParamsExist ) THEN
       CALL WARN( 'SaveMaterials', 'Parameters are not to be found. Nothing will be written')       
       RETURN
     END IF     

     SubroutineVisited = .TRUE.
   END IF


  !-----------------------------------
  ! loop all parameters to be exported
  !-------------------------------------
  DO i=1,NoParams 
    
    Var => VariableGet( Model % Variables, TRIM(ParamName(i)), .TRUE.)     
    Field => Var % Values
    FieldPerm => Var % Perm

    DO elementNumber=1,Solver % Mesh % NumberOfBulkElements

      CurrentElement => Solver % Mesh % Elements(elementNumber)
      n = CurrentElement % TYPE % NumberOfNodes
      NodeIndexes => CurrentElement % NodeIndexes

      IF( ASSOCIATED( FieldPerm ) ) THEN
        IF( .NOT. ALL(FieldPerm(NodeIndexes) > 0) ) CYCLE
      END IF


      Model % CurrentElement => CurrentElement
      body_id = CurrentElement % BodyId
      material_id = ListGetInteger( Model % Bodies(body_id) % Values, 'Material' )
      Material => Model % Materials(material_id) % Values

      LocalParam(1:n) = ListGetReal(Material, TRIM(ParamName(i)), n, NodeIndexes, GotIt)
      IF(.NOT. GotIt) CYCLE

      IF( ASSOCIATED( FieldPerm ) ) THEN
        Field(FieldPerm(NodeIndexes(1:n))) = LocalParam(1:n)      
      ELSE
        Field(NodeIndexes(1:n)) = LocalParam(1:n)      
      END IF

    END DO
  END DO


  CALL Info('SaveMaterials','All done')



END SUBROUTINE SaveMaterials



!------------------------------------------------------------------------------
! Additional routine for saving boundary values 
!------------------------------------------------------------------------------
SUBROUTINE SaveBoundaryValues( Model,Solver,dt,TransientSimulation )
  USE Types
  USE Lists
  USE Integration
  USE ElementDescription
  USE SolverUtils
  USE DefUtils

  IMPLICIT NONE
! Types
!------------------------------------------------------------------------------
  TYPE RealPointerList_t
     REAL(KIND=dp), DIMENSION(:), POINTER :: var
  END TYPE RealPointerList_t
!------------------------------------------------------------------------------
  TYPE(Solver_t), TARGET :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  TYPE(Solver_t), POINTER :: PointerToSolver
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Element_t),POINTER :: BoundaryElement
  TYPE(ValueList_t), POINTER :: BC
  TYPE(Variable_t), POINTER :: Var
  TYPE(RealPointerList_t), POINTER :: PPParam(:)

  INTEGER :: NoParams, DIM, ParamNo, istat, LocalNodes, bc_id,&
       n, j, i, t
  INTEGER, POINTER :: NodeIndexes(:)
  REAL(KIND=dp), POINTER :: PParam(:), LocalParam(:)
  
  CHARACTER(LEN=MAX_NAME_LEN) ::  ParamName(99), Name
  LOGICAL :: SubroutineVisited=.FALSE.,FirstTime=.TRUE., GotCoeff, &
       GotIt, GotOper, GotVar, ExactCoordinates, ParamsExist

  SAVE SubroutineVisited, DIM, LocalNodes, ParamName, NoParams, &
       LocalParam, PPParam


  CALL Info('SaveBoundaryValues','Saving selected boundary values as dofs')

  !-----------------------------------
  ! get pointers to Solver information
  !-----------------------------------
  PointerToSolver => Solver

  IF ( .NOT. ASSOCIATED( PointerToSolver ) ) THEN
    CALL FATAL('SaveBoundaryValues', ' No Solver Pointer associated')
  END IF

  !----------------------------------------
  ! Do these things for the first time only
  !----------------------------------------
  IF(.NOT.SubroutineVisited) THEN
     DIM = CoordinateSystemDimension()
     n = Solver % Mesh % MaxElementNodes
     ALLOCATE( LocalParam(n) )

     LocalNodes = Model % NumberOfNodes
     NoParams = 0
     GotVar = .TRUE.
     ParamsExist = .FALSE.

     DO WHILE(GotVar)  
       NoParams = NoParams + 1
       IF(NoParams < 10) THEN
         WRITE (Name,'(A,I2)') 'Parameter',NoParams
       ELSE IF(NoParams < 100) THEN
         WRITE (Name,'(A,I3)') 'Parameter',NoParams    
       ELSE
         CALL FATAL('SaveBoundaryValues','Number of parameters cannot exceed 99')
       END IF
       ParamName(NoParams) = ListGetString( Solver % Values, TRIM(Name), GotVar )
       IF(GotVar) THEN
          WRITE(Message,'(A,A,A)') TRIM(Name),': ', ParamName(NoParams)
          CALL INFO('SaveBoundaryValues',Message,Level=3)
       END IF
     END DO
     NoParams = NoParams-1

     IF( NoParams == 0) THEN
       CALL WARN( 'SaveBoundaryValues', 'No valid parameters found. Nothing will be written')       
       RETURN
     END IF     

     ! --------------------------------------------
     ! Allocate space for new variables to be added
     ! --------------------------------------------
     ALLOCATE( PPParam(NoParams),  STAT=istat )
     IF (istat /= 0) CALL FATAL('SaveBoundaryValues', 'Allocation Error')
     SubroutineVisited = .TRUE.

     !------------------
     ! Add new Variables
     ! -----------------
     DO ParamNo = 1, NoParams
       ALLOCATE( PParam(LocalNodes) )
       PParam = 0._dp
       CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, PointerToSolver, &
             TRIM(ParamName(ParamNo)), 1, PParam )
     END DO

    !------------------------------------------------
    ! Check that parameter is given in some material
    !------------------------------------------------
    DO i=1,NoParams
      GotIt = .FALSE.
      DO j=1,Model % NumberOfBCs
        BC => Model % BCs(j) % Values
        IF( ListCheckPresent( BC, TRIM(ParamName(i)) ) ) THEN
          GotIt = .TRUE.
          EXIT
        END IF
      END DO
      IF(.NOT. GotIt) THEN
        CALL Warn('SaveBoundaryValues','Parameter '//TRIM(ParamName(i))//' not present in any BCs')
      ELSE
        ParamsExist = .TRUE.
      END IF
    END DO

  END IF

  !------------------------------------------
  ! Assign Pointer Variables 
  !------------------------------------------
  DO i=1,NoParams  
     Var => VariableGet( Model % Variables, TRIM(ParamName(i)), .TRUE.)     
     PPParam(i) % var => Var % Values
  END DO
  !-----------------------------------
  ! Loop all active elements of solver
  !------------------------------------------------------


  DO t=1,Solver % Mesh % NumberOfBoundaryElements     
     BoundaryElement => GetBoundaryElement(t)
     !------------------------------------------------------------------
     ! do nothing, if we are dealing with a halo-element in parallel run
     !------------------------------------------------------------------
     IF (BoundaryElement % PartIndex .NE. Parenv % mype) CYCLE

     !--------------------------------
     ! get some information on element
     !--------------------------------    
     Model % CurrentElement => BoundaryElement
     NodeIndexes => BoundaryElement % NodeIndexes
     n = GetElementNOFNodes(BoundaryElement)

     BC => GetBC()
     bc_id = GetBCId( BoundaryElement )
     IF ( .NOT.ASSOCIATED( BC ) ) CYCLE
    
     !-----------------------------------
     ! loop all parameters to be exported
     !-------------------------------------
     DO i=1,NoParams        
       LocalParam(1:n) = ListGetReal(BC, TRIM(ParamName(i)), n, NodeIndexes, GotIt)
       IF( GotIt ) PPParam(i) % var(NodeIndexes(1:n)) = LocalParam(1:n)
     END DO

  END DO

  CALL Info('SaveBoundaryValues','All done')
  
END SUBROUTINE SaveBoundaryValues







