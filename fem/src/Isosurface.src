!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Module for extracting isosurfaces in 3d / isolines in 2d
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen
! *  Email:   jpr@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 20.06.2007
! *
! *****************************************************************************/

!------------------------------------------------------------------------------
  SUBROUTINE IsosurfaceSolver_Init( Model,Solver,dt,Transient )
!------------------------------------------------------------------------------
    USE DefUtils

    TYPE(Model_t)  :: Model
    TYPE(Solver_t) :: Solver
    REAL(KIND=dp) :: DT
    LOGICAL :: Transient
!------------------------------------------------------------------------------
    INTEGER :: dim
    TYPE(ValueList_t), POINTER :: SolverParams
!------------------------------------------------------------------------------
    SolverParams => GetSolverParams()

!------------------------------------------------------------------------------
  END SUBROUTINE IsosurfaceSolver_Init
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
SUBROUTINE IsosurfaceSolver( Model,Solver,dt,Transient )
!------------------------------------------------------------------------------

  USE CoordinateSystems
  USE DefUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
!******************************************************************************
!
!  Search isosurfaces
!
!  ARGUMENTS:
!
!  TYPE(Model_t) :: Model,  
!     INPUT: All model information (mesh,materials,BCs,etc...)
!
!  TYPE(Solver_t) :: Solver
!     INPUT: Linear equation solver options
!
!  REAL(KIND=dp) :: dt,
!     INPUT: Timestep size for time dependent simulations (NOTE: Not used
!            currently)
!
!******************************************************************************

  TYPE(Model_t)  :: Model
  TYPE(Solver_t), TARGET :: Solver
  LOGICAL ::  Transient
  REAL(KIND=dp) :: dt
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------
  CHARACTER(LEN=MAX_NAME_LEN) :: LevelVariableName
  TYPE(Mesh_t), POINTER :: Mesh, IsoMesh => Null(), Pmesh
  INTEGER :: i,j,k,l,n, dim,NoLevels,Level
  REAL(KIND=dp) :: LevelValue, LevelDiff

  INTEGER, TARGET :: TetraToTetraMap(1,4), PyramidToTetraMap(2,4), &
             WedgeToTetraMap(3,4), BrickToTetraMap(5,4), &
             TriangleToTriangleMap(1,3), QuadToTriangleMap(2,3)
  INTEGER, POINTER :: Map(:,:), Indexes(:)
  INTEGER :: SaveNOFBulk,calls=0

  TYPE(Variable_t), POINTER :: LevelVariable
  LOGICAL :: CreateNewMesh, ElementsAllocated, Found
  LOGICAL, ALLOCATABLE :: ElemSplit(:)
  INTEGER, ALLOCATABLE :: eperm(:), ElemPerm(:)
  INTEGER :: NewElemType, NewElemNodes, LevelDofs, NoEdges
  REAL(KIND=dp), ALLOCATABLE :: x(:),y(:),z(:),ElemFun(:)
  REAL(KIND=dp), POINTER :: LevelFun(:), LevelValues(:,:)
  INTEGER, POINTER :: LevelPerm(:)
  TYPE(Element_t), POINTER  :: SaveElements(:), NewElements(:), Element
  TYPE(ValueList_t), POINTER :: Params

 
  CALL Info( 'IsosurfaceSolver','-------------------------------------',Level=4 )
  CALL Info( 'IsosurfaceSolver','Determining the isosurface',Level=4 )
  CALL Info( 'IsosurfaceSolver','-------------------------------------',Level=4 )

  Mesh => GetMesh()
  dim = Mesh % MeshDim

  ! this is just a temporary hack to live with old library
  IF(dim < 1 .OR. dim > 3 ) dim = 3

  Params => GetSolverParams()

  LevelVariableName = GetString( Params,'Isosurface Variable')
  LevelVariable => VariableGet( Mesh % Variables, LevelVariableName )

  IF (.NOT.ASSOCIATED(LevelVariable)) THEN
    CALL Error( 'Isosurface', 'The isosurface variable: ' // &
        TRIM(LevelVariableName) // ' not present' )
    RETURN
  END IF
  
  n = Mesh % MaxElementNodes
  ALLOCATE(ElemFun(n), ElemPerm(n))

  Levelfun => LevelVariable % Values
  LevelPerm => LevelVariable % Perm
  LevelDofs = LevelVariable % Dofs

  !---------------------------------------------------------------
  ! Map any element to tetrahedron or triangle
  !---------------------------------------------------------------
  TetraToTetraMap(1,:) = [1,2,3,4]

  PyramidToTetraMap(1,:) = [3,5,4,1]
  PyramidToTetraMap(2,:) = [3,5,2,1]

  WedgeToTetraMap(1,:) = [5,4,3,1]
  WedgeToTetraMap(2,:) = [5,3,2,1]
  WedgeToTetraMap(3,:) = [5,6,4,3]

  BrickToTetraMap(1,:) = [1,2,4,5]
  BrickToTetraMap(2,:) = [6,7,2,5]
  BrickToTetraMap(3,:) = [3,4,2,7]
  BrickToTetraMap(4,:) = [8,7,5,4]
  BrickToTetraMap(5,:) = [2,4,5,7]

  TriangleToTriangleMap(1,:) = [1,2,3]
  QuadToTriangleMap(1,:) = [1,2,3]
  QuadToTriangleMap(2,:) = [1,3,4]

  !---------------------------------------------------------------
  ! Check whether mesh is all-tets or all-triangles
  !---------------------------------------------------------------
  CreateNewMesh = .FALSE.
  DO i=1,Mesh % NumberOfBulkElements
    Element => Mesh % Elements( i ) 
    j = GetElementFamily( Element )
    IF( dim == 2 .AND. j /= 3 ) THEN
      CreateNewMesh = .TRUE.
      EXIT
    END IF
    IF( dim == 3 .AND. j /= 5 ) THEN
      CreateNewMesh = .TRUE.
      EXIT
    END IF
  END DO

  IF( dim == 2 ) THEN
    NewElemType = 303
    NewElemNodes = 3
  ELSE
    NewElemType = 504
    NewElemNodes = 4
  END IF

  !---------------------------------------------------------------
  ! Check the isosurface values
  !---------------------------------------------------------------
  NoLevels = 0
  LevelValues => ListGetConstRealArray( Params,'Isosurface values',Found)
  IF( Found ) THEN
    NoLevels = SIZE(LevelValues,1)
    LevelValue = LevelValues(1,1)
  ELSE
    LevelValue = ListGetCReal( Params,'Isosurface value',Found)
    IF( Found ) NoLevels = 1
  END IF

  IF(.NOT. Found ) THEN
    CALL Warn('IsosurfaceSolver','Could not determine Isosurface value')
    RETURN
  END IF

  !---------------------------------------------------------------
  ! Create a temporary mesh consisting only of tets (or triangles)
  ! in where the isosurface (or isoline) will be determined.
  ! The temporal mesh includes only potential master elements.
  !---------------------------------------------------------------
  IF ( CreateNewMesh ) THEN
    CALL Info('IsoSurfaceSolver','Creating a temporal mesh')

    SaveNOFBulk = Mesh % NumberOfBulkElements
    SaveElements => Mesh % Elements
    ElementsAllocated = .FALSE.
    
    WRITE ( Message,'(A,I0)') 'Size of initial mesh is ',SaveNOFBulk
    CALL Info('IsosurfaceSolver',Message)

    IF( NoLevels > 1 ) ALLOCATE( ElemSplit( Mesh % NumberOfBulkElements ) )

100 j = 0
    IF( NoLevels > 1 ) ElemSplit = .FALSE.

    DO Level = 1, NoLevels
      IF( NoLevels > 1 ) LevelValue = LevelValues(Level,1) 

      DO i=1,Mesh % NumberOfBulkElements
        Element => Mesh % Elements(i)
        Indexes => Element % NodeIndexes
	n = Element % TYPE % NumberOfNodes
        
        IF( NoLevels > 1 ) THEN
          IF( ElemSplit(i) ) CYCLE
        END IF

	IF( ASSOCIATED( LevelPerm ) ) THEN
	  ElemPerm(1:n) = LevelPerm( Indexes ) 
          IF( ANY ( LevelPerm( Indexes) == 0 ) ) CYCLE
        ELSE 
   	  ElemPerm(1:n) = Indexes(1:n)
        END IF        

        SELECT CASE(GetElementFamily( Element ))
        CASE(3); Map => TriangleToTriangleMap
        CASE(4); Map => QuadToTriangleMap
        CASE(5); Map => TetraToTetraMap
        CASE(6); Map => PyramidToTetraMap
        CASE(7); Map => WedgeToTetraMap
        CASE(8); Map => BrickToTetraMap
        END SELECT
        
	IF( LevelDofs == 1 ) THEN
          ElemFun(1:n) =  LevelFun( ElemPerm(1:n) )
	ELSE
          ElemFun(1:n) = 0.0_dp
          DO l=1,MIN(dim,LevelDofs)
            ElemFun(1:n) = ElemFun(1:n) + LevelFun( LevelDofs * ( ElemPerm(1:n) - 1) + l )**2
          END DO
          ElemFun(1:n) = SQRT( ElemFun(1:n) )
        END IF
        ElemFun(1:n) = ElemFun(1:n) - LevelValue

        IF( ALL ( ElemFun(1:n) < 0.0_dp ) ) CYCLE
        IF( ALL ( ElemFun(1:n) > 0.0_dp ) ) CYCLE

        IF( NoLevels > 1 ) THEN
          IF( ElemSplit(i) ) CYCLE
        END IF
        
        IF( .NOT. ElementsAllocated ) THEN
          j = j + SIZE(Map,1)
          CYCLE
        END IF

        DO k=1,SIZE(Map,1)
          j = j + 1
          NewElements(j) = Element
          NewElements(j) % TYPE => GetElementType(NewElemType)
          ALLOCATE(NewElements(j) % NodeIndexes(NewElemNodes))
          DO l=1,NewElemNodes
            NewElements(j) % NodeIndexes(l) = &
                Element % NodeIndexes(Map(k,l))
          END DO
        END DO
      END DO      
    END DO

    IF( .NOT. ElementsAllocated ) THEN
      IF( j > 0 ) THEN
        ALLOCATE(NewElements(j))
        ElementsAllocated = .TRUE.      
	GOTO 100
      END IF
    END IF

    IF( j > 0 ) THEN
      Mesh % NumberOfBulkElements = j
      Mesh % Elements => NewElements
     END IF

    IF( NoLevels > 1 ) DEALLOCATE( ElemSplit ) 
  END IF


  k = NINT( ParallelReduction( 1.0_dp * j ) )
  WRITE ( Message,'(A,I0,A)') 'Created temporal mesh with ',&
          k,' elements'
  CALL Info('IsosurfaceSolver',Message)


  ! Find mesh edges in order to define the intersection points
  !-----------------------------------------------------------
  IF( j > 0 ) THEN
    IF (.NOT.ASSOCIATED(Mesh % Edges)) THEN
      IF( dim == 2 ) THEN
        CALL FindMeshEdges2D(Mesh)
      ELSE
        CALL FindMeshEdges3D(Mesh)
      END IF     
    END IF
    NoEdges = Mesh % NumberOfEdges
  ELSE
    NoEdges = 0
  END IF 

  ! If the mesh was previously created release it before recreating
  !----------------------------------------------------------------
  IF(ASSOCIATED(IsoMesh)) THEN
    Pmesh => Model % Meshes
    DO WHILE(ASSOCIATED(Pmesh % Next))
      IF ( ASSOCIATED(Pmesh % next, Isomesh)) THEN
        Pmesh % next => Isomesh % Next
        EXIT
      END IF
    END DO
    CALL ReleaseMesh(Isomesh)
  END IF
  
  Isomesh => AllocateMesh()
  IsoMesh % Name = GetString( Params,'Mesh Name', Found )
  IF (.NOT. Found ) THEN
    IF( dim == 2 ) THEN
      IsoMesh % Name = "isoline"
    ELSE
      IsoMesh % Name = "isosurf"
    END IF
  END IF
  
  IF( GetLogical(Params,'Mesh Numbering',Found) ) THEN
    Calls = Calls + 1
    Isomesh % name = TRIM(Isomesh % name) // TRIM(i2s(calls))
  END IF
  CALL MakeDirectory( TRIM(Isomesh % name) // CHAR(0) )

  Isomesh % Changed = .TRUE.
  Isomesh % OutputActive  = .TRUE.

  CALL CreateNodes()
  IF( j > 0 ) THEN
    CALL CreateSurfaces()
    IF ( CreateNewMesh ) THEN
      DEALLOCATE( NewElements )
      Mesh % NumberOfBulkElements = SaveNOFBulk
      Mesh % Elements => SaveElements
    END IF
  ELSE
    Isomesh % NumberOfBulkElements = 0
    Isomesh % NumberOfNodes = 0
  END IF

  Mesh => Model % Meshes
  DO WHILE( ASSOCIATED(Mesh % Next) )
    Mesh => Mesh % Next
  END DO
  Mesh % Next => Isomesh 
  
  IF( j > 0 ) CALL ReleaseMeshEdgeTables(Mesh)
  DEALLOCATE( ElemFun, ElemPerm )  

  j = Isomesh % NumberOfBulkElements
  k = NINT( ParallelReduction( 1.0_dp * j ) )
  IF( dim == 3 ) THEN
    WRITE ( Message,'(A,I0,A)') 'Isosurfaces created with ',&
        k,' elements'
  ELSE
    WRITE ( Message,'(A,I0,A)') 'Isolines created with ',&
        k,' elements'        
  END IF
  CALL Info('IsosurfaceSolver',Message)
  

CONTAINS

  !----------------------------------------------------------------
  ! Create nodes for the isosurface / isoline
  !----------------------------------------------------------------
  SUBROUTINE CreateNodes()

    TYPE(Element_t), POINTER :: Edge
    INTEGER :: i,j,k,l,n1,n2,m1,m2,ints,comps
    REAL(KIND=dp) :: t,t1,t2,x1,x2,y1,y2,z1,z2

    CHARACTER(LEN=MAX_NAME_LEN) :: Vname(32)
    LOGICAL :: Found
    TYPE(Variable_t), POINTER :: V
    INTEGER, POINTER :: Vperm(:)
    REAL(KIND=dp), POINTER :: Vals(:), dummy(:)

    TYPE Varr_t
       REAL(KIND=dp), POINTER :: Vals(:)
    END TYPE Varr_t
    TYPE(Varr_t), POINTER :: Varr(:)

    ! Make a table of the field variables and allocate space
    !----------------------------------------------------------------
    ints = 0
    DO WHILE(.TRUE.)
      ints = ints+1
      Vname(ints) = GetString( GetSolverParams(), &
          ComponentName('Isosurface interpolant',ints), Found )
      IF(.NOT. Found) Vname(ints) = GetString( GetSolverParams(), &
          ComponentName('Variable',ints), Found )
      IF ( .NOT. Found ) THEN
        ints = ints-1
        EXIT
      END IF
    END DO

    ! For parallel runs create the variables even though they do not exist since they 
    ! will in other partitions.
    !--------------------------------------------------------------------------------

    n = NoEdges
    IF( n == 0 ) THEN
      IF ( ints > 0 .AND. ParEnv % PEs > 1 ) THEN
        DO i=1,ints
          V => VariableGet( Mesh % Variables, Vname(i) )
          NULLIFY( Vperm, Vals )
          ALLOCATE( Vperm(1),Vals(V % DOFs) )
          Vperm = 0
          Vals = 0.0_dp
          CALL Info('IsoSurfaceSolver','Creating dummy variable '//TRIM( Vname(i) ) )
          CALL VariableAddVector( Isomesh % Variables, Isomesh, Solver, &
               TRIM(Vname(i)), V % DOFs, Vals, Vperm )
        END DO
      END IF
      RETURN
    END IF

    ALLOCATE(x(n), y(n), z(n), eperm(n) )
    x = 0; y = 0; z = 0; eperm = 0;

    IF ( ints > 0 ) THEN
      ALLOCATE(Varr(ints))
      DO i=1,ints
        V => VariableGet( Mesh % Variables, Vname(i) )
        IF ( ASSOCIATED(V) ) THEN
          ALLOCATE(Varr(i) % vals(n*V%DOFs))
          Varr(i) % Vals = 0._dp
        END IF
      END DO
    END IF

    ! Loop over edges and check for different signs
    !----------------------------------------------------------------
    j = 0


    DO Level = 1, NoLevels
      IF( NoLevels > 1 ) LevelValue = LevelValues(Level,1) 

      DO i=1,n
        Edge => Mesh % Edges(i)

        n1 = Edge % NodeIndexes(1)
        n2 = Edge % NodeIndexes(2)
        
	IF( ASSOCIATED( LevelPerm ) ) THEN
          m1 = LevelPerm( n1 )
          m2 = LevelPerm( n2 )
        ELSE
          m1 = n1
          m2 = n2
        END IF    
    
        IF ( m1 <= 0 .OR. m2 <= 0 ) CYCLE
        
	IF( LevelDofs == 1 ) THEN
	  t1 = LevelFun( m1 ) 
	  t2 = LevelFun( m2 ) 
        ELSE
	  t1 = 0.0_dp
          t2 = 0.0_dp
          DO k=1,MIN(dim,LevelDofs)
            t1 = t1 + LevelFun( LevelDofs*(m1-1) + k )**2
            t2 = t2 + LevelFun( LevelDofs*(m2-1) + k )**2
          END DO
	  t1 = SQRT( t1 )
	  t2 = SQRT( t2 )
        END IF

        t1 = t1 - LevelValue
        t2 = t2 - LevelValue
        
        IF( ABS( t1 - t2 ) < TINY( t1 ) ) CYCLE
        IF ( t1 * t2 > 0.0_dp ) CYCLE
        
        x1 = Mesh % Nodes % x(n1)
        x2 = Mesh % Nodes % x(n2)
        
        y1 = Mesh % Nodes % y(n1)
        y2 = Mesh % Nodes % y(n2)
        
        z1 = Mesh % Nodes % z(n1)
        z2 = Mesh % Nodes % z(n2)
        
        t = ABS( t1/(t2-t1) )
        j = j + 1

        IF( j > n ) THEN
          CALL Fatal('CreateNodes','Too many nodes on isosurface')
        END IF

        eperm(i) = j
        x(j) = (1-t) * x1 + t * x2
        y(j) = (1-t) * y1 + t * y2
        z(j) = (1-t) * z1 + t * z2
                
        DO k=1,ints
          V => VariableGet(Mesh % Variables, Vname(k))
          IF (ASSOCIATED(V)) THEN
            DO l=1,V % DOFs
              IF ( V % Perm(n1) > 0 .AND. V % Perm(n2) > 0 ) THEN
                x1 = V % Values(V % DOFs*(V % Perm(n1)-1)+l)
                x2 = V % Values(V % DOFs*(V % Perm(n2)-1)+l)
                Varr(k) % Vals(V % DOFs*(j-1)+l) = (1-t)*x1 + t*x2
              END IF
            END DO
          END IF
        END DO
      END DO
    END DO

    ALLOCATE( IsoMesh % Nodes )
    Isomesh % NumberOfNodes = j
    Isomesh % Nodes % NumberOfNodes = j

    ALLOCATE( IsoMesh % Nodes % x(j) )
    ALLOCATE( IsoMesh % Nodes % y(j) )
    ALLOCATE( IsoMesh % Nodes % z(j) )

    IsoMesh % Nodes % x = x(1:j)
    IsoMesh % Nodes % y = y(1:j)
    IsoMesh % Nodes % z = z(1:j)
    DEALLOCATE(x,y,z)

    CALL VariableAdd( IsoMesh % Variables, IsoMesh,Solver, &
       'Coordinate 1',1,IsoMesh % Nodes % x )

    CALL VariableAdd( IsoMesh % Variables,IsoMesh,Solver, &
       'Coordinate 2',1,IsoMesh % Nodes % y )

    CALL VariableAdd( IsoMesh % Variables,IsoMesh,Solver, &
       'Coordinate 3',1,IsoMesh % Nodes % z )

    V => VariableGet( Mesh % Variables, 'Time' )
    CALL VariableAdd( Isomesh % Variables, Isomesh, Solver, 'Time', 1, &
        V % Values )

    IF ( ints > 0 ) THEN
      DO k=1,ints
        V => VariableGet( Mesh % Variables, Vname(k) )
        IF (ASSOCIATED(V)) THEN
          NULLIFY( Vperm, Vals )
          ALLOCATE( Vperm(j),Vals(V % DOFs*j) )
          Vperm = [(i,i=1,j)]
          Vals = Varr(k) % Vals(1:V % DOFs*j)
          DEALLOCATE( Varr(k) % Vals )
          CALL Info('IsoSurfaceSolver','Creating variable '//TRIM( Vname(k) ) )
          CALL VariableAddVector( Isomesh % Variables, Isomesh, Solver, &
               TRIM(Vname(k)), V % DOFs, Vals, Vperm )
        END IF
      END DO
      DEALLOCATE(Varr)
    END IF
  END SUBROUTINE CreateNodes


  !----------------------------------------------------------------
  ! Create the isosurfaces or isolines
  !----------------------------------------------------------------
  SUBROUTINE CreateSurfaces()
     TYPE(Element_t), POINTER :: Element, DefElement
     REAL(KIND=dp) :: F(4)
     INTEGER :: i,j,k,n,Triangles(2,3),Line(2)
     INTEGER :: NewElemType, NewElemNodes
     LOGICAL :: SurfaceAllocated 

     IF( dim == 3 ) THEN
       NewElemType = 303
       NewElemNodes = 3
     ELSE
       NewElemType = 202
       NewElemNodes = 2
     END IF

     SurfaceALlocated = .FALSE.

100  k = 0

     DO Level = 1, NoLevels
       IF( NoLevels > 1 ) LevelValue = LevelValues(Level,1) 
       
       DO i=1,Mesh % NumberOfBulkElements
         Element => Mesh % Elements(i)
	 n = Element % TYPE % NumberOfNodes

         IF( ASSOCIATED( LevelPerm ) ) THEN
           ElemPerm(1:n) = LevelPerm(Element % NodeIndexes)
         ELSE
           ElemPerm(1:n) = Element % NodeIndexes
         END IF

         IF( LevelDofs == 1 ) THEN
           F(1:n) = LevelFun( ElemPerm(1:n) )
         ELSE
	   F(1:n) = 0.0_dp
           DO j=1,MIN(dim,LevelDofs)
             F(1:n) = F(1:n) + LevelFun( LevelDofs*(ElemPerm(1:n)-1)+j)**2
           END DO 
           F(1:n) = SQRT( F(1:n) ) 
         END IF
	 F(1:n) = F(1:n) - LevelValue


         IF( dim == 2 ) THEN
           IF( CreateLineFromTriangle(Element,F,Line) ) THEN
             k = k + 1
             IF( SurfaceAllocated) THEN
               Isomesh % Elements(k) % NodeIndexes = Line
               Isomesh % Elements(k) % BodyId = Level
             END IF
           END IF
         ELSE
           n = CreateSurfaceFromTetra(Element,F,Triangles)
           DO j=1,n
             IF ( ALL (Triangles(j,:) > 0 ) ) THEN
               k = k + 1
               IF( SurfaceAllocated ) THEN
                 Isomesh % Elements(k) % NodeIndexes = Triangles(j,:)
                 Isomesh % Elements(k) % BodyId = Level
               END IF
             END IF
           END DO
         END IF
       END DO
     END DO

     IF( .NOT. SurfaceAllocated ) THEN

       ALLOCATE( Isomesh % Elements(k) )
       SurfaceAllocated = .TRUE.
       
       Isomesh % MeshDim = dim 
       Isomesh % NumberOfBulkElements = k
       Isomesh % NumberOfFaces = 0
       Isomesh % NumberOfEdges = 0
       Isomesh % NumberOfBoundaryElements = 0
       
       DefElement => AllocateElement()
       DO i=1,k
         Isomesh % Elements(i) = DefElement
         Isomesh % Elements(i) % TYPE => GetElementType(NewElemType)
         ALLOCATE(Isomesh % Elements(i) % NodeIndexes(NewElemNodes))
       END DO

       GOTO 100
     END IF

     DEALLOCATE(DefElement)      


     
  END SUBROUTINE CreateSurfaces


  !----------------------------------------------------------------
  ! Create isosurfaces related to one tetrahedral element
  !----------------------------------------------------------------
  FUNCTION CreateSurfaceFromTetra(Tetra,F,Surf) RESULT(scount)
    TYPE(Element_t) :: Tetra
    REAL(KIND=dp) :: F(4)
    INTEGER :: scount, Surf(2,3)

    LOGICAL :: S1,S2,S3,S4
    INTEGER :: S,H,i,j,l,Indexes(6)

    scount = 0
    Indexes = eperm(Tetra % EdgeIndexes)

    S1 = F(1) > 0.0_dp;
    S2 = F(2) > 0.0_dp;
    S3 = F(3) > 0.0_dp;
    S4 = F(4) > 0.0_dp;

    S = 0
    IF ( S1 ) S = S + 1
    IF ( S2 ) S = S + 1
    IF ( S3 ) S = S + 1
    IF ( S4 ) S = S + 1

    IF ( S==0 .OR. S==4 ) RETURN

    IF ( S==1 .OR. S==3 ) THEN
      scount = 1
      IF ( (S==1 .AND. S1) .OR. (S==3 .AND. .NOT.S1) ) THEN
        Surf(1,1) = Indexes(1)
        Surf(1,2) = Indexes(3)
        Surf(1,3) = Indexes(4)
      ELSE IF ( (S==1 .AND. S2) .OR. (S==3 .AND. .NOT.S2) ) THEN
        Surf(1,1) = Indexes(1)
        Surf(1,2) = Indexes(2)
        Surf(1,3) = Indexes(5)
      ELSE IF ( (S==1 .AND. S3) .OR. (S==3 .AND. .NOT.S3) ) THEN
        Surf(1,1) = Indexes(2)
        Surf(1,2) = Indexes(3)
        Surf(1,3) = Indexes(6)
      ELSE IF ( (S==1 .AND. S4) .OR. (S==3 .AND. .NOT.S4) ) THEN
        Surf(1,1) = Indexes(4)
        Surf(1,2) = Indexes(5)
        Surf(1,3) = Indexes(6)
      ELSE
        scount=0
      END IF
    ELSE
      scount = 2
      IF ( (S1 .AND. S2) .OR. (.NOT.S1 .AND. .NOT.S2) ) THEN
        Surf(1,1) = Indexes(3)
        Surf(1,2) = Indexes(2)
        Surf(1,3) = Indexes(5)

        Surf(2,1) = Indexes(3)
        Surf(2,2) = Indexes(5)
        Surf(2,3) = Indexes(4)
      ELSE IF ( (S1 .AND. S3) .OR. (.NOT.S1 .AND. .NOT.S3) ) THEN
        Surf(1,1) = Indexes(1)
        Surf(1,2) = Indexes(2)
        Surf(1,3) = Indexes(6)

        Surf(2,1) = Indexes(1)
        Surf(2,2) = Indexes(6)
        Surf(2,3) = Indexes(4)
      ELSE IF ( (S1 .AND. S4) .OR. (.NOT.S1 .AND. .NOT.S4) ) THEN
        Surf(1,1) = Indexes(1)
        Surf(1,2) = Indexes(5)
        Surf(1,3) = Indexes(6)

        Surf(2,1) = Indexes(1)
        Surf(2,2) = Indexes(6)
        Surf(2,3) = Indexes(3)
      ELSE
        scount=0
      END IF
    END IF

  END FUNCTION CreateSurfaceFromTetra

  
  !----------------------------------------------------------------
  ! Create isoline related to one triangular element
  !----------------------------------------------------------------
  FUNCTION CreateLineFromTriangle(Triangle,F,Line) RESULT(GotLine)
    TYPE(Element_t) :: Triangle
    REAL(KIND=dp) :: F(3)
    INTEGER :: Line(2)
    LOGICAL :: GotLine

    LOGICAL :: S1,S2,S3
    INTEGER :: S,H,i,j,l,Indexes(3)

    GotLine = .FALSE.
    Indexes = eperm(Triangle % EdgeIndexes)

    S1 = F(1) > 0.0_dp;
    S2 = F(2) > 0.0_dp;
    S3 = F(3) > 0.0_dp;

    S = 0
    IF ( S1 ) S = S + 1
    IF ( S2 ) S = S + 1
    IF ( S3 ) S = S + 1

    IF ( S==0 .OR. S==3 ) RETURN

    GotLine = .TRUE.

    IF ( S == 1 ) THEN
      IF ( S1 ) THEN
        Line(1) = Indexes(1)
        Line(2) = Indexes(3)
      ELSE IF( S2 ) THEN
        Line(1) = Indexes(1)
        Line(2) = Indexes(2)
      ELSE
        Line(1) = Indexes(2)
        Line(2) = Indexes(3)
      END IF
    ELSE
      IF ( .NOT. S1 ) THEN
        Line(1)=Indexes(1)
        Line(2)=Indexes(3)
      ELSE IF( .NOT. S2 ) THEN
        Line(1) = Indexes(1)
        Line(2) = Indexes(2)
      ELSE
        Line(1) = Indexes(2)
        Line(2) = Indexes(3)
      END IF
    END IF

  END FUNCTION CreateLineFromTriangle

!------------------------------------------------------------------------------
END SUBROUTINE IsosurfaceSolver
!------------------------------------------------------------------------------
