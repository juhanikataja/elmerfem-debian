!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Module defining model type and operations on this type (that was a bold 
! *  statement, at the moment just the Model I/O routines are here ...)
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 01 Oct 1996
! *
! *****************************************************************************/

MODULE ModelDescription

    USE MeshUtils
    USE ElementDescription
    USE BinIO
 
    IMPLICIT NONE

    INTERFACE
      FUNCTION LoadFunction( Quiet,Abort_not_found,Libname,Procname ) RESULT(Proc)
        USE Types
        CHARACTER :: Libname(*),Procname(*)
        INTEGER :: Quiet, Abort_not_found
        INTEGER(KIND=AddrInt) :: Proc
      END FUNCTION LoadFunction
    END INTERFACE

    CHARACTER(LEN=1024) :: IncludePath = ' ', OutputPath = ' ', SimulationId = ' '

    INTEGER, PARAMETER :: PosUnit = 32, OutputUnit = 31, RestartUnit = 30,&
                          PostFileUnit = 29, InFileUnit = 28

    INTEGER, PARAMETER, PRIVATE :: MAX_OUTPUT_VARS = 100

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION GetProcAddr( str, Quiet, Abort ) RESULT( Proc )
!------------------------------------------------------------------------------
    CHARACTER(LEN=*) :: str
    LOGICAL, OPTIONAL :: Quiet, Abort

    INTEGER(KIND=AddrInt) :: Proc
    INTEGER   :: i,j,slen,q,a
    CHARACTER :: Libname(MAX_NAME_LEN),Procname(MAX_NAME_LEN)
!------------------------------------------------------------------------------

    DO slen=LEN(str),1,-1
      IF ( str(slen:slen) /= ' ' ) EXIT
    END DO

    i = 1
    DO WHILE( i <= slen )
      IF ( str(i:i) == ' ' ) EXIT
      Libname(i) = str(i:i)
      i = i + 1
    END DO
    Libname(i) = CHAR(0)

    DO WHILE( i <= slen )
       IF ( str(i:i) /= ' ' ) EXIT
       i = i + 1
    END DO

    j = 1
    DO WHILE( i <= slen )
      IF (  str(i:i) == ' ' ) EXIT
      Procname(j) = str(i:i)
      i = i + 1
      j = j + 1
    END DO
    ProcName(j) = CHAR(0)

    q = 0
    IF ( OutputPE/=0 ) q=1

    IF ( PRESENT(Quiet) ) THEN
       IF ( Quiet ) q = 1
    END IF

    a = 1
    IF ( PRESENT(abort) ) THEN
       IF ( .NOT. abort ) a=0
    END IF

    Proc = LoadFunction( q,a,Libname,Procname )
  END FUNCTION GetProcAddr
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE LoadIncludeFile( Model,InFileUnit,FileName,MeshDir,MeshName,ScanOnly )
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
     TYPE(Model_t) :: Model
     INTEGER :: InFileUnit
     LOGICAL :: ScanOnly
     CHARACTER(LEN=*) :: FileName
     CHARACTER(LEN=*) :: MeshDir,MeshName
!------------------------------------------------------------------------------
     CHARACTER(LEN=MAX_PATH_LEN) :: FName
 
     INTEGER :: k,k0,k1,l
!------------------------------------------------------------------------------

     IF ( .NOT. FileNameQualified(FileName) ) THEN
       k0 = 1
       k1 = INDEX( IncludePath, ';' )
       DO WHILE( k1 >= k0 )
         DO k = k1-1,k0,-1
           IF ( IncludePath(k:k) /= ' ' ) EXIT
         END DO 

         IF ( k >= k0 ) THEN
           WRITE( FName, '(a,a,a)' ) IncludePath(k0:k), '/', &
              TRIM( FileName )
           OPEN( InFileUnit, FILE=TRIM(FName), STATUS='OLD',ERR=10 )
           CALL LoadInputFile( Model, InFileUnit, FName, &
                 MeshDir, MeshName, .FALSE., ScanOnly )
           CLOSE( InFileUnit )
           RETURN
         END IF

10       CONTINUE

         k0 = k1+1
         k1 = INDEX( IncludePath(k0:), ';' ) + k0 - 1
       END DO

       IF ( LEN_TRIM(IncludePath) > 0 ) THEN
         WRITE( FName, '(a,a,a)' ) TRIM(IncludePath(k0:)), '/', &
            TRIM( FileName )

         OPEN( InFileUnit, FILE=TRIM(FName), STATUS='OLD',ERR=20 )
         CALL LoadInputFile( Model, InFileUnit, FName, &
                MeshDir, MeshName, .FALSE., ScanOnly )
         CLOSE( InFileUnit )
         RETURN
       END IF

20     CONTINUE

       OPEN( InFileUnit, FILE=TRIM(FileName), STATUS='OLD' )
       CALL LoadInputFile( Model, InFileUnit, FileName, &
              MeshDir, MeshName, .FALSE., ScanOnly )
       CLOSE( InFileUnit )

     ELSE
       OPEN( InFileUnit, FILE=TRIM(FileName), STATUS='OLD' )
       CALL LoadInputFile( Model, InFileUnit, FileName, &
            MeshDir, MeshName, .FALSE., ScanOnly )
       CLOSE( InFileUnit )
     END IF

!------------------------------------------------------------------------------
  END SUBROUTINE LoadIncludeFile
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  FUNCTION ReloadInputFile( Model ) RESULT(got)
!------------------------------------------------------------------------------
    LOGICAL :: got
    TYPE(Model_t) :: Model
    INTEGER :: pos, posn
    CHARACTER(LEN=MAX_NAME_LEN) :: MeshDir, MeshName

    MeshDir  = ' '
    Meshname = ' '
    CALL LoadInputFile( Model, InFileUnit, ' ', &
        MeshDir, MeshName, .FALSE., .FALSE., got )
!------------------------------------------------------------------------------
  END FUNCTION ReloadInputFile
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  RECURSIVE SUBROUTINE LoadInputFile( Model, InFileUnit, FileName, &
         MeshDir, MeshName, BaseLoad, ScanOnly, Runc )
!------------------------------------------------------------------------------

    CHARACTER(LEN=*) :: FileName
    TYPE(Model_t) :: Model
    INTEGER :: InFileUnit
    LOGICAL :: BaseLoad
    LOGICAL :: ScanOnly
    LOGICAL, OPTIONAL :: runc
    CHARACTER(LEN=*) :: MeshDir,MeshName
!------------------------------------------------------------------------------

    TYPE( ValueList_t ), POINTER :: List

    INTEGER :: i,j,k,n,Arrayn,TYPE,Sect,N1,N2,BoundaryIndex

    INTEGER(KIND=AddrInt) :: Proc

    CHARACTER(LEN=2048) :: section, name, depname, str

    LOGICAL :: SizeGiven
    LOGICAL :: FreeNames=.FALSE., Echo = .FALSE.
    INTEGER :: CheckAbort = 0

    TYPE(Solver_t), POINTER :: ASolvers(:)

    TYPE(MaterialArray_t), POINTER  :: AMaterial(:)
    TYPE(EquationArray_t), POINTER  :: AEquation(:)
    TYPE(BodyArray_t), POINTER      :: ABody(:)
    TYPE(BodyForceArray_t), POINTER :: ABF(:)
    TYPE(InitialConditionArray_t), POINTER  :: AIC(:)
    TYPE(BoundaryConditionArray_t), POINTER :: ABC(:)

    LOGICAL :: FirstTime = .TRUE.

    INTEGER :: nlen
    REAL(KIND=dp) :: Value
!------------------------------------------------------------------------------

!   OPEN( InFileUnit,FILE=TRIM(FileName),STATUS='OLD',ERR=10 )

!
!------------------------------------------------------------------------------
!   Read model header first
!------------------------------------------------------------------------------
    CheckAbort = 1
    IF ( FirstTime ) THEN
       FirstTime = .FALSE.
       CALL CheckKeyword( 'coordinate system', 'string', &
           CheckAbort,FreeNames,'simulation' )
    END IF
 
    IF ( BaseLoad ) THEN
      DO WHILE( ReadAndTrim( InFileUnit, Name, Echo ) )
        IF ( Name(1:1) == ' ' )   CYCLE
        IF ( Name(1:3) == 'end' ) EXIT
        IF ( Name(1:14) == 'check keywords' ) THEN
           k = 16
           IF ( Name(k:k) == '"' ) k = k + 1
           IF ( Name(k:k+5) == 'ignore' )  CheckAbort = 0
           IF ( Name(k:k+3) == 'warn' )    CheckAbort = 1
           IF ( Name(k:k+4) == 'abort' )   CheckAbort = 2
        ELSE IF ( Name(1:7) == 'echo on' ) THEN
           Echo = .TRUE.
        ELSE IF ( Name(1:8) == 'echo off' ) THEN
           Echo = .FALSE.
        ELSE IF ( Name(1:6)  == 'bodies' ) THEN
        ELSE IF ( Name(1:18) == 'initial conditions' ) THEN
        ELSE IF ( Name(1:10) == 'boundaries' ) THEN
        ELSE IF ( Name(1:19) == 'boundary conditions' ) THEN
        ELSE IF ( Name(1:9)  == 'equations' ) THEN
        ELSE IF ( Name(1:7)  == 'solvers' ) THEN
        ELSE IF ( Name(1:9)  == 'materials' ) THEN
        ELSE IF ( Name(1:11) == 'body forces' ) THEN
        ELSE IF ( Name(1:7)  == 'mesh db' ) THEN
          k = 9
          i = 1
          nlen = LEN_TRIM(Name)
          DO WHILE( Name(k:k) /= ' ' )
            MeshDir(i:i)  = Name(k:k)
            Meshname(i:i) = Name(k:k)
            k = k + 1
            i = i + 1
          END DO
          MeshDir(i:i) = CHAR(0)

          DO WHILE( k<=nlen .AND. Name(k:k) == ' ' )
            k = k + 1
          END DO

          IF ( k<=nlen ) THEN
             MeshName(i:i) = '/'
             i = i + 1
             DO WHILE( Name(k:k) /= ' ' )
               MeshName(i:i) = Name(k:k)
               k = k + 1
               i = i + 1
             END DO
          ELSE
             MeshDir = "." // CHAR(0)
          END IF
          MeshName(i:i) = CHAR(0)
        ELSE IF ( Name(1:6) == 'header' ) THEN
        ELSE IF ( Name(1:12) == 'include path' ) THEN
           IncludePath = Name(14:)
        ELSE IF ( Name(1:17) == 'results directory' ) THEN
           OutputPath = Name(19:)
        ELSE IF ( Name(1:13) == 'simulation id' ) THEN
           SimulationId = Name(15:)
        ELSE
          WRITE( Message, * ) 'Unknown input field in header section: ' // TRIM(Name)
          CALL Fatal( 'Model Input',  Message )
        END IF
      END DO

      Model % BCs => Null()
      Model % ICs => Null()
      Model % Bodies => Null()
      Model % Solvers => Null()
      Model % Equations => Null()
      Model % Materials => Null()
      Model % Constants => Null()
      Model % Simulation => Null()
      Model % BodyForces => Null()
      Model % Boundaries => Null()
    END IF


!------------------------------------------------------------------------------
    IF ( .NOT. ScanOnly ) THEN
       IF ( .NOT.ASSOCIATED( Model % Boundaries ) ) THEN
         ALLOCATE( Model % Boundaries(Model % NumberOfBoundaries) )
         ALLOCATE( Model % BoundaryId(Model % NumberOfBoundaries) )
         DO i=1,Model % NumberOfBoundaries
           NULLIFY( Model % Boundaries(i) % Values )
           Model % BoundaryId(i) = 0
         END DO
         BoundaryIndex = 0
       END IF
    END IF

    IF ( PRESENT(runc) ) runc = .FALSE.
!------------------------------------------------------------------------------
    DO WHILE(ReadAndTrim(InFileUnit,Section,Echo))
!------------------------------------------------------------------------------
      IF ( Section(1:1) == ' ' ) CYCLE

      IF ( Section(1:7) == 'include' ) THEN
        CALL LoadIncludeFile( Model, InFileUnit-1, Section(9:), &
                    MeshDir, MeshName, ScanOnly )
        CYCLE
      END IF

      IF ( Section(1:6) == 'header' ) THEN
         DO WHILE( ReadAndTrim( InFileUnit, Section, Echo ) )
            IF ( Section(1:3) == 'end' ) EXIT
         END DO
         CYCLE
      ELSE IF ( Section(1:5) == 'echo ' .OR. Section(1:6) == 'check ') THEN
         CYCLE
      ELSE IF ( Section(1:3) == 'run' ) THEN
         IF ( PRESENT(runc) ) runc=.TRUE.
         EXIT
      END IF

      FreeNames = CheckAbort <= 0

      ArrayN = 0
      IF ( Section(1:9) == 'constants' ) THEN

         IF ( .NOT. ScanOnly ) THEN
           ArrayN = 1
           List => Model % Constants
         END IF

      ELSE IF ( Section(1:10) == 'simulation' ) THEN

         IF ( .NOT. ScanOnly ) THEN
           ArrayN = 1
           List => Model % Simulation
         END IF

      ELSE IF ( Section(1:18) == 'boundary condition' ) THEN

        IF ( ScanOnly ) THEN
           READ( Section(19:),* ) Arrayn
           Model % NumberOFBCs = MAX( Model % NumberOfBCs, Arrayn )
        ELSE
           IF ( .NOT.ASSOCIATED( Model % BCs ) ) THEN
              ALLOCATE( Model % BCs(Model % NumberOfBCs) )
              DO i=1,Model % NumberOfBCs
                 NULLIFY( Model % BCs(i) % Values )
              END DO
           ELSE 
             READ( Section(19:),* ) Arrayn
             Model % NumberOfBCs = MAX( Arrayn, Model % NumberOfBCs )

             IF ( SIZE( Model % BCs ) < Model % NumberOfBCs ) THEN
                ALLOCATE( ABC(Model % NumberOfBCs) )
                DO i=1,SIZE(Model % BCs)
                   ABC(i) % Values => Model % BCs(i) % Values
                END DO
                DO i=SIZE(Model % BCs)+1,Model % NumberOfBCs
                   NULLIFY( ABC(i) % Values )
                END DO
                DEALLOCATE( Model % BCs )
                Model % BCs => ABC
             END IF
           END IF

           READ( Section(19:),* ) Arrayn
           IF ( Arrayn <= 0 .OR. Arrayn > Model % NumberOfBCs ) THEN
              WRITE( Message, * ) 'Boundary Condition section number: ',Arrayn, &
                            ' exeeds header value.'
              CALL Fatal( 'Model Input', Message )
           END IF
           Model % BCs(ArrayN) % Tag = ArrayN
           List => Model % BCs(Arrayn) % Values
        END IF

        FreeNames = .TRUE.

      ELSE IF ( Section(1:8) == 'boundary' ) THEN

        IF ( ScanOnly ) THEN
           Model % NumberOfBoundaries = Model % NumberOfBoundaries + 1
        ELSE
           IF ( .NOT.ASSOCIATED( Model % Boundaries ) ) THEN
              ALLOCATE( Model % Boundaries(Model % NumberOfBoundaries) )
              ALLOCATE( Model % BoundaryId(Model % NumberOfBoundaries) )
              DO i=1,Model % NumberOfBoundaries
                 NULLIFY( Model % Boundaries(i) % Values )
                 Model % BoundaryId(i) = 0
              END DO
           END IF

           READ( Section(9:),* ) Arrayn
           BoundaryIndex = BoundaryIndex + 1
           IF ( BoundaryIndex <= 0 .OR. BoundaryIndex >  &
                 Model % NumberOfBoundaries ) THEN
              WRITE( Message, * ) 'Boundary section number: ',BoundaryIndex, &
                               ' exeeds header value.'
              CALL Fatal( 'Model Input', Message )
           END IF
           Model % BoundaryId(BoundaryIndex) = Arrayn
           List => Model % Boundaries(BoundaryIndex) % Values
        END IF

      ELSE IF ( Section(1:17) == 'initial condition' ) THEN

        IF ( ScanOnly ) THEN
           READ( Section(18:),* ) Arrayn
           Model % NumberOFICs = MAX( Model % NumberOfICs, ArrayN )
        ELSE
           IF ( .NOT.ASSOCIATED( Model % ICs ) ) THEN
              ALLOCATE( Model % ICs(Model % NumberOfICs) )
              DO i=1,Model % NumberOfICs
                 NULLIFY( Model % ICs(i) % Values )
              END DO
           ELSE
              READ( Section(18:),* ) Arrayn
              Model % NumberOfICs = MAX( Model % NumberOfICs, Arrayn )
              IF ( SIZE( Model % ICs ) < Model % NumberOfICs ) THEN
                ALLOCATE( AIC(Model % NumberOfICs) )
                DO i=1,SIZE(Model % ICs)
                   AIC(i) % Values => Model % ICs(i) % Values
                END DO
                DO i=SIZE(Model % ICs)+1,Model % NumberOfICs
                   NULLIFY( AIC(i) % Values )
                END DO
                DEALLOCATE( Model % ICs )
                Model % ICs => AIC
              END IF
           END IF

           READ( Section(18:),* ) Arrayn
           IF ( Arrayn <= 0 .OR. Arrayn > Model % NumberOfICs ) THEN
              WRITE( Message, * ) 'Initial Condition section number: ',Arrayn, &
                          ' exeeds header value.'
              CALL Fatal( 'Model Input', Message )
           END IF
           Model % ICs(ArrayN) % Tag = ArrayN
           List => Model % ICs(Arrayn) % Values
        END IF

        FreeNames = .TRUE.

      ELSE IF ( Section(1:8) == 'material' ) THEN

        IF ( ScanOnly ) THEN
           READ( Section(9:),* ) Arrayn
           Model % NumberOFMaterials = MAX( Model % NumberOfMaterials, ArrayN )
        ELSE
           IF ( .NOT.ASSOCIATED( Model % Materials ) ) THEN
              ALLOCATE( Model % Materials(Model % NumberOfMaterials) )
              DO i=1,Model % NumberOfMaterials
                 NULLIFY( Model % Materials(i) % Values )
              END DO
           ELSE
              READ( Section(9:),* ) Arrayn
              Model % NumberOfMaterials = MAX( Arrayn, Model % NumberOFMaterials ) 
              IF ( SIZE( Model % Materials ) < Model % NumberOfMaterials ) THEN
                ALLOCATE( AMaterial(Model % NumberOfMaterials) )
                DO i=1,SIZE(Model % Materials)
                   AMaterial(i) % Values => Model % Materials(i) % Values
                END DO
                DO i=SIZE(Model % Materials)+1,Model % NumberOfMaterials
                   NULLIFY( AMaterial(i) % Values )
                END DO
                DEALLOCATE( Model % Materials )
                Model % Materials => AMaterial
              END IF
           END IF

           READ( Section(9:),* ) Arrayn
           IF ( Arrayn <= 0 .OR. Arrayn > Model % NumberOfMaterials ) THEN
              WRITE( Message, * ) 'Material section number: ',Arrayn, &
                             ' exeeds header value.'
              CALL Fatal( 'Model Input', Message )
           END IF
           List => Model % Materials(Arrayn) % Values
        END IF

      ELSE IF ( Section(1:10) == 'body force' ) THEN

        IF ( ScanOnly ) THEN
           READ( Section(12:),* ) Arrayn
           Model % NumberOFBodyForces = MAX( Model % NumberOFBodyForces, ArrayN)
        ELSE
           IF ( .NOT.ASSOCIATED( Model % BodyForces ) ) THEN
             ALLOCATE( Model % BodyForces(Model % NumberOfBodyForces) )
             DO i=1,Model % NumberOfBodyForces
                NULLIFY( Model % BodyForces(i) % Values )
             END DO
           ELSE
              READ( Section(12:),* ) Arrayn
              Model % NumberOFBodyForces = MAX( Arrayn, Model % NumberOfBodyForces )
              IF ( SIZE( Model % BodyForces ) < Model % NumberOfBodyForces ) THEN
                 ALLOCATE( ABF(Model % NumberOfBodyForces) )
                 DO i=1,SIZE(Model % BodyForces)
                    ABF(i) % Values => Model % BodyForces(i) % Values
                 END DO
                 DO i=SIZE(Model % BodyForces)+1,Model % NumberOfBodyForces
                    NULLIFY( ABF(i) % Values )
                 END DO
                 DEALLOCATE( Model % BodyForces )
                 Model % BodyForces => ABF
              END IF
           END IF

           READ( Section(12:),* ) Arrayn
           IF ( Arrayn <= 0 .OR. Arrayn > Model % NumberOfBodyForces ) THEN
              WRITE( Message, * ) 'Body Force section number: ',Arrayn, &
                          ' exeeds header value.'
              CALL Fatal( 'Model Input', Message )
           END IF
           List => Model % BodyForces(Arrayn) % Values
        END IF

      ELSE IF ( Section(1:8) == 'equation' ) THEN

        IF ( ScanOnly ) THEN
           READ( Section(9:),* ) Arrayn
           Model % NUmberOfEquations = MAX( Model % NumberOFEquations, ArrayN )
        ELSE
           IF ( .NOT.ASSOCIATED( Model % Equations ) ) THEN
             ALLOCATE( Model % Equations(Model % NumberOfEquations) )
             DO i=1,Model % NumberOfEquations
               NULLIFY( Model % Equations(i) % Values )
             END DO
           ELSE
              READ( Section(9:),* ) Arrayn
              Model % NumberOFEquations = MAX( Arrayn, Model % NumberOFEquations )
              IF ( SIZE( Model % Equations ) < Model % NumberOfEquations ) THEN
                ALLOCATE( AEquation(Model % NumberOfEquations) )
                DO i=1,SIZE(Model % Equations)
                   AEquation(i) % Values => Model % Equations(i) % Values
                END DO
                DO i=SIZE(Model % Equations)+1,Model % NumberOfEquations
                   NULLIFY( AEquation(i) % Values )
                END DO
                DEALLOCATE( Model % Equations )
                Model % Equations => AEquation
              END IF
           END IF

           READ( Section(9:),* ) Arrayn
           IF ( Arrayn <= 0 .OR. Arrayn > Model % NumberOfEquations ) THEN
              WRITE( Message, * ) 'Equation section number: ',Arrayn, &
                           ' exeeds header value.'
              CALL Fatal( 'Model Input', Message )
           END IF
           List => Model % Equations(ArrayN) % Values
        END IF

        FreeNames = .TRUE.

      ELSE IF ( Section(1:4) == 'body' ) THEN

        IF ( ScanOnly ) THEN
           READ( Section(5:),* ) Arrayn
           Model % NumberOFBodies = MAX( Model % NumberOFBodies, ArrayN )
        ELSE
           IF ( .NOT.ASSOCIATED( Model % Bodies ) ) THEN
             ALLOCATE( Model % Bodies(Model % NumberOfBodies) )
             DO i=1,Model % NumberOfBodies
               NULLIFY( Model % Bodies(i) % Values )
             END DO
           ELSE
              READ( Section(5:),* ) Arrayn
              Model % NumberOFBodies = MAX( Arrayn, Model % NumberOFBodies )
              IF ( SIZE( Model % Bodies ) < Model % NumberOfBodies ) THEN
                 ALLOCATE( ABody(Model % NumberOfBodies) )
                 DO i=1,SIZE(Model % Bodies)
                    ABody(i) % Values => Model % Bodies(i) % Values
                 END DO
                 DO i=SIZE(Model % Bodies)+1,Model % NumberOfBodies
                    NULLIFY( ABody(i) % Values )
                 END DO
                 DEALLOCATE( Model % Bodies )
                 Model % Bodies => ABody
              END IF
           END IF

           READ( Section(5:),* ) Arrayn
           IF ( Arrayn <= 0 .OR. Arrayn > Model % NumberOfBodies ) THEN
              WRITE( Message, * ) 'Body section number: ',Arrayn, &
                        ' exeeds header value. Aborting. '
              CALL Fatal( 'Model Input', Message )
           END IF
           List => Model % Bodies(Arrayn) % Values
        END IF

      ELSE IF ( Section(1:6) == 'solver' ) THEN

        IF ( ScanOnly ) THEN
           READ( Section(7:),* ) Arrayn
           Model % NumberOfSolvers = MAX( Model % NumberOfSolvers, ArrayN )
        ELSE
           IF ( .NOT.ASSOCIATED( Model % Solvers ) ) THEN
             ALLOCATE( Model % Solvers(Model % NumberOfSolvers) )
             DO i=1,Model % NumberOfSolvers
                Model % Solvers(i) % PROCEDURE = 0
                NULLIFY( Model % Solvers(i) % Matrix )
                NULLIFY( Model % Solvers(i) % Values )
                NULLIFY( Model % Solvers(i) % Variable )
                NULLIFY( Model % Solvers(i) % ActiveElements )
                Model % Solvers(i) % NumberOfActiveElements = 0
             END DO
           ELSE
              READ( Section(7:),* ) Arrayn
              Model % NumberOfSolvers = MAX( Arrayn, Model % NumberOfSolvers )
              IF ( SIZE(Model % Solvers) < Model % NumberOfSolvers ) THEN
                ALLOCATE( ASolvers(Model % NumberOfSolvers) )
                DO i=1,SIZE(Model % Solvers)
                   ASolvers(i) = Model % Solvers(i)
                END DO
                DO i=SIZE(Model % Solvers)+1,Model % NumberOfSolvers
                   ASolvers(i) % PROCEDURE = 0
                   NULLIFY( ASolvers(i) % Matrix )
                   NULLIFY( ASolvers(i) % Mesh )
                   NULLIFY( ASolvers(i) % Values )
                   NULLIFY( ASolvers(i) % Variable )
                   NULLIFY( ASolvers(i) % ActiveElements )
                   ASolvers(i) % NumberOfActiveElements = 0
                END DO
                DEALLOCATE( Model % Solvers )
                Model % Solvers => ASolvers
              END IF
           END IF

           READ( Section(7:),* ) Arrayn
           IF ( Arrayn <= 0 .OR. Arrayn > Model % NumberOfSolvers ) THEN
              WRITE( Message, * ) 'Solver section number: ',Arrayn, &
                               ' exeeds header value. Aborting. '
              CALL Fatal( 'Model Input', Message )
           END IF
           List => Model % Solvers(Arrayn) % Values
        END IF
      ELSE
        WRITE( Message, * ) 'Unknown input section name: ',TRIM(Section)
        CALL Fatal( 'Model Input', Message )
      END IF
!------------------------------------------------------------------------------
      IF ( .NOT. ScanOnly .AND. ArrayN == 0 ) CYCLE

      CALL SectionContents( Model, List, CheckAbort, FreeNames, &
                Section, InFileUnit, ScanOnly, Echo )

      IF ( .NOT. ScanOnly ) THEN
        IF ( Section(1:9) == 'constants' ) THEN
          Model % Constants => List
        ELSE IF ( Section(1:10) == 'simulation' ) THEN
          Model % Simulation => List
        ELSE IF ( Section(1:18) == 'boundary condition' ) THEN
          Model % BCs(Arrayn) % Values => List
        ELSE IF ( Section(1:8) == 'boundary' ) THEN
          Model % Boundaries(BoundaryIndex) % Values => List
        ELSE IF ( Section(1:17) == 'initial condition' ) THEN
          Model % ICs(Arrayn) % Values => List
        ELSE IF ( Section(1:8) == 'material' ) THEN
          Model % Materials(Arrayn) % Values => List
        ELSE IF ( Section(1:10) == 'body force' ) THEN
          Model % BodyForces(Arrayn) % Values => List
        ELSE IF ( Section(1:8) == 'equation' ) THEN
          Model % Equations(Arrayn) % Values  => List
        ELSE IF ( Section(1:4) == 'body' ) THEN
          Model % Bodies(Arrayn) % Values => List
        ELSE IF ( Section(1:6) == 'solver' ) THEN
          Model % Solvers(Arrayn) % Values => List
        END IF
      END IF
!------------------------------------------------------------------------------
    END DO
!------------------------------------------------------------------------------

!   CLOSE( InFileUnit )

    IF ( .NOT. ScanOnly )  THEN

      ! Add default equation, material, ic, bodyforce, and body if not given:
      ! ---------------------------------------------------------------------
      IF ( Model % NumberOFEquations <= 0 ) THEN
         Model % NumberOfEquations = 1
         ALLOCATE( Model % Equations(1) )
         NULLIFY( Model % Equations(1) % Values )
         CALL ListAddIntegerArray( Model % Equations(1) % Values, 'Active Solvers', &
             Model % NumberOFSolvers, (/ (i,i=1,Model % NumberOfSolvers) /) )
         CALL ListAddString ( Model % Equations(1) % Values, 'Name', 'Default Equation 1' )
      END IF

      IF ( Model % NumberOfMaterials <= 0 ) THEN
         Model % NumberOfMaterials = 1
         ALLOCATE( Model % Materials(1) )
         NULLIFY( Model % Materials(1) % Values )
         CALL ListAddString ( Model % Materials(1) % Values, 'Name', 'Default Material 1' )
      END IF

      IF ( Model % NumberOfBodyForces <= 0 ) THEN
         Model % NumberOfBodyForces = 1
         ALLOCATE( Model % BodyForces(1) )
         NULLIFY( Model % BodyForces(1) % Values )
         CALL ListAddString ( Model % BodyForces(1) % Values, 'Name','Default Body Force 1' )
      END IF

      IF ( Model % NumberOfICs <= 0 ) THEN
         Model % NumberOfICs = 1
         ALLOCATE( Model % ICs(1) )
         NULLIFY( Model % ICs(1) % Values )
         CALL ListAddString ( Model % ICs(1) % Values, 'Name','Default IC 1' )
      END IF

      IF ( Model % NumberOfBodies <= 0 ) THEN
         Model % NumberOfBodies = 1
         ALLOCATE( Model % Bodies(1) )
         NULLIFY( Model % Bodies(1) % Values )
         CALL ListAddString(  Model % Bodies(1) % Values, 'Name', 'Default Body 1' )
         CALL ListAddInteger( Model % Bodies(1) % Values, 'Equation',   1 )
         CALL ListAddInteger( Model % Bodies(1) % Values, 'Material',   1 )
         CALL ListAddInteger( Model % Bodies(1) % Values, 'Body Force', 1 )
         CALL ListAddInteger( Model % Bodies(1) % Values, 'Initial Condition', 1 )
      END IF
      ! -- done adding default fields
    END IF

    RETURN

10  CONTINUE

    WRITE( Message, * ) 'Cannot find input file: ', TRIM(FileName)
    CALL Warn( 'Model Input', Message )

CONTAINS

    SUBROUTINE CheckKeyWord( Name,TYPE,CheckAbort,FreeNames,Section,ReturnType )
       USE HashTable

       CHARACTER(LEN=*) :: Name,TYPE,Section
       INTEGER :: CheckAbort
       LOGICAL, OPTIONAL :: ReturnType,FreeNames

       INTEGER :: i,j, k,n, istat
       TYPE(HashTable_t), POINTER, SAVE :: Hash =>Null()
       TYPE(HashValue_t), POINTER :: Value
       LOGICAL :: FirstTime = .TRUE.,lstat
       CHARACTER(LEN=MAX_PATH_LEN) :: str,str1
       EXTERNAL ENVIR

       IF ( PRESENT( ReturnType ) ) ReturnType = .FALSE.

       IF ( CheckAbort <= 0 ) RETURN

       IF ( FirstTime ) THEN
!
!         First time in, read the SOLVER.KEYWORDS database, and
!         build up a local hash table for it:
! 
!         Priority is in ELMER_LIB, ELMER_HOME, and finally, if all else fails
!         use the compilation time prefix.
!         ------------------------------------------------------
#include "../config.h"

          str = 'ELMER_LIB'; str(10:10) = CHAR(0)
          CALL envir( str,str1,k ) 

          IF ( k > 0  ) THEN
            str1 = str1(1:k) // '/SOLVER.KEYWORDS'
          ELSE
             str = 'ELMER_HOME'; str(11:11) = CHAR(0)
             CALL envir( str,str1,k ) 
             IF ( k > 0 ) THEN
               str1 = str1(1:k) // '/share/elmersolver/lib/' // 'SOLVER.KEYWORDS'
             ELSE
               CALL GetSolverHome(str, n)
               WRITE(str1, '(a,a)') str(1:n), '/lib/SOLVER.KEYWORDS'
             END IF
          END IF

          OPEN( 1, FILE=TRIM(str1), STATUS='OLD', ERR=10 )

!
!         Initially 50 buckets, on avarage MAX 4 entries / bucket:
!         --------------------------------------------------------
          hash => HashCreate( 50,4 )
          IF ( .NOT. ASSOCIATED( hash ) ) THEN
             IF ( CheckAbort <= 1 ) THEN
               CALL Warn( 'Model Input', 'Can not create the hash table for SOLVER.KEYWORDS.' )
               CALL Warn( 'Model Input', 'keyword checking disabled.' )
               CheckAbort = 0
               RETURN
             ELSE
               CALL Fatal( 'Model Input','Can not create the hash table for SOLVER.KEYWORDS.' )
             END IF
          END IF

5         CONTINUE

!
!         Read the keywords file row by row and add to the hash table:
!         ------------------------------------------------------------
          DO WHILE( ReadAndTrim( 1, str ) )

             i = INDEX( str, ':' )
             j = INDEX( str, "'" )
             IF ( i <= 0 .OR. j<= 0 ) CYCLE
             str1 = str(1:i-1) // ':' //  str(j+1:LEN_TRIM(str)-1)

             ALLOCATE( Value, STAT=istat )

             IF ( istat /= 0 ) THEN
                IF ( CheckAbort <= 1 ) THEN
                  CALL Warn( 'Model Input', 'Can not allocate the hash table entry for SOLVER.KEYWORDS.' )
                  CALL Warn( 'Model Input', ' keyword checking disabled.' )
                  CheckAbort = 0
                  RETURN
                ELSE
                  CALL Fatal( 'Model Input', 'Can not allocate the hash table entry for SOLVER.KEYWORDS.' )
                END IF
             END IF

             Value % TYPE = str(i+1:j-3)

             lstat = HashAdd( hash, str1, Value )
             IF ( .NOT. lstat ) THEN
                IF ( CheckAbort <= 1 ) THEN
                   CALL Warn( 'Model Input', 'Hash table build error. Keyword checking disabled.' )
                   CheckAbort = 0
                   RETURN
                ELSE
                   CALL Fatal( 'Model Input', 'Hash table build error.' )
                END IF
             END IF
          END DO
          CLOSE(1)

          IF ( FirstTime ) THEN
             FirstTime = .FALSE.
             OPEN( 1, FILE='SOLVER.KEYWORDS', STATUS='OLD', ERR=6 )
             CALL Info( 'Model Input', 'Found local SOLVER.KEYWORDS file, ' // &
                        'adding keywords to runtime database.' )
             GOTO 5
6            CONTINUE
          END IF
       END IF

!------------------------------------------------------------------------------

        IF ( Section(1:9) == 'constants' ) THEN
           str =  'constants: '
        ELSE IF ( Section(1:10) == 'simulation' ) THEN
           str =  'simulation: '
        ELSE IF ( Section(1:18) == 'boundary condition' ) THEN
           str =  'bc: '
        ELSE IF ( Section(1:8) == 'boundary' ) THEN
          str =  'boundary: '
        ELSE IF ( Section(1:17) == 'initial condition' ) THEN
          str =  'ic: '
        ELSE IF ( Section(1:8) == 'material' ) THEN
          str =  'material: '
        ELSE IF ( Section(1:10) == 'body force' ) THEN
          str =  'bodyforce: '
        ELSE IF ( Section(1:8) == 'equation' ) THEN
          str =  'equation: '
        ELSE IF ( Section(1:4) == 'body' ) THEN
          str =  'body: '
        ELSE IF ( Section(1:6) == 'solver' ) THEN
          str =  'solver: '
        END IF

        str = TRIM(str) // TRIM(Name)

!------------------------------------------------------------------------------

       Value => HashValue( Hash, str )
       IF ( ASSOCIATED( Value ) ) THEN
          IF ( PRESENT( ReturnType ) ) THEN
             ReturnType = .TRUE.
             TYPE = Value % TYPE
          END IF
          IF  ( HashEqualKeys( Value % TYPE, TYPE ) ) RETURN
       END IF

       IF ( PRESENT( ReturnType ) ) ReturnType = .FALSE.

       IF ( .NOT.ASSOCIATED(Value) .AND. (CheckAbort <= 1 .OR. FreeNames) ) THEN
          IF ( .NOT. ScanOnly ) THEN
            WRITE( Message, * ) 'Unlisted keyword: [', TRIM(name), &
                      '] in section: [', TRIM(Section), ']'
            CALL Info( 'Model Input', Message )
          END IF
       ELSE
          IF ( ASSOCIATED( Value ) ) THEN
             WRITE( Message, * ) 'Keyword: [', TRIM(name), &
                    '] in section: [', TRIM(Section), ']',  &
                    ' is given wrong type: [', TRIM(TYPE),  &
                    '], should be of type: [', TRIM(Value % TYPE),']'
          ELSE
             WRITE( Message, * ) 'Unlisted keyword: [', TRIM(name), &
               '] in section: [', TRIM(Section), '].'
          END IF
          CALL Fatal( 'Model Input', Message )
       END IF

       RETURN

10     CONTINUE

       IF ( CheckAbort <= 1 ) THEN
          CALL Warn( 'Model Input', 'Keyword check requested, but SOLVER.KEYWORDS' // &
                 ' database not available.' )
       ELSE
          CALL Fatal( 'Model Input', 'Keyword check requested, but SOLVER.KEYWORDS' // &
                 ' database not available.' )
       END IF
!------------------------------------------------------------------------------
    END SUBROUTINE CheckKeyword
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
    RECURSIVE SUBROUTINE SectionContents( Model,List, CheckAbort,FreeNames, &
              Section, InFileUnit, ScanOnly, Echo )
!------------------------------------------------------------------------------
      TYPE(ValueList_t), POINTER :: List,ll
      INTEGER :: InFileUnit,CheckAbort
      TYPE(Model_t) :: Model
      LOGICAL :: FreeNames,Echo
      CHARACTER(LEN=*)  :: Section

      INTEGER, ALLOCATABLE  :: IValues(:)
      REAL(KIND=dp), ALLOCATABLE :: Atx(:,:,:), ATt(:)

      CHARACTER(LEN=MAX_NAME_LEN) :: TypeString,Keyword
      CHARACTER(LEN=MAX_PATH_LEN) :: Name,str, Depname
      LOGICAL :: ReturnType, ScanOnly, String_literal,  SizeGiven, Cubic

      INTEGER(KIND=AddrInt) :: Proc
      INTEGER :: i,j,k,l,n,slen, str_beg, str_end, n1,n2, TYPE, abuflen=0,maxbuflen=0

      ALLOCATE( ATt(1), ATx(1,1,1), IValues(1) )


      DO WHILE( ReadAndTrim( InFileUnit,Name,Echo ) )

        IF ( Name(1:7) == 'include' ) THEN
          OPEN( InFileUnit-1,FILE=TRIM(Name(9:)),STATUS='OLD',ERR=10 )
          CALL SectionContents( Model,List,CheckAbort,FreeNames, &
                  Section,InFileUnit-1,ScanOnly, Echo )
          CLOSE( InFileUnit-1 )
          CYCLE

10        CONTINUE

          WRITE( Message, * ) 'Cannot find include file: ', Name(9:40)
          CALL Warn( 'Model Input', Message )
          CYCLE
        END IF

        IF ( Name(1:1) == ' ' )  CYCLE
        IF ( Name(1:3) == 'end' ) THEN
          EXIT
        END IF

        TYPE = LIST_TYPE_CONSTANT_SCALAR
        N1   = 1
        N2   = 1
        SizeGiven = .FALSE.
        str = ''
        DO WHILE( ReadAndTrim(InFileUnit,str,echo,string_literal) ) 

          IF ( string_literal ) THEN
            ReturnType = .TRUE.
            CALL CheckKeyWord( Name, TypeString, CheckAbort,FreeNames,Section,ReturnType )
            IF ( .NOT. ReturnType ) THEN
              CALL SyntaxError( Section, Name,str )
            ELSE IF (TypeString/='string' .AND. TypeString/='file') THEN 
              CALL SyntaxError( Section, Name,str )
            ELSE
              str = TRIM(TypeString) // ' ' // TRIM(str)
            END IF
          END IF

20        CONTINUE

          slen = LEN_TRIM(str)
          j = slen
          DO i=1,slen
            IF ( str(i:i)==' ') EXIT
            j = i
          END DO
          Keyword=str(1:j)
          str_beg = j+2

          SELECT CASE(Keyword)
          CASE('real')
             CALL CheckKeyWord( Name,'real',CheckAbort,FreeNames,Section )

             Proc = 0
             IF ( str(str_beg:str_beg+9) == 'procedure ' ) THEN

               IF ( .NOT. ScanOnly ) THEN
                  Proc = GetProcAddr( str(str_beg+10:) )

                  SELECT CASE( TYPE )
                  CASE( LIST_TYPE_CONSTANT_SCALAR )

                    IF ( SizeGiven ) THEN
                      CALL ListAddConstRealArray( List,Name,N1,N2, &
                             ATx(1:N1,1:N2,1),Proc )
                    ELSE
                      CALL ListAddConstReal( List,Name,Value,Proc )
                    END IF
   
                  CASE( LIST_TYPE_VARIABLE_SCALAR )

                    IF ( SizeGiven ) THEN
                      CALL ListAddDepRealArray( List,Name,Depname,1,ATt, &
                            N1,N2,ATx(1:N1,1:N2,1:1),Proc )
                    ELSE
                      CALL ListAddDepReal( List,Name,Depname,1,ATt,ATx,Proc )
                    END IF
                  END SELECT
               END IF

             ELSE IF ( str(str_beg:str_beg+4) == 'matc ' ) THEN

               IF ( .NOT. ScanOnly ) THEN

                  SELECT CASE( TYPE )
                  CASE( LIST_TYPE_CONSTANT_SCALAR )

                    IF ( SizeGiven ) THEN
                       CALL ListAddConstRealArray( List,Name,N1,N2, &
                         ATx(1:N1,1:N2,1), Proc, str(str_beg+5:) )
                    ELSE
                      CALL ListAddConstReal( List,Name,Value,Proc, &
                                  str(str_beg+5:) )
                    END IF
   
                  CASE( LIST_TYPE_VARIABLE_SCALAR )

                    IF ( SizeGiven ) THEN
                      CALL ListAddDepRealArray( List,Name,Depname,1,ATt, &
                            N1,N2,ATx(1:N1,1:N2,1:n),Proc, str(str_beg+5:) )
                    ELSE
                      CALL ListAddDepReal( List,Name,Depname,1,ATt,ATx, &
                                  Proc, str(str_beg+5:) )
                    END IF
                  END SELECT
               END IF

             ELSE

               SELECT CASE( TYPE )
               CASE( LIST_TYPE_CONSTANT_SCALAR )
                  k = 0
                  DO i=1,N1
                     DO j=1,N2
                        DO WHILE( k <= slen )
                           k = k + 1
                           IF ( str(k:k) == ' ' ) EXIT
                        END DO

                        DO WHILE( k <= slen )
                          k = k + 1
                             IF ( str(k:k) /= ' ' ) EXIT
                        END DO

                        IF ( k > slen ) THEN
                          IF ( .NOT. ReadAndTrim( InFileUnit,str,Echo) ) &
                            CALL SyntaxError( Section,Name,str )
                          k = 1
                          slen = LEN_TRIM(str)
                        END IF

                        IF (.NOT.ScanOnly ) READ( str(k:),* ) ATx(i,j,1)
                     END DO
                  END DO
 
                  IF ( .NOT. ScanOnly ) THEN
                     IF ( SizeGiven ) THEN
                       CALL ListAddConstRealArray( List,Name,N1,N2, &
                              ATx(1:N1,1:N2,1) )
                     ELSE
                       CALL ListAddConstReal( List,Name,ATx(1,1,1) )
                     END IF
                  END IF
  
               CASE( LIST_TYPE_VARIABLE_SCALAR )
                 IF (ScanOnly) THEN
                   AbufLen=0
                 ELSE
                   IF (ALLOCATED(ATt) ) DEALLOCATE(ATt,ATx)
                   ALLOCATE( ATt(MaxBufLen), ATx(n1,n2,MaxBufLen) )
                 END IF
 
                 Cubic = str(str_beg:str_beg+4)=='cubic'
                 n = 0
                 DO WHILE( ReadAndTrim(InFileUnit,str,Echo) )

                   IF ( str(1:3) == 'end' ) EXIT
                   IF ( str(1:1) == ' '  ) CYCLE
 
                   slen = LEN_TRIM(str)
                   IF ( .NOT. ScanOnly ) THEN
                     n = n + 1
                     READ( str,* ) ATt(n)
                   ELSE
                     AbufLen = AbufLen+1
                   END IF

                   k = 0
                   DO i=1,N1
                     DO j=1,N2
                       DO WHILE( k <= slen )
                         k = k + 1
                         IF ( str(k:k) == ' ' ) EXIT
                       END DO

                       DO WHILE( k <= slen )
                         k = k + 1
                         IF ( str(k:k) /= ' ' ) EXIT
                       END DO

                       IF ( k > slen ) THEN
                          IF ( .NOT. ReadAndTrim( InFileUnit,str,Echo) ) &
                            CALL SyntaxError( Section,Name,str )

                          k = 1
                          slen = LEN_TRIM(str)
                       END IF

                       IF ( .NOT. ScanOnly ) READ( str(k:),* ) ATx(i,j,n)
                     END DO
                   END DO
                 END DO
 
                 IF (.NOT. ScanOnly ) THEN
                   IF ( SizeGiven ) THEN
                     CALL ListAddDepRealArray( List,Name,Depname,n,ATt(1:n), &
                              N1,N2,ATx(1:N1,1:N2,1:n) )
                   ELSE
                     CALL ListAddDepReal( List,Name,Depname,n,ATt(1:n), &
                                   ATx(1,1,1:n),CubicTable=Cubic )
                   END IF
                 END IF
                 MaxBufLen = MAX(MaxBuflen, Abuflen)
               END SELECT
             END IF
             EXIT

          CASE('logical')

            CALL CheckKeyWord( Name,'logical',CheckAbort,FreeNames,Section )

            IF ( .NOT. ScanOnly ) THEN
               IF ( str(str_beg:str_beg+3) == 'true' .OR. &
                 str(str_beg:str_beg) == '1' ) THEN
                 CALL ListAddLogical( List,Name,.TRUE. )
               ELSE 
                 CALL ListAddLogical( List,Name,.FALSE. )
               END IF
            END IF
            EXIT

          CASE('integer')

            CALL CheckKeyWord( Name,'integer',CheckAbort,FreeNames,Section )


             Proc = 0
             IF ( str(str_beg:str_beg+9) == 'procedure ' ) THEN
               IF ( .NOT. ScanOnly ) THEN
                 Proc = GetProcAddr( str(str_beg+10:) )
                 IF ( SizeGiven ) THEN
                   CALL ListAddIntegerArray( List,Name,N1,IValues,Proc )
                 ELSE
                   CALL ListAddInteger( List,Name,k,Proc )
                 END IF
               END IF
             ELSE
               IF ( SizeGiven ) THEN
                 IF ( .NOT. ScanOnly ) THEN
                   IF (SIZE(IValues)<n1) THEN
                     DEALLOCATE(IValues)
                     ALLOCATE(IValues(n1))
                   END IF
                 END IF

                 k = 0
                 DO i=1,N1
                   DO WHILE( k <= slen )
                      k = k + 1
                      IF ( str(k:k) == ' ') EXIT
                   END DO

                   DO WHILE( k <= slen )
                     k = k + 1
                     IF ( str(k:k) /= ' ') EXIT
                   END DO

                   IF ( k > slen ) THEN
                     IF ( .NOT. ReadAndTrim(InFileUnit,str,Echo)) &
                       CALL SyntaxError( Section,Name,str )

                     k = 1
                     slen = LEN_TRIM(str)
                   END IF
                   IF ( .NOT. ScanOnly ) READ( str(k:),* ) IValues(i)
                 END DO
                 IF ( .NOT. ScanOnly ) CALL ListAddIntegerArray( &
                              List,Name,N1,IValues )
               ELSE IF (.NOT.ScanOnly) THEN
                 READ( str(str_beg:),* ) k 
                 CALL ListAddInteger( List,Name,k )
               END IF
             END IF
             EXIT

          CASE('string')

            CALL CheckKeyWord( Name,'string',CheckAbort,FreeNames,Section )

            IF ( .NOT. ScanOnly ) CALL ListAddString( List,Name,str(str_beg:) )
            EXIT

          CASE('file')

            CALL CheckKeyWord( Name,'file',CheckAbort,FreeNames,Section )

            IF ( .NOT. ScanOnly ) CALL ListAddString( List,Name, &
                          str(str_beg:),.FALSE. )
            EXIT

          CASE('variable')

            DO k=MAX_NAME_LEN,1,-1
              IF ( str(k:k) /= ' ' ) EXIT 
            END DO

            Depname = ' '
            Depname(1:k-9) = str(str_beg:k)
            TYPE = LIST_TYPE_VARIABLE_SCALAR

          CASE('equals')

            IF ( .NOT. ScanOnly ) THEN
               DO k=MAX_NAME_LEN,1,-1
                 IF ( str(k:k) /= ' ' ) EXIT 
               END DO

               Depname = ' '
               Depname(1:k-7) = str(str_beg:k)

               n = 1
               IF ( n > SIZE( ATt ) ) THEN
                  DEALLOCATE( ATt, ATx )
                  ALLOCATE( ATt(n), ATx(1,1,n) )
               END IF

               ATt(1) = 1.0_dp
               ATx(1,1,1) = 1.0_dp

               CALL ListAddDepReal(List,Name,Depname,n,ATt(1:n),ATx(1,1,1:n))
            END IF
            EXIT

          CASE('opposes')

           IF ( .NOT. ScanOnly ) THEN
               DO k=MAX_NAME_LEN,1,-1
                 IF ( str(k:k) /= ' ' ) EXIT 
               END DO

               Depname = ' '
               Depname(1:k-7) = str(str_beg:k)

               n = 1
               IF ( n > SIZE( ATt ) ) THEN
                  DEALLOCATE( ATt, ATx )
                  ALLOCATE( ATt(n), ATx(1,1,n) )
               END IF

               ATt(1) = 1.0_dp
               ATx(1,1,1) = -1.0_dp

               CALL ListAddDepReal(List,Name,Depname,n,ATt(1:n),ATx(1,1,1:n))
            END IF
            EXIT

          CASE('size')
            N1 = 1
            N2 = 1
            READ( str(str_beg:),*,err=1,END=1) N1,N2

1           CONTINUE

            IF ( .NOT. ScanOnly ) THEN
               IF ( ALLOCATED( ATx ) ) DEALLOCATE( ATx )
               ALLOCATE( ATx(N1,N2,1) )
               IF ( ALLOCATED( ATt ) ) DEALLOCATE( ATt )
               ALLOCATE( ATt(1) )
            END IF

            SizeGiven = .TRUE.

          CASE('-remove')

            IF ( .NOT. ScanOnly ) CALL ListRemove( List, Name )
            EXIT

          CASE DEFAULT

            ReturnType = .TRUE.
            CALL CheckKeyWord( Name, TypeString, CheckAbort, &
                     FreeNames,Section,ReturnType )
            IF ( ReturnType ) THEN 
              str = TRIM(TypeString) // ' ' // str
              GOTO 20
            END IF
            CALL SyntaxError( Section, Name,str )
          END SELECT
!------------------------------------------------------------------------------
        END DO
!------------------------------------------------------------------------------
      END DO
!------------------------------------------------------------------------------
      END SUBROUTINE SectionContents
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE SyntaxError( Section, Name, LastString )
!------------------------------------------------------------------------------
        CHARACTER(LEN=*) :: Section, Name, LastString

         CALL Error( 'Model Input', ' ' )
         WRITE( Message, * ) 'Unknown specifier: [',TRIM(LastString),']'
         CALL Error( 'Model Input', Message )
         WRITE( Message, * ) 'In section: [', TRIM(Section), ']'
         CALL Error( 'Model Input', Message )
         WRITE( Message, * ) 'For property name:[',TRIM(Name),']'
         CALL Fatal( 'Model Input', Message )
!------------------------------------------------------------------------------
      END SUBROUTINE SyntaxError
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  END SUBROUTINE LoadInputFile
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
  SUBROUTINE LoadGebhardtFactors( Mesh,FileName )
!------------------------------------------------------------------------------
    TYPE(Mesh_t), POINTER :: Mesh
    CHARACTER(LEN=*) FileName
!------------------------------------------------------------------------------

    INTEGER, ALLOCATABLE :: Mapping(:)
    INTEGER :: i,j,k,l,n,m,p
    REAL(KIND=dp) :: s
    CHARACTER(LEN=MAX_PATH_LEN) :: FName
    TYPE(Element_t), POINTER :: elm,celm

!------------------------------------------------------------------------------

    IF ( LEN_TRIM(Mesh % Name) > 0 ) THEN
      FName = TRIM(OutputPath) // '/' // TRIM(Mesh % Name) // '/' // TRIM(FileName)
    ELSE
      FName = TRIM(FileName)
    END IF
    OPEN( 1,file = TRIM(FName),err=10 )

    CALL Info( 'LoadGebhardtFactors', 'Start', Level=5 )

    READ(1,*) n
    ALLOCATE( mapping(n) )
    DO i=1,n
      READ(1,*) j,mapping(i)
    END DO

    DO i=1,n
      READ(1,*) m
      DO j=1,m
        READ(1,*) k,l,s
        k = mapping(k)
        l = mapping(l)
        IF ( .NOT.ASSOCIATED( &
          mesh % elements(k) % boundaryinfo % gebhardtfactors) ) THEN
          ALLOCATE( mesh % elements(k) % boundaryinfo % gebhardtfactors )
          ALLOCATE(  &
          mesh % elements(k) % boundaryinfo % gebhardtfactors % factors(m), &
          mesh % elements(k) % boundaryinfo % gebhardtfactors % elements(m) )
          mesh % elements(k) % boundaryinfo % gebhardtfactors % numberoffactors = m
        ELSE IF ( mesh % elements(k) % boundaryinfo % gebhardtfactors % numberoffactors/=m ) THEN
          DEALLOCATE(  &
          mesh % elements(k) % boundaryinfo % gebhardtfactors % factors, &
          mesh % elements(k) % boundaryinfo % gebhardtfactors % elements )
          ALLOCATE(  &
          mesh % elements(k) % boundaryinfo % gebhardtfactors % factors(m), &
          mesh % elements(k) % boundaryinfo % gebhardtfactors % elements(m) )
          mesh % elements(k) % boundaryinfo % gebhardtfactors % numberoffactors = m
        END IF
        mesh % elements(k) % boundaryinfo % gebhardtfactors % numberofimplicitfactors = &
            mesh % elements(k) % boundaryinfo % gebhardtfactors % numberoffactors
      END DO
    END DO

    REWIND(1)

    READ(1,*) n

    DO i=1,n
      READ(1,*) j,mapping(i)
    END DO

    DO i=1,n
      READ(1,*) m
      DO j=1,m
        READ(1,*) k,l,s
        k = mapping(k)
        l = mapping(l)
        mesh % elements(k) % boundaryinfo % gebhardtfactors % elements(j) = l
        mesh % elements(k) % boundaryinfo % gebhardtfactors % factors(j)  = s
      END DO
    END DO

    DEALLOCATE(mapping)
    CLOSE(1)

    CALL Info( 'LoadGebhardtFactors', '...Done', Level=5 )

    RETURN

10  CONTINUE

    WRITE( Message, * ) 'Can not open file for GebhardtFactors: ',TRIM(FileName)
    CALL Fatal( 'LoadGebhardtFactors', Message )

  END SUBROUTINE LoadGebhardtFactors
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
!    Figure out requested coordinate system
!------------------------------------------------------------------------------
  SUBROUTINE SetCoordinateSystem( Model )
!------------------------------------------------------------------------------
     TYPE(Model_t), POINTER :: Model
!------------------------------------------------------------------------------
     LOGICAL :: Found, C(3)
     TYPE(Mesh_t), POINTER :: Mesh
     REAL(KIND=dp) :: x,y,z
     CHARACTER(LEN=MAX_NAME_LEN) :: csys

     csys = ListGetString( Model % Simulation, 'Coordinate System', Found )
     IF ( .NOT. Found ) Csys = 'cartesian'

     IF ( csys=='cartesian' .OR. csys=='polar' ) THEN
        Mesh => Model % Meshes
        x = Mesh % Nodes % x(1)
        y = Mesh % Nodes % y(1)
        z = Mesh % Nodes % z(1)
        c = .FALSE.
        DO WHILE( ASSOCIATED( Mesh ) )
           c(1) = c(1) .OR. ANY( Mesh % Nodes % x /= x )
           c(2) = c(2) .OR. ANY( Mesh % Nodes % y /= y )
           c(3) = c(3) .OR. ANY( Mesh % Nodes % z /= z )
           Mesh => Mesh % Next
        END DO
        Model % DIMENSION = COUNT( c )
     END IF

     SELECT CASE ( csys )
       CASE( 'cartesian' )
         Coordinates = Cartesian
       CASE( 'cartesian 1d' )
         Model % DIMENSION = 1
         Coordinates = Cartesian
       CASE( 'cartesian 2d' )
         Model % DIMENSION = 2
         Coordinates = Cartesian
       CASE( 'cartesian 3d' )
         Model % DIMENSION = 3
         Coordinates = Cartesian
       CASE( 'axi symmetric' )
         Model % DIMENSION = 2
         Coordinates = AxisSymmetric
       CASE( 'cylindric symmetric' )
         Model % DIMENSION = 2
         Coordinates = CylindricSymmetric
       CASE( 'cylindrical' )
         Model % DIMENSION = 3
         Coordinates = Cylindric
       CASE( 'polar' )
         Coordinates = Polar
       CASE( 'polar 2d' )
         Model % DIMENSION = 2
         Coordinates = Polar
       CASE( 'polar 3d' )
         Model % DIMENSION = 3
         Coordinates = Polar
       CASE DEFAULT
         WRITE( Message, * ) 'Unknown global coordinate system: ', TRIM(csys)
         CALL Fatal( 'SetCoordinateSystem', Message )
     END SELECT
!------------------------------------------------------------------------------
   END SUBROUTINE SetCoordinateSystem
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
! Function to read model from the ELMER DATA BASE 
!------------------------------------------------------------------------------
  FUNCTION LoadModel( ModelName,BoundariesOnly,numprocs,mype ) RESULT( Model )
!------------------------------------------------------------------------------
    IMPLICIT NONE

    CHARACTER(LEN=*) :: ModelName
    LOGICAL :: BoundariesOnly

    INTEGER, OPTIONAL :: numprocs,mype

    TYPE(Model_t), POINTER :: Model

!------------------------------------------------------------------------------
    TYPE(Mesh_t), POINTER :: Mesh,Mesh1,NewMesh,OldMesh
    INTEGER :: i,j,k,l,s,nlen,eqn,MeshKeep,MeshLevels
    LOGICAL :: GotIt,GotMesh,found,OneMeshName, OpenFile, Transient
    LOGICAL :: stat, single, MeshGrading
    TYPE(Solver_t), POINTER :: Solver
    INTEGER(KIND=AddrInt) :: InitProc
    INTEGER, POINTER :: ActiveSolvers(:)
    INTEGER :: Def_Dofs(6)
    REAL(KIND=dp) :: MeshPower
    REAL(KIND=dp), POINTER :: h(:)
    CHARACTER(LEN=MAX_NAME_LEN) :: Name,ElementDef
    CHARACTER(LEN=MAX_NAME_LEN) :: MeshDir,MeshName
TYPE(valuelist_t), POINTER :: lst
!------------------------------------------------------------------------------

    ALLOCATE( Model )
    CurrentModel => Model
    NULLIFY( Model % Variables )

    MeshDir  = ' '
    MeshName = ' '

    Model % DIMENSION = 0
    Model % NumberOfBoundaries = 0
    Model % NumberOfBodies     = 0
    Model % NumberOfICs        = 0
    Model % NumberOfBCs        = 0
    Model % NumberOfEquations  = 0
    Model % NumberOfSolvers    = 0
    Model % NumberOfMaterials  = 0
    Model % NumberOfBodyForces = 0

    INQUIRE( Unit=InFileUnit, OPENED=OpenFile )
    IF ( .NOT. OpenFile ) OPEN( Unit=InFileUnit, File=Modelname, STATUS='OLD' )
    CALL LoadInputFile( Model,InFileUnit,ModelName,MeshDir,MeshName, .TRUE., .TRUE. )
    REWIND( InFileUnit )
    CALL LoadInputFile( Model,InFileUnit,ModelName,MeshDir,MeshName, .TRUE., .FALSE. )
    IF ( .NOT. OpenFile ) CLOSE( InFileUnit )

    DO j=1,Model % NumberOfEquations
      IF (ListCheckPresent(Model % Equations(j) % Values, 'Element') ) THEN
        CALL Error('LM:', 'Depreciated: "Element" keyword  ' // &
          'in the "Equation" section, move to "Solver" section(s)' )
      END IF
    END DO

    Transient=ListGetString(Model % Simulation, &
                     'Simulation Type',Found)=='transient'

    Def_Dofs = -1; Def_Dofs(1)=1

    i = 1
    DO WHILE(i<=Model % NumberOFSolvers)

      Solver => Model % Solvers(i)
      Model % Solver => Solver

      Name = ListGetString( Solver  % Values, 'Procedure', Found )
      IF ( Found ) THEN
        InitProc = GetProcAddr( TRIM(Name)//'_Init0', abort=.FALSE. )
        IF ( InitProc /= 0 ) THEN
          CALL ExecSolver( InitProc, Model, Solver, &
                  Solver % dt, Transient )

          Solver => Model % Solvers(i)
          Model % Solver => Solver
        END IF
      END IF

      GotMesh = ListCheckPresent(Solver % Values, 'Mesh')

      ALLOCATE(Solver % Def_Dofs(Model % NumberOfBodies,6))
      Solver % Def_Dofs = -1; Solver % Def_Dofs(:,1)=1
      ElementDef = ListGetString( Solver % Values, 'Element', stat )
   
      IF (.NOT.stat) THEN
        Name = ListGetString(Solver % Values, 'Equation', stat)
        DO j=1,Model % NumberOfEquations
          IF (ListCheckPresent(Model % Equations(j) % Values, 'Element') ) THEN
            IF (ListGetLogical(Model % Equations(j) % Values,Name,Found) ) THEN
              ElementDef=ListGetString(Model % Equations(J) % Values, 'Element',stat)
              EXIT
            END IF
            ActiveSolvers => ListGetIntegerArray(Model % Equations(j) % Values, &
                    'Active Solvers', Found )
            IF ( Found ) THEN
              IF ( ANY(ActiveSolvers==i) ) THEN
                ElementDef=ListGetString(Model % Equations(J) % Values,'Element',stat)
                EXIT
              END IF
            END IF
          END IF
        END DO
      END IF

      IF ( .NOT. stat ) THEN
        IF ( ListGetLogical( Solver % Values, &
             'Discontinuous Galerkin', stat ) ) THEN
           Solver % Def_Dofs(:,4) = 0
           IF ( .NOT. GotMesh ) Def_Dofs(4) = MAX(Def_Dofs(4),0 )
           CYCLE
        ELSE
           ElementDef = "n:1"
        END IF
      END IF
          
      j = INDEX( ElementDef, 'n:' )
      IF ( j>0 ) THEN
        READ( ElementDef(j+2:), * ) l
        Solver % Def_Dofs(:,1) = l
        IF (.NOT. GotMesh ) Def_Dofs(1) = MAX(Def_Dofs(1), l)
      END IF
          
      j = INDEX( ElementDef, 'e:' )
      IF ( j>0 ) THEN
        READ( ElementDef(j+2:), * ) l
        Solver % Def_Dofs(:,2) = l
        IF ( .NOT. GotMesh ) Def_Dofs(2) = MAX(Def_Dofs(2), l )
      END IF
          
      j = INDEX( ElementDef, 'f:' )
      IF ( j>0 ) THEN
        READ( ElementDef(j+2:), * ) l
        Solver % Def_Dofs(:,3) = l
        IF ( .NOT. GotMesh ) Def_Dofs(3) = MAX(Def_Dofs(3), l )
      END IF
          
      j = INDEX( ElementDef, 'd:' )
      IF ( j>0 ) THEN
        READ( ElementDef(j+2:), * ) l
        Solver % Def_Dofs(:,4) = l
        IF ( .NOT. GotMesh ) Def_Dofs(4) = MAX(Def_Dofs(4), l )
      ELSE 
        IF ( ListGetLogical( Solver % Values, &
            'Discontinuous Galerkin', stat ) ) THEN
          Solver % Def_Dofs(:,4) = 0
          IF ( .NOT. GotMesh ) Def_Dofs(4) = MAX(Def_Dofs(4),0 )
        END IF
      END IF
          
      j = INDEX( ElementDef, 'b:' )
      IF ( j>0 ) THEN
        READ( ElementDef(j+2:), * ) l
        Solver % Def_Dofs(:,5) = l
        IF ( .NOT. GotMesh ) Def_Dofs(5) = MAX(Def_Dofs(5), l )
      END IF
          
      j = INDEX( ElementDef, 'p:' )
      IF ( j>0 ) THEN
        IF ( ElementDef(j+2:j+2)=='%' ) THEN
          Solver % Def_Dofs(:,6) = 0
        ELSE
          READ( ElementDef(j+2:), * ) l
          Solver % Def_Dofs(:,6) = l
          IF ( .NOT. GotMesh ) Def_Dofs(6) = MAX(Def_Dofs(6), l )
         END IF
      END IF

      i = i + 1
    END DO

    Name = ListGetString( Model % Simulation, 'Mesh', GotIt )

    OneMeshName = .FALSE.
    IF ( GotIt ) THEN
      k = 1
      i = 1
      nlen = LEN_TRIM(name)
      DO WHILE( k<=nlen .AND. name(k:k) /= ' ' )
        MeshDir(i:i)  = name(k:k)
        Meshname(i:i) = name(k:k)
        k = k + 1
        i = i + 1
      END DO

      DO WHILE( k<=nlen .AND. Name(k:k) == ' ' )
        k = k + 1
      END DO

      IF ( k<=nlen ) THEN
         MeshName(i:i) = '/'
         i = i + 1
         DO WHILE( name(k:k) /= ' ' )
           MeshName(i:i) = Name(k:k)
           k = k + 1
           i = i + 1
         END DO
      ELSE
         OneMeshName = .TRUE.
         MeshDir = "." // CHAR(0)
      END IF
      MeshName(i:i) = CHAR(0)
    END IF

    NULLIFY( Model % Meshes )
    IF ( MeshDir(1:1) /= ' ' ) THEN

      Model % Meshes => LoadMesh( Model, MeshDir, MeshName, &
          BoundariesOnly, numprocs, mype, Def_Dofs )

      CALL SetCoordinateSystem( Model )

      MeshLevels = ListGetInteger( Model % Simulation, 'Mesh Levels', GotIt )
      IF ( .NOT. GotIt ) MeshLevels=1

      MeshKeep = ListGetInteger( Model % Simulation, 'Mesh keep',  GotIt )
      IF ( .NOT. GotIt ) MeshKeep=MeshLevels

      MeshPower   = ListGetConstReal( Model % Simulation, 'Mesh Grading Power',GotIt)
      MeshGrading = ListGetLogical( Model % Simulation, 'Mesh Keep Grading', GotIt)

      DO i=2,MeshLevels
        OldMesh => Model % Meshes

        IF (MeshGrading) THEN
          ALLOCATE(h(OldMesh % NumberOfNodes))
          Model % Mesh => OldMesh
          CALL GetNodalElementSize(Model,MeshPower,.FALSE.,h)
          NewMesh => SplitMeshEqual(OldMesh,h)
          DEALLOCATE(h)
        ELSE
          NewMesh => SplitMeshEqual(OldMesh)
        END IF


        IF ( i>MeshLevels-MeshKeep+1 ) THEN
          NewMesh % Next => OldMesh
          NewMesh % Parent => OldMesh
          OldMesh % Child  => NewMesh
          NewMesh % Name = OldMesh % Name
          Newmesh % OutputActive = .TRUE.
          OldMesh % OutputActive = .FALSE.
        ELSE
          CALL ReleaseMesh(OldMesh)
        END IF
        Model % Meshes => NewMesh
      END DO


      IF ( OneMeshName ) THEN
         i = 0
      ELSE
         i = LEN_TRIM(MeshName)
         DO WHILE( i>0 .AND. MeshName(i:i) /= '/' )
           i = i-1
         END DO
      END IF

      i = i + 1
      k = 1
      Model % Meshes % Name = ' '
      DO WHILE( MeshName(i:i) /= CHAR(0) )
        Model % Meshes % Name(k:k) = MeshName(i:i)
        k = k + 1
        i = i + 1
      END DO

      DO i=1,Model % NumberOfSolvers
         Model % Solvers(i) % Mesh => Model % Meshes
      END DO
    END IF

    DO s=1,Model % NumberOfSolvers
      Name = ListGetString( Model % Solvers(s) % Values, 'Mesh', GotIt )
      IF ( GotIt ) THEN
        single=.FALSE.
        IF ( Name(1:8) == '-single ' ) THEN
          single=.TRUE.
          Name=Name(9:)
        END IF
        OneMeshName = .FALSE.
        k = 1
        i = 1
        nlen = LEN_TRIM(name)
        DO WHILE( k<=nlen .AND. name(k:k) /= ' ' )
          MeshDir(i:i)  = name(k:k)
          Meshname(i:i) = name(k:k)
          k = k + 1
          i = i + 1
        END DO

        DO WHILE( k<=nlen .AND. Name(k:k) == ' ' )
          k = k + 1
        END DO

        IF ( k<=nlen ) THEN
          MeshName(i:i) = '/'
          i = i + 1
          DO WHILE( name(k:k) /= ' ' )
            MeshName(i:i) = Name(k:k)
            k = k + 1
            i = i + 1
          END DO
        ELSE
          OneMeshName = .TRUE.
          MeshDir = "." // CHAR(0)
        END IF
        MeshName(i:i) = CHAR(0)

        IF ( OneMeshName ) THEN
          i = 0
        ELSE
          DO WHILE( i>0 .AND. MeshName(i:i) /= '/' )
            i = i - 1
          END DO
        END IF

        Mesh => Model % Meshes
        Found = .FALSE.
        DO WHILE( ASSOCIATED( Mesh ) )
           Found = .TRUE.
           k = 1
           j = i+1
           DO WHILE( MeshName(j:j) /= CHAR(0) )
              IF ( Mesh % Name(k:k) /= MeshName(j:j) ) THEN
                Found = .FALSE.
                EXIT
              END IF
              k = k + 1
              j = j + 1
           END DO
           IF ( LEN_TRIM(Mesh % Name) /= k-1 ) Found = .FALSE.
           IF ( Found ) EXIT
           Mesh => Mesh % Next
        END DO

        IF ( Found ) THEN
          Model % Solvers(s) % Mesh => Mesh
          CYCLE
        END IF

        DO i=1,6
          Def_Dofs(i) = MAXVAL(Model % Solvers(s) % Def_Dofs(:,i))
        END DO

        IF ( Single ) THEN
          Model % Solvers(s) % Mesh => &
            LoadMesh( Model,MeshDir,MeshName,BoundariesOnly,1,0,def_dofs )
        ELSE
          Model % Solvers(s) % Mesh => &
            LoadMesh( Model,MeshDir,MeshName,BoundariesOnly,numprocs,mype,Def_Dofs )
        END IF

        MeshLevels = ListGetInteger( Model % Solvers(s) % Values, 'Mesh Levels', GotIt )
        IF ( .NOT. GotIt ) MeshLevels=1

        MeshKeep = ListGetInteger( Model % Solvers(s) % Values, 'Mesh keep',  GotIt )
        IF ( .NOT. GotIt ) MeshKeep=MeshLevels

        MeshPower   = ListGetConstReal( Model % Simulation, 'Mesh Grading Power',GotIt)
        MeshGrading = ListGetLogical( Model % Simulation, 'Mesh Keep Grading', GotIt)


        DO i=2,MeshLevels
          OldMesh => Model % Solvers(s) % Mesh

          IF (MeshGrading) THEN
            ALLOCATE(h(OldMesh % NumberOfNodes))
            Model % Mesh => OldMesh
            CALL GetNodalElementSize(Model,MeshPower,.FALSE.,h)
            NewMesh => SplitMeshEqual(OldMesh,h)
            DEALLOCATE(h)
          ELSE
            NewMesh => SplitMeshEqual(OldMesh)
          END IF

          IF ( i>MeshLevels-MeshKeep+1 ) THEN
            NewMesh % Next => OldMesh
            NewMesh % Parent => OldMesh
            OldMesh % Child  => NewMesh
            NewMesh % Name = OldMesh % Name
            Newmesh % OutputActive = .TRUE.
            OldMesh % OutputActive = .FALSE.
          ELSE
            CALL ReleaseMesh(OldMesh)
          END IF
          Model % Solvers(s) % Mesh => NewMesh
        END DO

        IF ( OneMeshName ) i = 0

        k = 1
        i = i + 1
        Model % Solvers(s) % Mesh % Name = ' '
        DO WHILE( MeshName(i:i) /= CHAR(0) )
          Model % Solvers(s) % Mesh % Name(k:k) = MeshName(i:i)
          k = k + 1
          i = i + 1
        END DO

        IF ( ASSOCIATED( Model % Meshes ) ) THEN
          Mesh1 => Model % Meshes
          DO WHILE( ASSOCIATED( Mesh1 % Next ) ) 
            Mesh1 => Mesh1 % Next
          END DO
          Mesh1 % Next => Model % Solvers(s) % Mesh
        ELSE
          Model % Meshes => Model % Solvers(s) % Mesh
        END IF
      END IF
    END DO

    CALL SetCoordinateSystem( Model )
  
    IF ( OutputPath == ' ' ) THEN
      DO i=1,MAX_NAME_LEN
        IF ( MeshDir(i:i) == CHAR(0) ) EXIT
        OutputPath(i:i) = MeshDir(i:i)
      END DO
    END IF

    Mesh => Model % Meshes
    DO WHILE( ASSOCIATED( Mesh ) )
       CALL MeshStabParams( Mesh )
       Mesh => Mesh % Next
    END DO
!------------------------------------------------------------------------------
  END FUNCTION LoadModel
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
  FUNCTION SaveResult( Filename,Mesh,Time,SimulationTime,Binary,SaveAll,&
                       FreeSurface ) RESULT(SaveCount)
!------------------------------------------------------------------------------
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER :: Time,SaveCount
    CHARACTER(LEN=*) :: Filename
    REAL(KIND=dp) :: SimulationTime
    LOGICAL :: Binary,SaveAll
    LOGICAL, OPTIONAL :: FreeSurface

!------------------------------------------------------------------------------

    TYPE(Element_t), POINTER :: CurrentElement
    INTEGER :: i,j,k,DOFs, dates(8), n
    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=MAX_NAME_LEN) :: FName, PosName, DateStr
    LOGICAL :: FreeSurfaceFlag, MoveBoundary, GotIt
    INTEGER, POINTER :: PrevPerm(:) 
    INTEGER(IntOff_k) :: PrevPermPos, Pos
    INTEGER(IntOff_k), SAVE :: VarPos(MAX_OUTPUT_VARS) = 0
    CHARACTER(1) :: E

!------------------------------------------------------------------------------
!   If first time here, count number of variables
!------------------------------------------------------------------------------
    FName = FileName
    IF ( .NOT. FileNameQualified(FileName) ) THEN
      IF ( LEN_TRIM(OutputPath) > 0 ) THEN
        FName = TRIM(OutputPath) // '/' // TRIM(FileName)
      END IF
    END IF
    PosName = TRIM(FName) // ".pos"

    IF ( PRESENT( FreeSurface ) ) THEN
      FreeSurfaceFlag = FreeSurface
    ELSE
       FreeSurfaceFlag = .FALSE.
       MoveBoundary    = .FALSE.
       DO i=1,CurrentModel % NumberOfBCs
         FreeSurfaceFlag = FreeSurfaceFlag .OR. ListGetLogical( &
            CurrentModel % BCs(i) % Values,'Free Surface', GotIt )
         IF ( FreeSurfaceFlag ) THEN
            MoveBoundary =  ListGetLogical( &
                CurrentModel % BCs(i) % Values,'Internal Move Boundary', GotIt )
         
            IF ( .NOT. GotIt ) MoveBoundary = .TRUE.

            FreeSurfaceFlag = FreeSurfaceFlag .AND. MoveBoundary
         END IF

         IF ( FreeSurfaceFlag ) EXIT
       END DO
    END IF

    ! The first time we start by writing the header.
    IF ( Mesh % SavesDone == 0 ) THEN
      CALL InitializeFile( OutputUnit, FName, PosUnit, PosName )

      DateStr = FormatDate()
      WRITE( OutputUnit, '("!File started at: ",A)' ) TRIM(DateStr)
      DOFs = 0
      Var => Mesh % Variables
      WRITE( OutputUnit,* ) 'Degrees of freedom: '


      DO WHILE( ASSOCIATED(Var) )
        IF ( Var % Output ) THEN
           IF ( Var % DOFs > 1 .AND. SIZE(Var % Values)>1 ) THEN
             k = LEN_TRIM(Var % Name)
             IF ( Var % Name(1:10) /= 'coordinate' .OR. FreeSurfaceFlag ) THEN
               WRITE( OutputUnit,* ) Var % Name(1:k),Var % DOFs, &
                  ' :', 'fs' ! TRIM(ListGetString( Var % Solver % Values, 'Equation' ))
             ELSE 
!              WRITE( OutputUnit,* ) Var % Name(1:k),Var % DOFs, &
!              ':eq'
             END IF
           END IF
        END IF

        Var => Var % Next
      END DO 

      i = 1
      Var => Mesh % Variables
      DO WHILE( ASSOCIATED(Var) )
        IF ( Var % Output ) THEN

           IF ( Var % DOFs == 1 .AND. SIZE(Var % Values)>1 ) THEN
             k = LEN_TRIM(Var % Name)
             IF ( Var % Name(1:10) /= 'coordinate' .OR. FreeSurfaceFlag ) THEN
               WRITE( OutputUnit,* ) Var % Name(1:k),Var % DOFs, &
                ' :', 'fs' ! TRIM(ListGetString( Var % Solver % Values, 'Equation' ))
               IF ( Var % DOFs == 1 ) DOFs = DOFs + 1

               IF ( Binary ) THEN
                  CALL BinWriteString( PosUnit, Var % Name(1:k) )
                  i = i + 1
               END IF
             ELSE
!              IF ( Var % DOFs == 1 ) DOFs = DOFs + 1
!              WRITE( OutputUnit,* ) Var % Name(1:k),Var % DOFs, &
!               ':eq'
             END IF
           END IF
        END IF
        Var => Var % Next
      END DO 
      WRITE(OutputUnit,*) 'Total DOFs: ', DOFs
      WRITE(OutputUnit,*) 'Number Of Nodes: ', Mesh % NumberOfNodes

      IF ( Binary ) THEN
         ! Jump to the beginning (remembering the initial L|B!) in the positions
         ! file to fill in the number of variables, then jump back here again.
         Pos = BinFTell( PosUnit )
         CALL BinFSeek( PosUnit, 1_IntOff_k, BIN_SEEK_SET )
         CALL BinWriteInt4( PosUnit, i-1 )
         CALL BinFSeek( PosUnit, Pos, BIN_SEEK_SET )

         CALL SwitchToBinary( OutputUnit,FName,Mesh % NumberOfNodes )
      END IF
    ELSE
      CALL AppendOpen( OutputUnit,FName,PosUnit,PosName )
    END IF

    CALL WriteTime( OutputUnit,PosUnit,Mesh % SavesDone+1, Time, SimulationTime )

!------------------------------------------------------------------------------
!   Write data to disk
!------------------------------------------------------------------------------
    PrevPerm => NULL()
    Var => Mesh % Variables
    j = 1
    DO WHILE( ASSOCIATED(Var) )
      IF ( Var % Output .AND. Var % DOFs==1 .AND. SIZE(Var % Values)>1 ) THEN

         k = LEN_TRIM(Var % Name)
         IF ( Var % Name(1:10) /= 'coordinate' .OR. FreeSurfaceFlag ) THEN
            IF ( SaveAll .OR. Var % ValuesChanged ) THEN
               CALL WriteVarName( OutputUnit,PosUnit,Var % Name(1:k),VarPos(j) )
               CALL WritePerm( OutputUnit, Var % Perm, PrevPerm )
   
               IF ( ASSOCIATED(Var % Perm) ) THEN
                  n = SIZE(Var % Perm)
               ELSE
                  n = Mesh % NumberOfNodes
               END IF

               DO i=1, n
                  k = 1
                  IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(i)
                  IF ( k > 0 ) THEN
                     CALL WriteReal( OutputUnit,Var % Values(k) )
                  END IF
               END DO
               Var % ValuesChanged = .FALSE.
            ELSE
               IF ( Binary ) CALL BinWriteInt8( PosUnit,INT(VarPos(j),Int8_k) )
            END IF
            j = j + 1
         END IF
      END IF
      Var => Var % Next
    END DO 

    IF ( Binary ) THEN
      CALL BinClose( OutputUnit )
      CALL BinClose( PosUnit )
    ELSE
      CLOSE( OutputUnit )
    END IF

    Mesh % SavesDone = Mesh % SavesDone + 1
    SaveCount = Mesh % SavesDone 

  CONTAINS

      SUBROUTINE WritePerm( OutputUnit, CurrPerm, PrevPerm )
         INTEGER, INTENT(IN) :: OutputUnit
         INTEGER, POINTER :: CurrPerm(:), PrevPerm(:)
         INTEGER :: i, n
         LOGICAL :: SameAsPRev

         IF ( .NOT.ASSOCIATED( CurrPerm ) ) THEN

            IF ( Binary ) THEN
               CALL BinWriteInt4( OutputUnit,0 )
            ELSE
               WRITE( OutputUnit, '(A)' ) 'Perm: NULL'
            END IF

         ELSE
         
            SameAsPrev = .FALSE.
            IF ( ASSOCIATED( CurrPerm, PrevPerm ) ) THEN
               SameAsPrev = .TRUE.
            ELSE IF ( ASSOCIATED( PrevPerm ) ) THEN
               IF ( SIZE(CurrPerm) == SIZE(PrevPerm) ) THEN
                  IF ( ALL( CurrPerm == PrevPerm ) ) SameAsPrev = .TRUE.
               END IF
            END IF

            IF ( SameAsPrev ) THEN

               IF ( Binary ) THEN
                  CALL BinWriteInt4( OutputUnit,-1 )
                  CALL BinWriteInt8( OutputUnit,INT( PrevPermPos,Int8_k ) )
               ELSE
                  WRITE( OutputUnit, '(A)' ) 'Perm: use previous'
               END IF

            ELSE

               PrevPerm => Var % Perm

               n = COUNT( CurrPerm > 0 )
               IF ( Binary ) THEN
                  PrevPermPos = BinFTell( OutputUnit )
                  CALL BinWriteInt4( OutputUnit, SIZE(CurrPerm) )
                  CALL BinWriteInt4( OutputUnit, n )
                  DO i = 1, SIZE( CurrPerm )
                     IF ( CurrPerm(i) > 0 ) THEN
                        CALL BinWriteInt4( OutputUnit,i )
                        CALL BinWriteInt4( OutputUnit,CurrPerm(i) )
                     END IF
                  END DO
               ELSE
                  WRITE( OutputUnit,'(A,i12," ",i12)') 'Perm: ', SIZE(CurrPerm), n
                  DO i = 1, SIZE( CurrPerm )
                     IF ( CurrPerm(i) > 0 ) THEN
                        WRITE( OutputUnit, '(2i11)' ) i,CurrPerm(i)
                     END IF
                  END DO
               END IF

            END IF

         END IF
      END SUBROUTINE WritePerm


      SUBROUTINE WriteVarName( OutputUnit,PosUnit,Name,VarPos )
         INTEGER, INTENT(IN) :: OutputUnit,PosUnit
         CHARACTER(*), INTENT(IN) :: Name
         INTEGER(IntOff_k), INTENT(OUT) :: VarPos

         IF ( Binary ) THEN
            VarPos = BinFTell( OutputUnit )
            CALL BinWriteInt8( PosUnit, INT(VarPos,Int8_k) )

            CALL BinWriteString( OutputUnit,TRIM(Name) )
         ELSE
            WRITE( OutputUnit,'(a)' ) TRIM(Name)
         END IF
      END SUBROUTINE WriteVarName
        

      SUBROUTINE WriteReal( OutputUnit,r )
         INTEGER, INTENT(IN) :: OutputUnit
         REAL(dp), INTENT(IN) :: r

         IF ( Binary ) THEN
            CALL BinWriteDouble( OutputUnit,r )
         ELSE
            WRITE( OutputUnit,* ) r
         END IF
      END SUBROUTINE WriteReal


      SUBROUTINE WriteTime( OutputUnit,PosUnit,SavesDone,nTime,SimulationTime )
         INTEGER, INTENT(IN) :: OutputUnit, PosUnit
         INTEGER, INTENT(IN) :: SavesDone,nTime
         REAL(dp), INTENT(IN) :: SimulationTime
         INTEGER(IntOff_k) :: Pos

         IF ( Binary ) THEN
            Pos = BinFTell( OutputUnit )
            CALL BinWriteInt8( PosUnit, INT(Pos,Int8_k) )

            CALL BinWriteString( OutputUnit, 'Time:' )
            CALL BinWriteInt4( OutputUnit, SavesDone )
            CALL BinWriteInt4( OutputUnit, nTime )
            CALL BinWriteDouble( OutputUnit, SimulationTime )
         ELSE
            WRITE( OutputUnit,'(a,i7,i7,E20.11E3)' ) 'Time: ',SavesDone,nTime, &
                                                   SimulationTime
         END IF
      END SUBROUTINE WriteTime


      SUBROUTINE AppendOpen( OutputUnit,FName,PosUnit,PosName )
         INTEGER, INTENT(IN) :: OutputUnit
         CHARACTER(*), INTENT(IN) :: FName
         INTEGER, INTENT(IN) :: PosUnit
         CHARACTER(*), INTENT(IN) :: PosName

         IF ( Binary ) THEN
            CALL BinOpen( OutputUnit,FName,"APPEND" )
            CALL BinOpen( PosUnit,PosName,"APPEND" )
         ELSE
            OPEN( OutputUnit,FILE=FName,STATUS="OLD",POSITION="APPEND" )
         END IF
      END SUBROUTINE AppendOpen
      

      SUBROUTINE SwitchToBinary( OutputUnit,FName,nNodes )
         INTEGER, INTENT(IN) :: OutputUnit
         CHARACTER(*), INTENT(IN) :: FName
         INTEGER, INTENT(IN) :: nNodes

         CLOSE( OutputUnit )
         CALL BinOpen( OutputUnit, TRIM(FName), "APPEND" )

         ! The binary part starts with a NULL byte.
         CALL BinWriteString( OutputUnit, "" )
      END SUBROUTINE SwitchToBinary
      

      SUBROUTINE InitializeFile( OutputUnit,FName,PosUnit,PosName )
         INTEGER, INTENT(IN) :: OutputUnit
         CHARACTER(*), INTENT(IN) :: FName
         INTEGER, INTENT(IN) :: PosUnit
         CHARACTER(*), INTENT(IN) :: PosName

         IF ( Binary ) THEN
            CALL BinEndianess( E )
            OPEN( OutputUnit,File=FName,STATUS='UNKNOWN' )
            WRITE( OutputUnit, * ) 'BINARY 2.', E

            CALL BinOpen( PosUnit,PosName,'WRITE' )
            CALL BinWriteChar( PosUnit,E )
            ! Make room for number of variables, we fill it in later
            CALL BinWriteInt4( PosUnit, 0 )
         ELSE
            OPEN( OutputUnit,File=FName,STATUS='UNKNOWN' )
            WRITE( OutputUnit, * ) 'ASCII 1'
         END IF
      END SUBROUTINE InitializeFile

!------------------------------------------------------------------------------
  END FUNCTION SaveResult
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE LoadRestartFile( RestartFile,TimeCount,Mesh,Continuous,EOF )
    CHARACTER(LEN=*) :: RestartFile
    INTEGER :: TimeCount
    TYPE(Mesh_T), POINTER :: Mesh
    LOGICAL, OPTIONAL :: Continuous,EOF
!------------------------------------------------------------------------------
    TYPE(Variable_t),POINTER :: Var, Comp
    CHARACTER(LEN=MAX_NAME_LEN) :: Row,Name,PosName
    CHARACTER(LEN=MAX_PATH_LEN) :: FName,Trash
    INTEGER ::i,j,k,n,nt,Node,DOFs,SavedCount,Timestep,NSDOFs,nlen
    INTEGER :: nNodes, Stat
    INTEGER, SAVE :: FmtVersion
    INTEGER, POINTER, SAVE :: Perm(:)

    TYPE(Solver_t),   POINTER :: Solver
    TYPE(Variable_t), POINTER :: TimeVar, tStepVar

    LOGICAL :: RestartFileOpen = .FALSE., Cont
    LOGICAL, SAVE :: PosFile = .FALSE.
    LOGICAL, SAVE :: Binary

    REAL(KIND=dp) :: Dummy,value,Time
    REAL(KIND=dp), POINTER :: Component(:), Temp(:)
    REAL(KIND=dp), POINTER :: Velocity1(:),Velocity2(:),Velocity3(:),Pressure(:)
    INTEGER(KIND=IntOff_k) :: Pos
    CHARACTER(1) :: E
    REAL(dp) :: tstart, tstop
    SAVE DOFs

    CALL CPU_TIME(tstart)
    Perm => NULL()
!------------------------------------------------------------------------------
!   Open restart file and search for the right position
!------------------------------------------------------------------------------
    CALL Info( 'LoadRestartFile',' ', Level = 3)
    CALL Info( 'LoadRestartFile','--------------------------------------------', Level=3 )
    CALL Info( 'LoadRestartFile','Reading data from file: '//TRIM(RestartFile), Level = 3 )

    Cont = .FALSE.
    IF ( PRESENT( Continuous ) ) Cont = Continuous
    IF ( PRESENT( EOF ) ) EOF = .FALSE.

    IF ( Cont .AND. RestartFileOpen ) GOTO 30

    IF ( .NOT. FileNameQualified(RestartFile) .AND. LEN_TRIM(OutputPath)>0 ) THEN
      FName = TRIM(OutputPath) // '/' // TRIM(RestartFile)
    ELSE
      FName = RestartFile
    END IF
    OPEN( RestartUnit,File=TRIM(FName),STATUS='OLD',ERR=10 )

    GOTO 20

10 CONTINUE

    CALL Error( 'LoadRestartFile','=======================================' )
    CALL Error( 'LoadRestartFile','' )
    CALL Error( 'LoadRestartFile','Could not open file "'//TRIM(FName)//'"' )
    CALL Error( 'LoadRestartFile','No restart possible!' )
    CALL Error( 'LoadRestartFile','' )
    CALL Error( 'LoadRestartFile','=======================================' )
    RETURN

20  CONTINUE

    RestartFileOpen = .TRUE.

    READ( RestartUnit, '(A)' ) Row
    IF ( Row(3:8) == 'BINARY' ) THEN
        Binary = .TRUE.
        FmtVersion = 1
        E = Row(1:1)
        CALL Info( 'LoadRestartFile', TRIM(Row(3:)), Level=3 )
    ELSE IF ( Row(2:7) == 'BINARY' ) THEN
        Binary = .TRUE.
        FmtVersion = 2
        i = INDEX( Row, "." )
        E = Row(i+1:i+1)
        CALL Info( 'LoadRestartFile', TRIM(Row(2:)), Level=3 )
    ELSE IF ( Row(2:7) == 'ASCII' ) THEN
        Binary = .FALSE.
        FmtVersion = 1
        CALL Info( 'LoadRestartFile', TRIM(Row(2:)), Level=3 )
    ELSE 
        Binary = .FALSE.
        FmtVersion = 0
        CALL Info( 'LoadRestartFile', 'ASCII 0', Level=3 )
    END IF
    CALL Info( 'LoadRestartFile',' ', Level = 3)

    DO WHILE( ReadAndTrim(RestartUnit,Row) )
      IF ( Row(1:18) == 'degrees of freedom' ) EXIT
    END DO

!------------------------------------------------------------------------------
    DO WHILE( ReadAndTrim(RestartUnit,Row) )

      nlen = LEN_TRIM(Row)
      IF ( Row(1:11) == 'total dofs:' ) THEN
        READ( Row(12:),* ) DOFs
        EXIT
      END IF

      k = INDEX(Row,']')+1
      k = k+INDEX(Row(k:),':')-1

      NULLIFY(Solver)
      DO i = 1,CurrentModel % NumberOfSolvers
        Solver => CurrentModel % Solvers(i)
        IF ( Row(k+1:nlen)==ListGetString(Solver % Values, 'Equation')) EXIT
      END DO

      DO j=k-1,1,-1
        IF ( Row(j:j) /= ' ' ) EXIT
      END DO

      DO k=j,1,-1
        IF ( Row(k:k) == ' ' ) EXIT
      END DO

      j = INDEX(Row,'[')
      IF ( j>0 ) THEN
        Var => VariableGet( Mesh % Variables, TRIM(Row(1:j-1)),.TRUE. )
      ELSE
        Var => VariableGet( Mesh % Variables, TRIM(Row(1:k-1)),.TRUE. )
      END IF

      IF ( .NOT.ASSOCIATED(Var) ) THEN

        READ(Row(k+1:),*) DOFs

        ALLOCATE( Var )
        ALLOCATE( Var % Values(Mesh % NumberOfNodes*DOFs) )
        Var % Values = 0

        ALLOCATE( Var % Perm(Mesh % NumberOfNodes) )
        Var % Perm = -1

        IF ( row(1:14) == 'flow solution ' ) THEN
!------------------------------------------------------------------------------
!         First add components to the variable list separately...
!         (must be done this way for the output routines to work properly...)
!----------------------------------------------------------------------------
          NSDOFs = CoordinateSystemDimension() + 1
          IF ( Coordinates == CylindricSymmetric ) NSDOFs = NSDOFs + 1

          Velocity1 => Var % Values(1:NSDOFs*Mesh % NumberOfNodes:NSDOFs)
          CALL VariableAdd( Mesh % Variables,  Mesh, Solver, 'Velocity 1', &
                       1, Velocity1, Var % Perm )

          Velocity2 => Var % Values(2:NSDOFs*mesh % NumberOfNodes:NSDOFs)
          CALL VariableAdd( Mesh % Variables, Mesh, Solver, 'Velocity 2', &
                       1, Velocity2, Var % Perm )
  
          IF ( NSDOFs == 3 ) THEN
            Pressure => Var % Values(3:NSDOFs*Mesh % NumberOfNodes:NSDOFs)
            CALL VariableAdd( Mesh % Variables, Mesh, Solver, 'Pressure', &
                       1, Pressure, Var % Perm )
          ELSE
            Velocity3 => Var % Values(3:NSDOFs*Mesh % NumberOfNodes:NSDOFs)
            CALL VariableAdd( Mesh % Variables, Mesh, Solver, 'Velocity 3', &
                       1, Velocity3, Var % Perm )

            Pressure => Var % Values(4:NSDOFs*Mesh % NumberOfNodes:NSDOFs)
             CALL VariableAdd( Mesh % Variables, Mesh, Solver, 'Pressure', &
                         1, Pressure, Var % Perm )
           END IF
!------------------------------------------------------------------------------
!        Then add the thing itself
!------------------------------------------------------------------------------
         CALL VariableAdd( Mesh % Variables, Mesh, Solver, &
                'Flow Solution',NSDOFs,Var % Values,Var % Perm )
        ELSE
          IF ( DOFs > 1 ) THEN
            DO i=1,DOFs
              Component => Var % Values(i:DOFs*Mesh % NumberOfNodes:DOFs)
              name = ComponentName( TRIM(row(1:k-1)), i )
              CALL VariableAdd( Mesh % Variables,  Mesh, Solver, name, &
                           1, Component, Var % Perm )
            END DO
          END IF
          CALL VariableAdd( Mesh % Variables, Mesh, Solver, &
              Row(1:k-1),DOFs,Var % Values,Var % Perm )
        END IF
      END IF
    END DO

    IF ( Binary ) THEN
      ! Switch to binary reading
      CLOSE( RestartUnit )
      CALL BinOpen( RestartUnit,FName,"read" )
      CALL BinSetInputEndianess( RestartUnit,E )
      CALL BinReadString( RestartUnit,Trash ) !Skip header; we read it already

      PosName = TRIM(FName) // '.pos'
      INQUIRE( FILE=PosName, EXIST=PosFile )
      IF ( PosFile ) THEN
         CALL BinOpen( PosUnit,PosName,'read' )
         CALL BinReadString( PosUnit,E ) 
         CALL BinSetInputEndianess( PosUnit,E )
      END IF
    END IF

30  CONTINUE

!------------------------------------------------------------------------------
!   ...read one timestep to memory...
!------------------------------------------------------------------------------
    TimeVar  => VariableGet( Mesh % Variables, 'Time' )
    tStepVar => VariableGet( Mesh % Variables, 'Timestep' )

    IF ( Cont ) THEN
       nt = TimeCount
    ELSE
       nt = 1
    END IF

    IF ( PosFile ) THEN
      ! If TimeCount == 0, we'll get the last time step
      Pos = GetPosition( PosUnit,TimeCount,0,TimeCount )
      nt = TimeCount
      CALL BinFSeek( RestartUnit,Pos,BIN_SEEK_SET )
    END IF

    DO WHILE( nt <= TimeCount .OR. TimeCount == 0 )
      CALL ReadTime( RestartUnit,SavedCount,Timestep,Time,Stat )

      IF ( Stat /= 0 ) THEN
         IF ( PRESENT( EOF ) ) THEN
            EOF = .TRUE.
         ELSE IF ( TimeCount /= 0 ) THEN
            CALL Warn( 'LoadRestartFile','Did not find data at the requested point' )
            WRITE( Message,'(A,I6)') 'Reading from the last existing point: ',nt-1
            CALL Warn( 'LoadRestartFile',Message)
         END IF
         EXIT
      END IF

      IF ( ASSOCIATED( TimeVar ) )  TimeVar % Values(1)  = Time
      IF ( ASSOCIATED( tStepVar ) ) tStepVar % Values(1) = Timestep

      DO i=1,DOFs
         IF ( PosFile ) THEN
            Pos = GetPosition( PosUnit,TimeCount,i )
            CALL BinFSeek( RestartUnit,Pos,BIN_SEEK_SET )
         END IF

         CALL ReadVariableName( RestartUnit,Row,Stat )
         ! If not all varibales were saved for this time step, and we're not
         ! using a .pos file, we may have reached the end even though i < DOFs.
         IF ( Stat /= 0 ) EXIT
         IF ( Row(1:5) == "Time:" ) THEN
            CALL UnReadLine( RestartUnit, Row )
            EXIT
         END IF

         Var => VariableGet( Mesh % Variables,Row, ThisOnly=.TRUE. )

         IF ( FmtVersion > 0 ) THEN
            CALL ReadPerm( RestartUnit, Var % Perm, Perm )
         END IF

         IF ( ASSOCIATED(Var) ) THEN
   
            IF ( ASSOCIATED(Var % Perm) .AND. FmtVersion > 0 ) THEN
               n = SIZE(Var % Perm)
            ELSE
               n = Mesh % NumberOfNodes
            END IF

            DO j=1, n
               IF ( FmtVersion > 0 ) THEN
                  CALL GetValue( RestartUnit, Perm, j, k, value )
               ELSE
                  READ( RestartUnit,* ) Node, k, value
               END IF

               IF ( .NOT. ASSOCIATED( Var % Perm ) ) THEN
                  IF ( k > 0 ) Var % Values(k) = value
               ELSE IF ( Var % Perm(j) <= 0 ) THEN
                  Var % Perm(j) = k
                  IF ( k > 0 ) Var % Values(k) = value
               ELSE IF ( Var % Perm(j) > 0 ) THEN
                  IF ( k > 0 ) Var % Values(Var % Perm(j)) = value
               END IF
            END DO

            CALL InvalidateVariable( CurrentModel % Meshes, Mesh, Row )
         END IF

      END DO
      nt = nt + 1
    END DO
!------------------------------------------------------------------------------
    IF ( .NOT. Cont ) THEN
      IF ( Binary ) THEN
         CALL BinClose( RestartUnit )
         IF ( PosFile ) CALL BinClose( PosUnit )
       ELSE
         CLOSE( RestartUnit )
       END IF
       RestartFileOpen = .FALSE.
    END IF

    ! Change variable allocations to correct sizes,
    ! first for vectors...
    ! ---------------------------------------------
    Var => Mesh % Variables
    DO WHILE(ASSOCIATED(Var))
      IF ( ASSOCIATED(Var % Perm) .AND. Var % DOFs>1 ) THEN
        n = Var % DOFs*COUNT(Var % Perm>0)
        IF ( SIZE(Var % Values) /= n) THEN
          ALLOCATE(Temp(n))
          Temp = Var % Values(1:n)
          DEALLOCATE(Var % Values)
          Var % Values => Temp
          DO i=1,Var % DOFs
            Comp => VariableGet(Mesh % Variables, &
                  ComponentName(Var,i),ThisOnly=.TRUE.)
            Comp % Values => Var % Values(i::Var % DOFs)
          END DO
        END IF
      END IF
      Var => Var % Next
    END DO

    !... and then for scalars
    ! -----------------------
    Var => Mesh % Variables
    DO WHILE(ASSOCIATED(Var))
      IF ( ASSOCIATED(Var % Perm) .AND. Var % DOFs==1 ) THEN
        n = COUNT(Var % Perm>0)
        IF ( SIZE(Var % Values) /= n) THEN
          ALLOCATE(Temp(n))
          Temp = Var % Values(1:n)
          DEALLOCATE(Var % Values)
          Var % Values => Temp
        END IF
      END IF
      Var => Var % Next
    END DO

    CALL CPU_TIME(tstop)
    
    WRITE( Message,* ) 'Restart time = ', tstop - tstart
    CALL Info( 'LoadRestartFile',Message)
    CALL Info( 'LoadRestartFile', 'All done', Level=3 )
    CALL Info( 'LoadRestartFile','--------------------------------------------', Level=3 )
    CALL Info( 'LoadRestartFile', ' ', Level = 3 )


CONTAINS

   SUBROUTINE UnReadLine( Unit,Line )
      INTEGER, INTENT(IN) :: Unit
      CHARACTER(*), INTENT(IN) :: Line
      INTEGER(IntOff_k) :: Offset

      IF ( Binary ) THEN
         Offset = LEN_TRIM(Line) + 1
         CALL BinFSeek( Unit, -Offset, BIN_SEEK_CUR )
      ELSE
         BACKSPACE Unit
      END IF
   END SUBROUTINE UnReadLine


   INTEGER(IntOff_k) FUNCTION GetPosition( PosUnit,TimeStep,VarNr,FoundTStep ) &
                     RESULT(Pos)
      INTEGER, INTENT(IN) :: PosUnit
      INTEGER, INTENT(IN) :: TimeStep
      INTEGER, INTENT(IN) :: VarNr  ! 0 = time, 1 = first var, etc.
      INTEGER, INTENT(OUT),OPTIONAL :: FoundTStep
      CHARACTER(40) :: VarName
      INTEGER :: iTime, nVar, i, Stat
      INTEGER(IntOff_k) :: Offset
      INTEGER(Int8_k) :: tmp
      INTEGER(IntOff_k), SAVE :: HeaderEnd, TimeStepSize = 0

      IF ( TimeStepSize == 0 ) THEN
         CALL BinReadInt4( PosUnit, nVar )
         TimeStepSize = (nVar + 1)*8 ! 8 bytes per variable + 8 bytes for time

         DO i = 1, nVar
            CALL BinReadString( PosUnit, VarName )
         END DO

         HeaderEnd = BinFTell( PosUnit )
      END IF

      IF ( TimeStep > 0 ) THEN
         Offset = (TimeStep - 1)*TimeStepSize + VarNr*8
         CALL BinFSeek( PosUnit, HeaderEnd + Offset, BIN_SEEK_SET )
         CALL BinReadInt8( PosUnit, tmp, Stat )

         IF ( Stat == 0 ) THEN
            Pos = tmp
            IF ( PRESENT(FoundTStep) ) FoundTStep = TimeStep
         ELSE
            CALL Warn( 'LoadRestartFile',&
                 'Did not find the the requested timestep in the positions file;' )
            CALL Warn( 'LoadRestartFile','using the last found one instead.')
            CALL BinFSeek( PosUnit, -TimeStepSize + VarNr*8 , BIN_SEEK_END )
            CALL BinReadInt8( PosUnit, tmp )
            Pos = tmp

            IF ( PRESENT(FoundTStep) ) THEN
               CALL BinFSeek( PosUnit, 0_IntOff_k, BIN_SEEK_END )
               Offset = BinFTell( PosUnit )
               FoundTStep = (Offset - HeaderEnd - VarNr*8)/TimeStepSize
            END IF
         END IF
      ELSE
         ! Find last time step
         CALL BinFSeek( PosUnit, -TimeStepSize + VarNr*8 , BIN_SEEK_END )
         CALL BinReadInt8( PosUnit, tmp )
         Pos = tmp
         IF ( PRESENT(FoundTStep) ) THEN
            CALL BinFSeek( PosUnit, 0_IntOff_k, BIN_SEEK_END )
            Offset = BinFTell( PosUnit )
            FoundTStep = (Offset - HeaderEnd - VarNr*8)/TimeStepSize
         END IF
      END IF
   END FUNCTION GetPosition
      

   SUBROUTINE GetValue( RestartUnit, Perm, iNode, iPerm, Value )
   !
   ! Get iPerm = Perm(iNode) and Value from input
   !
      INTEGER, INTENT(IN) :: RestartUnit
      INTEGER, POINTER :: Perm(:)
      INTEGER, INTENT(IN) :: iNode
      INTEGER, INTENT(OUT) :: iPerm
      REAL(dp), INTENT(OUT) :: Value

      IF ( ASSOCIATED( Perm ) ) THEN
         iPerm = Perm(iNode)
      ELSE
         iPerm = iNode
      END IF

      IF ( iPerm > 0 ) THEN
         IF ( Binary ) THEN
            CALL BinReadDouble( RestartUnit, Value )
         ELSE
            READ( RestartUnit, * ) Value
         END IF
      END IF
   END SUBROUTINE GetValue
    

   SUBROUTINE ReadPerm( RestartUnit, VarPerm, Perm )
      INTEGER, INTENT(IN) :: RestartUnit
      INTEGER, POINTER :: VarPerm(:)
      INTEGER, POINTER :: Perm(:)
      INTEGER :: nPerm, nPositive, i, j
      CHARACTER(MAX_NAME_LEN) :: Row
      INTEGER(Int8_k) :: Pos

      IF ( Binary ) THEN
         CALL BinReadInt4( RestartUnit, nPerm )
      ELSE
         READ( RestartUnit, '(A)' ) Row
         IF ( Row(7:10) == "NULL" ) THEN
            nPerm = 0
         ELSE IF ( Row(7:18) == "use previous" ) THEN
            nPerm = -1
         ELSE
            READ( Row(7:),* ) nPerm, nPositive
         END IF
      END IF

      IF ( nPerm < 0 ) THEN
         IF ( Binary ) CALL BinReadInt8( RestartUnit, Pos )
         ! At the moment, we allways read all variables, and can therefore
         ! safely assume that the "previous" Perm table has been read and is
         ! held in memory at this point. In the future, however, we might be
         ! asked to read only some variables, in which case the previous Perm
         ! table might be yet unread so we need to jump back to 'Pos' and read
         ! it from there.
         RETURN
      ELSE IF ( nPerm == 0 ) THEN
         IF ( ASSOCIATED(Perm) ) DEALLOCATE( Perm )
         RETURN
      ELSE 
         IF ( Binary ) CALL BinReadInt4( RestartUnit, nPositive )
      END IF

      ALLOCATE( Perm(nPerm) )
      Perm = 0.0d0

      DO i = 1, nPositive
         IF ( Binary ) THEN
            CALL BinReadInt4( RestartUnit, j )
            CALL BinReadInt4( RestartUnit, Perm(j) )
         ELSE
            ! The format string for j has better mach the corresponding format
            ! in WritePerm().
            READ( RestartUnit, '(i11)', ADVANCE='no' ) j
            READ( RestartUnit, * ) Perm(j)
         END IF
      END DO
   END SUBROUTINE ReadPerm


   SUBROUTINE ReadVariableName( RestartUnit,VarName,Stat )
      INTEGER, INTENT(IN) :: RestartUnit
      CHARACTER(*), INTENT(OUT) :: VarName
      INTEGER, INTENT(OUT) :: Stat

      IF ( Binary ) THEN
         CALL BinReadString( RestartUnit,VarName,Stat )
      ELSE
         READ( RestartUnit,FMT='(a)',IOSTAT=Stat ) VarName
      END IF
   END SUBROUTINE ReadVariableName


  SUBROUTINE ReadTime( RestartUnit,SavedCount,Timestep,Time,Stat )
  ! Read SavedCount, Timestep and Time.  Stat is set to 0 for success, < 0 for
  ! end-of-file, and > 0 for error.
    INTEGER, INTENT(IN) :: RestartUnit
    INTEGER, INTENT(OUT) :: SavedCount, Timestep
    REAL(dp), INTENT(OUT) :: Time
    INTEGER, INTENT(OUT) :: Stat
    CHARACTER(80) :: String

    IF ( Binary ) THEN
      CALL BinReadString( RestartUnit, String, Stat )
      IF (Stat /= 0) RETURN
      CALL BinReadInt4( RestartUnit, SavedCount, Stat )
      CALL BinReadInt4( RestartUnit, Timestep, Stat )
      CALL BinReadDouble( RestartUnit, Time, Stat )
    ELSE
      DO WHILE( ReadAndTrim(RestartUnit,String) )
        IF ( String(1:5) == 'time:' ) THEN
          READ( String(7:),* ) SavedCount,Timestep,Time
          Stat = 0
          RETURN
        END IF
      END DO
      Stat = -1
    END IF
  END SUBROUTINE ReadTime

!------------------------------------------------------------------------------
  RECURSIVE SUBROUTINE InvalidateVariable( TopMesh,PrimaryMesh,Name )
!------------------------------------------------------------------------------
    CHARACTER(LEN=*) :: Name
    TYPE(Mesh_t),  POINTER :: TopMesh,PrimaryMesh
!------------------------------------------------------------------------------
    CHARACTER(LEN=MAX_NAME_LEN) :: tmpname
    INTEGER :: i
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Variable_t), POINTER :: Var,Var1
!------------------------------------------------------------------------------
    Mesh => TopMesh

    DO WHILE( ASSOCIATED(Mesh) )
      IF ( .NOT.ASSOCIATED( PrimaryMesh, Mesh) ) THEN
        Var => VariableGet( Mesh % Variables, Name, .TRUE.)
        IF ( ASSOCIATED( Var ) ) THEN
          Var % Valid = .FALSE.
          Var % PrimaryMesh => PrimaryMesh
          IF ( Var % DOFs > 1 ) THEN
            IF ( Var % Name == 'flow solution' ) THEN
              Var1 => VariableGet( Mesh % Variables, 'Velocity 1', .TRUE.)
              IF ( ASSOCIATED( Var1 ) ) THEN
                 Var1 % Valid = .FALSE.
                 Var1 % PrimaryMesh => PrimaryMesh
              END IF
              Var1 => VariableGet( Mesh % Variables, 'Velocity 2', .TRUE.)
              IF ( ASSOCIATED( Var1 ) ) THEN
                 Var1 % Valid = .FALSE.
                 Var1 % PrimaryMesh => PrimaryMesh
              END IF
              Var1 => VariableGet( Mesh % Variables, 'Velocity 3', .TRUE.)
              IF ( ASSOCIATED( Var1 ) ) THEN
                 Var1 % Valid = .FALSE.
                 Var1 % PrimaryMesh => PrimaryMesh
              END IF
              Var1 => VariableGet( Mesh % Variables, 'Pressure', .TRUE.)
              IF ( ASSOCIATED( Var1 ) ) THEN
                 Var1 % Valid = .FALSE.
                 Var1 % PrimaryMesh => PrimaryMesh
              END IF
              Var1 => VariableGet( Mesh % Variables, 'Surface', .TRUE.)
              IF ( ASSOCIATED( Var1 ) ) THEN
                 Var1 % Valid = .FALSE.
                 Var1 % PrimaryMesh => PrimaryMesh
              END IF
            ELSE
              DO i=1,Var % DOFs
                tmpname = ComponentName( Name, i )
                Var1 => VariableGet( Mesh % Variables, tmpname, .TRUE. )
                IF ( ASSOCIATED( Var1 ) ) THEN
                   Var1 % Valid = .FALSE.
                   Var1 % PrimaryMesh => PrimaryMesh
                END IF
              END DO
            END IF
          END IF
        END IF
      END IF
!     CALL InvalidateVariable( Mesh % Child, PrimaryMesh, Name )
      Mesh => Mesh % Next
    END DO 
!------------------------------------------------------------------------------
  END SUBROUTINE InvalidateVariable
!------------------------------------------------------------------------------
  END SUBROUTINE LoadRestartFile
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE WritePostFile( PostFile,ResultFile,Model,TimeCount,AppendFlag )
!------------------------------------------------------------------------------
    TYPE(Model_t), POINTER :: Model 
    INTEGER :: TimeCount
    LOGICAL, OPTIONAL :: AppendFlag
    CHARACTER(LEN=*) :: PostFile,ResultFile
!------------------------------------------------------------------------------
    TYPE(Element_t), POINTER :: CurrentElement
    TYPE(Variable_t), POINTER :: Var,Var1,Displacement,MeshUpdate,MaskVar

    CHARACTER(LEN=512) :: Row
    CHARACTER(MAX_NAME_LEN) :: Str, DateStr

    LOGICAL :: gotIt, FreeSurfaceFlag, MoveBoundary, MeshMoved, MaskExists

    REAL(KIND=dp) :: Time,Dummy, MeshScale
    INTEGER :: ii,i,j,k,l,n,m,q,Node,idummy,DOFs,SavedCount,TimeStep, &
         NumberOfNodes, NumberOfElements, ind, nDOFs
    INTEGER, POINTER :: MaskPerm(:), MaskOrder(:)
!------------------------------------------------------------------------------


    IF( Model % Mesh % SavesDone == 0 ) THEN
      CALL Info('WriteToPost','Saving results in ElmerPost format to file '//TRIM(PostFile))
    END IF


    IF ( .NOT. FileNameQualified(PostFile) ) THEN
      IF ( LEN_TRIM(OutputPath) > 0 ) THEN
        IF ( AppendFlag .AND. Model % Mesh % SavesDone /= 0 )  THEN
          OPEN( PostFileUnit,File=TRIM(OutputPath) // '/' // &
             TRIM(PostFile), POSITION='APPEND' )
        ELSE
          OPEN( PostFileUnit,File=TRIM(OutputPath) // '/' // &
             TRIM(PostFile),STATUS='UNKNOWN' )
        END IF
      ELSE
        IF ( AppendFlag .AND. Model % Mesh % SavesDone /= 0 ) THEN
          OPEN( PostFileUnit,File=TRIM(PostFile),POSITION='APPEND' )
        ELSE
          OPEN( PostFileUnit,File=TRIM(PostFile),STATUS='UNKNOWN' )
        ENDIF
      END IF
    ELSE
      IF ( AppendFlag .AND. Model % Mesh % SavesDone /= 0  ) THEN
        OPEN( PostFileUnit,File=TRIM(PostFile),POSITION='APPEND' )
      ELSE
        OPEN( PostFileUnit,File=TRIM(PostFile),STATUS='UNKNOWN' )
      END IF
    END IF

    IF ( .NOT.AppendFlag ) THEN
      IF ( .NOT. FileNameQualified(ResultFile) ) THEN
        IF ( LEN_TRIM(OutputPath) > 0 ) THEN
          OPEN( OutputUnit,File=TRIM(OutputPath) // '/' &
              // TRIM(ResultFile),STATUS='OLD' )
        ELSE
          OPEN( OutputUnit,File=TRIM(ResultFile),STATUS='OLD' )
        END IF
      ELSE
        OPEN( OutputUnit,File=TRIM(ResultFile),STATUS='OLD' )
      END IF
    END IF

    FreeSurfaceFlag = .FALSE.
    MoveBoundary    = .FALSE.
    DO i=1,CurrentModel % NumberOfBCs
      FreeSurfaceFlag = FreeSurfaceFlag .OR. ListGetLogical( &
         CurrentModel % BCs(i) % Values,'Free Surface', GotIt )
      IF ( FreeSurfaceFlag ) THEN
         MoveBoundary =  ListGetLogical( &
             CurrentModel % BCs(i) % Values,'Internal Move Boundary', GotIt )
         
         IF ( .NOT. GotIt ) MoveBoundary = .TRUE.

         FreeSurfaceFlag = FreeSurfaceFlag .AND. MoveBoundary
      END IF

      IF ( FreeSurfaceFlag ) EXIT
    END DO

!------------------------------------------------------------------------------
! Initialize stuff for masked saving
!------------------------------------------------------------------------------
    Str = ListGetString( Model % Simulation,'Post File Mask Variable',MaskExists)
    IF(.NOT. MaskExists) THEN
       Str = ListGetString( Model % Simulation,'ElmerPost Mask Variable',MaskExists)      
    END IF

    IF( MaskExists ) THEN
       MaskVar => VariableGet(Model % Variables,TRIM(Str))
       IF( ASSOCIATED(MaskVar)) MaskPerm => MaskVar % Perm
       MaskExists = ASSOCIATED(MaskPerm)
    END IF
    IF(MaskExists) THEN
       CALL Info('WritePostFile','Using '// TRIM(Str) // ' as mask variable')
       NumberOfNodes = MAXVAL(MaskPerm)
       ALLOCATE(MaskOrder(NumberOfNodes))
       DO i=1,SIZE(MaskPerm)
          j = MaskPerm(i)
          IF(j > 0) MaskOrder(j) = i
       END DO
       NumberOfElements = 0
       DO i=1,Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
          CurrentElement => Model % Elements(i)
          IF( ALL(MaskPerm(CurrentElement % NodeIndexes) /= 0)) THEN
             NumberOfElements = NumberOfElements + 1
          END IF
       END DO
    ELSE
       NumberOfNodes = Model % NumberOfNodes
       NumberOfElements =  Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
    END IF
 
!------------------------------------------------------------------------------
!   Count degrees of freedom to be saved
!------------------------------------------------------------------------------
    NULLIFY( Displacement, MeshUpdate )

    DOFs = 0
    Var => Model % Variables
    DO WHILE( ASSOCIATED(Var) )

      IF ( .NOT. Var % Output ) THEN
         Var => Var % Next
         CYCLE
      END IF

      IF( SIZE( Var % Values ) == Var % Dofs ) THEN
        Var => Var % Next
        CYCLE
      END IF

      SELECT CASE(Var % Name(1:Var % NameLen))
        CASE( 'mesh update' )
           Var1 => Model % Variables
           DO WHILE( ASSOCIATED( Var1 ) )
             IF ( Var1 % Name == 'displacement' ) EXIT
             Var1 => Var1 % Next
           END DO
           IF ( .NOT. ASSOCIATED( Var1 ) ) THEN
              DOFs = DOFs + 3
           END IF

        CASE('mesh update 1','mesh update 2', 'mesh update 3' )

        CASE( 'displacement' )
          DOFs = DOFs + 3
          IF (ASSOCIATED(Var % Cvalues)) DOFs=DOFs+3

        CASE( 'displacement 1','displacement 2','displacement 3')

        CASE( 'flow solution' )
          DOFs = DOFs + 4

        CASE( 'velocity 1','velocity 2','velocity 3','pressure' )

        CASE( 'magnetic field' )
          DOFs = DOFs + 3

        CASE( 'magnetic field 1','magnetic field 2','magnetic field 3')

        CASE( 'electric current' )
          DOFs = DOFs + 3

        CASE( 'electric current 1','electric current 2','electric current 3')

        CASE( 'magnetic flux density' )
          DOFs = DOFs + 3

        CASE( 'magnetic flux density 1','magnetic flux density 2','magnetic flux density 3')

        CASE DEFAULT

          nDOFs = 1
          IF (ASSOCIATED(Var % Cvalues)) nDOFs=2

          IF ( Var % DOFs == 1 ) THEN
             DOFs = DOFs + nDOFs

          ELSE
            j=INDEX(Var % Name, '[')
            IF ( j > 0 ) THEN
              str =  ' '
              DO i=1,LEN_TRIM(Var % Name)
                str(i:i) = Var % Name(i:i)
              END DO
              DO WHILE( .TRUE. )
                i = INDEX( str(j+1:), ':' ) + j
                IF ( i<=j ) EXIT
                READ( str(i+1:),'(i1)' ) k
                DOFs = DOFs+nDOFs*k
                IF (k==2) DOFs=DOFs+nDOFs
                j = i + 1
              END DO
              DO k=1,Var % DOFs
                Var => Var % Next
              END DO
            END IF
          END IF

      END SELECT
      Var => Var % Next
    END DO

    IF ( .NOT.FreeSurfaceFlag ) DOFs=DOFs-3

!------------------------------------------------------------------------------
! Write header to output
!------------------------------------------------------------------------------
    IF ( .NOT.AppendFlag .OR. Model % Mesh % SavesDone == 0 ) THEN
      WRITE(PostFileUnit,'(i10,i10,i7,i7)',ADVANCE='NO' ) NumberOfNodes, &
           NumberOfElements, DOFs, TimeCount

      Var => Model % Variables
      DO WHILE( ASSOCIATED( Var ) )

        IF ( .NOT. Var % Output ) THEN
           Var => Var % Next
           CYCLE
        END IF

        IF( SIZE( Var % Values ) == Var % Dofs ) THEN
          Var => Var % Next
          CYCLE
        END IF

        SELECT CASE(Var % Name(1:Var % Namelen))
          CASE( 'mesh update' )

             Var1 => Model % Variables
             DO WHILE( ASSOCIATED( Var1 ) )
               IF ( TRIM(Var1 % Name) == 'displacement' ) EXIT
               Var1 => Var1 % Next
             END DO

             IF ( .NOT. ASSOCIATED( Var1 ) ) THEN
                WRITE(PostFileUnit,'(a)',ADVANCE='NO') ' vector: Mesh.Update'
                Displacement => Var
             ELSE
                MeshUpdate   => Var
             END IF

          CASE( 'mesh update 1','mesh update 2', 'mesh update 3' )

          CASE( 'displacement' )
            WRITE(PostFileUnit,'(a)',ADVANCE='NO' ) ' vector: Displacement'
            IF (ASSOCIATED(Var % Cvalues)) &
              WRITE(PostFileUnit,'(a)',ADVANCE='NO' ) ' vector: Displacement.im'
            Displacement => Var

          CASE( 'displacement 1','displacement 2','displacement 3')

          CASE( 'flow solution' )
            WRITE(PostFileUnit,'(a)',ADVANCE='NO') ' vector: Velocity scalar: Pressure'

          CASE( 'velocity 1','velocity 2','velocity 3','pressure' )

          CASE( 'magnetic field' )
            WRITE(PostFileUnit,'(a)',ADVANCE='NO' ) ' vector: MagField'

          CASE( 'magnetic field 1','magnetic field 2','magnetic field 3')

          CASE( 'electric current' )
            WRITE(PostFileUNit,'(a)',ADVANCE='NO' ) ' vector: Current'

          CASE( 'electric current 1','electric current 2','electric current 3')

          CASE( 'magnetic flux density' )
            WRITE(PostFileUnit,'(a)',ADVANCE='NO' ) ' vector: MagneticFlux'

          CASE( 'magnetic flux density 1','magnetic flux density 2','magnetic flux density 3')

          CASE( 'coordinate 1','coordinate 2','coordinate 3' )

          CASE DEFAULT

            IF ( Var % DOFs == 1 ) THEN
              DO i=1,Var % NameLen
                str(i:i) = Var % Name(i:i)
                IF ( str(i:i) == ' ' ) str(i:i) = '.'
              END DO
              str(1:1) = CHAR(ICHAR(str(1:1))-ICHAR('a')+ICHAR('A'))
              WRITE(PostFileUnit,'(a,a)',ADVANCE='NO' ) ' scalar: ',str(1:Var % NameLen)
              IF (ASSOCIATED(Var % Cvalues)) &
                WRITE(PostFileUnit,'(a,a)',ADVANCE='NO' ) ' scalar: ',str(1:Var % NameLen)//'.im'
            ELSE
               j=INDEX(Var % Name, '[')
               IF ( j > 0 ) THEN
                 str =  ' '
                 DO i=1,LEN_TRIM(Var % Name)
                   str(i:i) = Var % Name(i:i)
                 END DO
                 DOFs = 0
                 DO WHILE( .TRUE. )
                   i = INDEX( str(j+1:), ':' ) + j
                   IF ( i<=j ) EXIT
                   READ( str(i+1:),'(i1)' ) k
                   DOFs = DOFs+k
                   DO WHILE( str(j+1:j+1) == ' ' )
                     j = j + 1
                   END DO
                   str(j+1:j+1) = CHAR(ICHAR(str(j+1:j+1))-ICHAR('a')+ICHAR('A'))
                   DO l=j+1,i-1
                     IF ( str(l:l) == ' ' ) str(l:l) = '.'
                   END DO
                   IF ( k==1 ) THEN
                     WRITE(PostFileUnit,'(a,a)',ADVANCE='NO' ) ' scalar: ',str(j+1:i-1)
                     IF (ASSOCIATED(Var % Cvalues)) &
                      WRITE(PostFileUnit,'(a,a)',ADVANCE='NO' ) ' scalar: ',str(j+1:i-1)//'.im'
                   ELSE IF ( k<= 3 ) THEN
                     WRITE(PostFileUnit,'(a,a)',ADVANCE='NO' ) ' vector: ',str(j+1:i-1)
                     IF (ASSOCIATED(Var % Cvalues)) &
                       WRITE(PostFileUnit,'(a,a)',ADVANCE='NO' ) ' vector: ',str(j+1:i-1)//'.im'
                   ELSE
                     DO l=1,k
                       WRITE(PostFileUnit,'(a,a)',ADVANCE='NO' ) ' scalar: ', &
                           str(j+1:i-1) // '.' // CHAR(l+ICHAR('0'))
                       IF (ASSOCIATED(Var % Cvalues)) &
                         WRITE(PostFileUnit,'(a,a)',ADVANCE='NO' ) ' scalar: ', &
                             str(j+1:i-1) // '.' // CHAR(l+ICHAR('0')) // '.im'
                     END DO
                   END IF
                   j = i + 1
                 END DO
                 DO k=1,Var % DOFs
                    Var => Var % Next
                 END DO
               END IF
            END IF
        END SELECT
        Var => Var % Next
      END DO

      IF ( FreeSurfaceFlag ) THEN
        WRITE(PostFileUnit,'(a)',ADVANCE='NO' ) ' vector: Coordinates'
      END IF

      WRITE(PostFileUnit,'()')
      DateStr = FormatDate()
      WRITE( PostFileUnit, '("#File started at: ",A)' ) TRIM(DateStr)
!------------------------------------------------------------------------------
!   Coordinates
!------------------------------------------------------------------------------
!
      MeshScale = 1.0_dp
      DO i=1,Model % NumberOfSolvers
        MeshMoved = ListGetLogical( Model % Solvers(i) % Values, &
                    'Displace Mesh', Gotit )
        IF ( Gotit ) THEN
          IF ( .NOT. MeshMoved ) MeshScale = 0.0_dp
        ELSE
          MeshMoved = ListGetLogical( Model % Solvers(i) % Values, &
                 'Output Mesh Deformation', Gotit )
          IF ( GotIt ) THEN
            IF (MeshMoved ) MeshScale = 0.0_dp
          ELSE
            IF (Model % Solvers(i) % NofEigenValues>0) MeshScale=0._dp
          END IF
        END IF
      END DO


      DO ii=1,NumberOfNodes

         i = ii
         IF(MaskExists) i = MaskOrder(i)

         IF ( ASSOCIATED(Displacement) ) THEN
            k = Displacement % Perm(i)
            l = 0
            IF ( ASSOCIATED( MeshUpdate ) ) l = MeshUpdate % Perm(i)

            IF ( k > 0 ) THEN
               k = Displacement % DOFs * (k-1)
               SELECT CASE( Displacement % DOFs )
               CASE(1)
                  WRITE(PostFileUnit,'(3E20.11E3)') &
                       Model % Nodes % x(i) - MeshScale*Displacement % Values(k+1), &
                       Model % Nodes % y(i), Model % Nodes % z(i)
                  
               CASE(2)
                  WRITE(PostFileUnit,'(3E20.11E3)') &
                       Model % Nodes % x(i) - MeshScale*Displacement % Values(k+1), &
                       Model % Nodes % y(i) - MeshScale*Displacement % Values(k+2), &
                       Model % Nodes % z(i)
                  
               CASE(3)
                  WRITE(PostFileUnit,'(3E20.11E3)') &
                       Model % Nodes % x(i) - MeshScale*Displacement % Values(k+1), &
                       Model % Nodes % y(i) - MeshScale*Displacement % Values(k+2), &
                       Model % Nodes % z(i) - MeshScale*Displacement % Values(k+3)
               END SELECT

            ELSE IF ( l > 0 ) THEN
               k = MeshUpdate % DOFs * (l-1)
               SELECT CASE( MeshUpdate % DOFs )
               CASE(1)
                  WRITE(PostFileUnit,'(3E20.11E3)') &
                       Model % Nodes % x(i) - MeshScale*MeshUpdate % Values(k+1), &
                       Model % Nodes % y(i), Model % Nodes % z(i)
                  
               CASE(2)
                  WRITE(PostFileUnit,'(3E20.11E3)') &
                       Model % Nodes % x(i) - MeshScale*MeshUpdate % Values(k+1), &
                       Model % Nodes % y(i) - MeshScale*MeshUpdate % Values(k+2), &
                       Model % Nodes % z(i)
                  
               CASE(3)
                  WRITE(PostFileUnit,'(3E20.11E3)') &
                       Model % Nodes % x(i) - MeshScale*MeshUpdate % Values(k+1), &
                       Model % Nodes % y(i) - MeshScale*MeshUpdate % Values(k+2), &
                       Model % Nodes % z(i) - MeshScale*MeshUpdate % Values(k+3)
               END SELECT
            ELSE
               WRITE(PostFileUnit,'(3E20.11E3)') Model % Nodes % x(i),Model % Nodes % y(i), &
                    Model % Nodes % z(i)
            ENDIF
         ELSE
            WRITE(PostFileUnit,'(3E20.11E3)') Model % Nodes % x(i),Model % Nodes % y(i), &
                 Model % Nodes % z(i)
         END IF
      END DO

!------------------------------------------------------------------------------
! Elements
!------------------------------------------------------------------------------
      WRITE(PostFileUnit,'(a)') '#group all'
      DO i=1,Model % NumberOfBulkElements
         CurrentElement => Model % Elements(i)

         IF(MaskExists) THEN
            IF( .NOT. ALL(MaskPerm(CurrentElement % NodeIndexes) /= 0)) CYCLE
         END IF
         
         k = CurrentElement % BodyId
         gotIt = .FALSE.
         IF ( k >= 1 .AND. k <= Model % NumberOfBodies ) THEN
            Str = ListGetString( Model % Bodies(k) % Values,'Name',gotIt )
         END IF
         
         IF ( gotIt ) THEN
            k = LEN_TRIM(Str)
            DO j=1,k
               IF ( Str(j:j) == ' ' ) Str(j:j) = '.'
            END DO
            
            WRITE( PostFileUnit,'(a)',ADVANCE='NO' )  Str(1:k)
         ELSE
            IF ( k > 0 .AND. k < 10 ) THEN
               WRITE(PostFileUnit,'(a,i1,a)',ADVANCE='NO' ) 'body',k,' '
            ELSE IF ( k >= 10 .AND. k < 100 ) THEN
               WRITE(PostFileUnit,'(a,i2,a)',ADVANCE='NO' ) 'body',k,' '
            ELSE
               WRITE(PostFileUnit,'(a,i3,a)',ADVANCE='NO' ) 'body',k,' '
            END IF
         END IF
         
         WRITE(PostFileUnit,'(i5)', ADVANCE='NO') CurrentElement % TYPE % ElementCode
         n = 0
         DO j=1,CurrentElement % TYPE % NumberOfNodes,4
            DO k=1,MIN(4,CurrentElement % TYPE % NumberOfNodes-n)
               n = n + 1
               ind = CurrentElement % NodeIndexes(n)
               IF(MaskExists) ind = MaskPerm(ind)
               WRITE(PostFileUnit, '(i8)', ADVANCE='NO')  ind - 1
            END DO
            WRITE( PostFileUnit,'(a)' ) ''
         END DO
      END DO
      
      DO i=Model % NumberOfBulkElements + 1,Model % NumberOfBulkElements + &
           Model % NumberOfBoundaryElements
         
         CurrentElement => Model % Elements(i)
         
         IF(MaskExists) THEN
            IF( .NOT. ALL(MaskPerm(CurrentElement % NodeIndexes) /= 0)) CYCLE
         END IF
         
         k = CurrentElement % BoundaryInfo % Constraint
         
         gotIt = .FALSE.
         IF ( k >= 1 .AND. k <= Model % NumberOfBCs ) THEN
            Str = ListGetString( Model % BCs(k) % Values,'Name',gotIt )
         END IF
         
         IF ( gotIt ) THEN
            k = LEN_TRIM(Str)
            DO j=1,k
               IF ( Str(j:j) == ' ' ) Str(j:j) = '.'
            END DO
            
            WRITE( PostFileUnit,'(a)',ADVANCE='NO' )  Str(1:k)
         ELSE
            IF ( k < 10 ) THEN
               WRITE( PostFileUnit,'(a,i1,a)',ADVANCE='NO' ) 'Constraint', k, ' '
            ELSE IF ( k < 100 ) THEN
               WRITE( PostFileUnit,'(a,i2,a)',ADVANCE='NO' ) 'Constraint', k, ' '
            ELSE
               WRITE( PostFileUnit,'(a,i3,a)',ADVANCE='NO' ) 'Constraint', k, ' '
            END IF
         END IF
         
         WRITE(PostFileUnit,'(i5)', ADVANCE='NO') CurrentElement % TYPE % ElementCode
         DO k=1,CurrentElement % TYPE % NumberOfNodes
            ind = CurrentElement % NodeIndexes(k)
            IF(MaskExists) ind = MaskPerm(ind)
            WRITE( PostFileUnit, '(i8)', ADVANCE='NO' )  ind-1
         END DO
         WRITE( PostFileUnit,'(a)' ) ''
      END DO
      WRITE(PostFileUnit,'(a)') '#endgroup all'
!------------------------------------------------------------------------------
!   Open result file and go trough it...
!------------------------------------------------------------------------------

      REWIND(OutputUnit)
   END IF ! .NOT.AppendFlag .OR. Model % Mesh % SavesDone == 0
   
   IF ( AppendFlag .AND. Model % Mesh % SavesDone == 0 ) THEN
      CLOSE(PostFileUnit)
      RETURN
   END IF

!------------------------------------------------------------------------------
   DO WHILE( .TRUE. )
      IF ( AppendFlag ) THEN
         SavedCount = Model % Mesh % SavesDone
         TimeStep   = SavedCount
         Var => VariableGet( Model % Variables, 'Time', ThisOnly=.TRUE. )
         Time = 1.0d0
         IF ( ASSOCIATED(Var) ) Time = Var % Values(1)
      ELSE
!------------------------------------------------------------------------------
!   ...read one timestep to memory (if not already there)...
!------------------------------------------------------------------------------
         Row = ' '
         DO WHILE( ReadAndTrim(OutputUnit,Row) )
            IF ( Row(1:11) == 'total dofs:' ) READ( Row(12:),* ) DOFs
            IF ( Row(1:5)  == 'time:' ) EXIT
         END DO
         
         IF ( Row(1:5) /= 'time:' ) EXIT
         
         READ( Row(7:),* ) SavedCount,Timestep,Time
      END IF
      
      WRITE( PostFileUnit,'(a,i7,i7,E20.11E3)' ) '#time ',SavedCount,Timestep,Time
      
      IF ( .NOT.AppendFlag ) THEN
         DO i=1,DOFs
            READ(OutputUnit,'(a)' ) Row
            Var => VariableGet( Model % Variables,Row,.TRUE. )
            
            IF ( ASSOCIATED(Var) ) THEN
               DO j=1,NumberOfNodes
                  k = j
                  IF( MaskExists ) k = MaskPerm(k)
                  IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(k)
                  IF ( k > 0 ) THEN
                     READ(OutputUnit,*) Node,idummy,Var % Values(k)
                  ELSE
                     READ(OutputUnit,*) Node,idummy,Dummy
                  END IF
               END DO
            END IF
        END DO
     END IF
!-----------------------------------------------------------------------------
!     ...then save it to post file.
!------------------------------------------------------------------------------
     DO ii=1,NumberOfNodes
        
        i = ii
        IF(MaskExists) i = MaskOrder(i)

        Var => Model % Variables
        DO WHILE( ASSOCIATED( Var ) )
           IF ( .NOT. Var % Output ) THEN
              Var => Var % Next
              CYCLE
           END IF
           
           IF( SIZE( Var % Values ) == Var % DOFs ) THEN
             Var => Var % Next
             CYCLE
           END IF

           SELECT CASE(Var % Name(1:Var % Namelen))
              
           CASE( 'mesh update' )
              Var1 => Model % Variables
              DO WHILE( ASSOCIATED( Var1 ) )
                 IF ( Var1 % Name(1:Var1 % NameLen) == 'displacement' ) EXIT
                 Var1 => Var1 % Next
              END DO
              IF ( .NOT. ASSOCIATED( Var1 ) ) THEN
                 k = i
                 IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(k)
                 IF ( k > 0 ) THEN
                    DO j=1,Var % DOFs
                       WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') Var % Values(Var % DOFs*(k-1)+j)
                    END DO
                    IF ( Var % DOFs < 3 ) WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0D0
                 ELSE
                    WRITE(PostFileUnit,'(4E20.11E3)',ADVANCE='NO') 0.0D0,0.0D0,0.0D0
                 END IF
              END IF
              
           CASE(  'mesh update 1','mesh update 2', 'mesh update 3' )
              
           CASE( 'displacement' )
              k = i
              IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(k)
              
              IF ( k > 0 ) THEN
                 IF (ASSOCIATED(Var % Cvalues)) THEN
                   DO j=1,Var % DOFs
                     WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') &
                         REAL(Var % Cvalues(Var % DOFs*(k-1)+j))
                   END DO
                   IF (Var % DOFs<3) WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0d0
                   DO j=1,Var % DOFs
                     WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') &
                         AIMAG(Var % Cvalues(Var % DOFs*(k-1)+j))
                   END DO
                   IF (Var % DOFs<3) WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0d0
                 ELSE
                   DO j=1,Var % DOFs
                     WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') &
                         Var % Values(Var % DOFs*(k-1)+j)
                   END DO
                   IF (Var % DOFs<3) WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0d0
                 END IF
              ELSE
                 Var1 => Model % Variables
                 DO WHILE( ASSOCIATED( Var1 ) )
                    IF ( Var1 % Name(1:Var1 % Namelen) == 'mesh update' ) EXIT
                    Var1 => Var1 % Next
                 END DO
                 IF ( ASSOCIATED( Var1 ) ) THEN
                    k = i
                    IF ( ASSOCIATED(Var1 % Perm) ) k = Var1 % Perm(k)
                    IF ( k > 0 ) THEN
                       DO j=1,Var1 % DOFs
                          WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO')  &
                               Var1 % Values(Var1 % DOFs*(k-1)+j)
                       END DO
                       IF ( Var1 % DOFs<3 ) &
                            WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0D0
                    ELSE
                       WRITE(PostFileUnit,'(4E20.11E3)',ADVANCE='NO') 0.0D0,0.0D0,0.0D0
                    END IF
                 ELSE
                    WRITE(PostFileUnit,'(4E20.11E3)',ADVANCE='NO') 0.0D0,0.0D0,0.0D0
                 END IF
              END IF
              
           CASE( 'displacement 1','displacement 2','displacement 3')
              
           CASE( 'flow solution' )
              k = i
              IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(k)
              IF ( k > 0 ) THEN
                 DO j=1,Var % DOFs-1
                    WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') Var % Values(Var % DOFs*(k-1)+j)
                 END DO
                 IF ( Var % DOFs < 4 ) WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0D0
                 
                 WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO')  &
                      Var % Values(Var % DOFs*(k-1)+Var % DOFs)
              ELSE
                 WRITE(PostFileUnit,'(4E20.11E3)',ADVANCE='NO') 0.0D0,0.0D0,0.0D0,0.0D0
              END IF
              
           CASE( 'velocity 1','velocity 2','velocity 3','pressure' )
              
           CASE( 'magnetic field' )
              k = i
              IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(k)
              IF ( k > 0 ) THEN
                 DO j=1,Var % DOFs
                    WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') Var % Values(Var % DOFs*(k-1)+j)
                 END DO
                 IF ( Var % DOFs < 3 ) WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0D0
              ELSE
                 WRITE(PostFileUnit,'(4E20.11E3)',ADVANCE='NO') 0.0D0,0.0D0,0.0D0
              END IF
              
           CASE( 'magnetic field 1','magnetic field 2','magnetic field 3')
              
           CASE( 'electric current' )
              k = i
              IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(k)
              IF ( k > 0 ) THEN
                 DO j=1,Var % DOFs
                    WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') Var % Values(Var % DOFs*(k-1)+j)
                 END DO
                 IF ( Var % DOFs < 3 ) WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0D0
              ELSE
                 WRITE(PostFileUnit,'(4E20.11E3)',ADVANCE='NO') 0.0D0,0.0D0,0.0D0
              END IF
              
           CASE( 'electric current 1','electric current 2','electric current 3')
              
           CASE( 'coordinate 1','coordinate 2','coordinate 3' )
              
           CASE( 'magnetic flux density' )
              k = i
              IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(k)
              IF ( k > 0 ) THEN
                 DO j=1,Var % DOFs
                    WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') Var % Values(Var % DOFs*(k-1)+j)
                 END DO
                 IF ( Var % DOFs < 3 ) WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0D0
              ELSE
                 WRITE(PostFileUnit,'(4E20.11E3)',ADVANCE='NO') 0.0D0,0.0D0,0.0D0
              END IF
              
           CASE( 'magnetic flux density 1','magnetic flux density 2','magnetic flux density 3')
              
           CASE DEFAULT

              IF ( Var % DOFs == 1 ) THEN
                 k = i
                 IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(k)
                 IF ( k > 0 ) THEN
                    IF (ASSOCIATED(Var % Cvalues)) THEN
                      WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') &
                         REAL(Var % Cvalues(k))
                      WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') &
                         AIMAG(Var % Cvalues(k))
                    ELSE
                      WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') Var % Values(k)
                    END IF
                 ELSE
                    WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0d0
                 END IF
              ELSE
                 l = INDEX( var % name, '[' )
                 IF ( l > 0 ) THEN
                    DOFs = 0
                    DO WHILE( .TRUE. )
                       m = INDEX( Var % Name(l+1:), ':' ) + l
                       IF ( m<=l ) EXIT
                       READ( Var % Name(m+1:),'(i1)' ) q
                       k = i
                       IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(k)
                       IF ( k > 0 ) THEN
                          IF ( q==2 .OR. q==3 ) THEN
                            IF (ASSOCIATED(Var % Cvalues)) THEN
                               DO j=DOFs+1,DOFs+q
                                  WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') &
                                     REAL(Var % Cvalues(Var % DOFs*(k-1)+j))
                               END DO
                               DO j=q+1,3
                                 WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0d0
                               END DO
                               DO j=DOFs+1,DOFs+q
                                  WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') &
                                     AIMAG(Var % Cvalues(Var % DOFs*(k-1)+j))
                               END DO
                               DO j=q+1,3
                                 WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0d0
                               END DO
                            ELSE
                               DO j=DOFs+1,DOFs+q
                                 WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') &
                                     Var % Values(Var % DOFs*(k-1)+j)
                               END DO
                               DO j=q+1,3
                                 WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0d0
                               END DO
                            END IF
                          ELSE
                            DO j=DOFs+1,DOFs+q
                              IF (ASSOCIATED(Var % Cvalues)) THEN
                                WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') &
                                   REAL(Var % Cvalues(Var % DOFs*(k-1)+j))
                                WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') &
                                   AIMAG(Var % Cvalues(Var % DOFs*(k-1)+j))
                              ELSE
                                WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') &
                                   Var % Values(Var % DOFs*(k-1)+j)
                              END IF
                            END DO
                          END IF
                       ELSE
                          DO j=1,q
                             WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0d0
                          END DO
                          IF ( q==2 .OR. q==3 ) THEN
                             DO j=q+1,3
                                WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') 0.0d0
                             END DO
                          END IF
                       END IF
                       l=m+1
                       DOFs = DOFs+q
                    END DO
                    DO j=1,Var % DOFs
                       Var => Var % Next
                    END DO
                 END IF
              END IF
           END SELECT
           Var => Var % Next
        END DO

        IF ( FreeSurfaceFlag ) THEN
           Var => VariableGet( Model % Variables,'Coordinate 1' )
           WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') Var % Values(i)
           
           Var => VariableGet( Model % Variables,'Coordinate 2' )
           WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') Var % Values(i)
           
           Var => VariableGet( Model % Variables,'Coordinate 3' )
           WRITE(PostFileUnit,'(E20.11E3)',ADVANCE='NO') Var % Values(i)
        END IF
        
        WRITE(PostFileUnit,'()')
     END DO
     IF (  AppendFlag ) EXIT
!------------------------------------------------------------------------------
  END DO
!------------------------------------------------------------------------------
!   We are done here close the files and deallocate
!------------------------------------------------------------------------------
  CLOSE(PostFileUnit)
  IF ( .NOT. AppendFlag ) CLOSE(OutputUnit)

  IF(MaskExists) DEALLOCATE(MaskOrder)
  
END SUBROUTINE WritePostFile
!------------------------------------------------------------------------------


SUBROUTINE GetNodalElementSize(Model,expo,noweight,h)
!------------------------------------------------------------------------------
!******************************************************************************
!
!  Solve the ElementSize equation!
!
!  ARGUMENTS:
!
!  TYPE(Model_t) :: Model,  
!     INPUT: All model information (mesh, materials, BCs, etc...)
!
!  TYPE(Solver_t) :: Solver
!     INPUT: Linear & nonlinear equation solver options
!
!  REAL(KIND=dp) :: dt,
!     INPUT: Timestep size for time dependent simulations
!
!  LOGICAL :: TransientSimulation
!     INPUT: Steady state or transient simulation
!
!******************************************************************************
  USE IterSolve
  USE Integration
  USE ElementDescription

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Model_t) :: Model
  LOGICAL :: noweight
  REAL(KIND=dp) :: expo
  REAL(KIND=Dp), POINTER :: h(:)
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  TYPE(Solver_t), POINTER :: Solver
  REAL(KIND=dp) :: dt=1._dp
  LOGICAL :: TransientSimulation=.FALSE.

  TYPE(Element_t),POINTER :: Element

  LOGICAL :: AllocationsDone = .FALSE., Found

  INTEGER :: n, t, istat, active
  REAL(KIND=dp) :: Norm, Power
  TYPE(Mesh_t), POINTER :: Mesh
  REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), FORCE(:)
  LOGICAL :: GotIt
  REAL(KIND=dp) :: ElemMin, ElemMax
  TYPE(ValueList_t), POINTER :: Params

  TYPE(Matrix_t), POINTER :: A
  INTEGER, POINTER :: CPerm(:)

  SAVE STIFF, FORCE, AllocationsDone
!------------------------------------------------------------------------------

  CALL Info('ElementSizeSolver','Computing nodal element size indicator')


  ALLOCATE( Solver )
  Solver % Mesh => Model % Mesh
  Mesh => Solver % Mesh

  Params => Null()
  CALL ListAddString( Params,'Linear System Iterative Method', 'CG' )
  CALL ListAddLogical( Params,'Linear System Symmetric', .TRUE. )
  CALL ListAddInteger( Params, 'Linear System Max Iterations', 5000 )
  CALL ListAddString( Params, 'Linear System Preconditioning', 'ILU0' )
  CALL ListAddInteger( Params, 'Linear System Residual Output', 100 )
  CALL ListAddConstReal( Params, 'Linear System Convergence Tolerance', 1.0d-9 )
  Solver % Values=>Params

  ALLOCATE(CPerm(Mesh % NumberOfNodes))

  A => CreateMatrix(Model,Solver, &
           Solver % Mesh,CPerm,1,MATRIX_CRS,.FALSE. )

  A % Comm = MPI_COMM_WORLD
  A % ParMatrix => Null()
  Solver % Matrix => A
  Model % Solver => Solver

  ALLOCATE(A % RHS(Mesh % NumberOfNodes))

  Solver % TimeOrder = 0

  Mesh % Variables => Null()
  CALL VariableAdd( Mesh % Variables, Mesh, Solver, &
        'nodal h',1,h,Cperm) !,Output=.FALSE.)
  Solver % Variable=>VariableGet(Mesh % Variables,'nodal h',ThisOnly=.TRUE.)

  IF ( ParEnv % PEs>1 ) THEN
    IF ( ASSOCIATED(Solver % Mesh % ParallelInfo % Interface) ) THEN
      ParEnv % ActiveComm = MPI_COMM_WORLD

      ALLOCATE(ParEnv % Active(ParEnv % PEs))
      ParEnv % Active=.TRUE.

      CALL ParallelInitMatrix(Solver, Solver % Matrix )

      Solver % Matrix % ParMatrix % ParEnv % ActiveComm = &
                 Solver % Matrix % Comm
      ParEnv = Solver % Matrix % ParMatrix % ParEnv
    END IF
  END IF


  ! Allocate some storage
  !--------------------------------------------------------------
  N = Mesh % MaxElementNodes ! just big enough for elemental arrays
  ALLOCATE( FORCE(N), STIFF(N,N), STAT=istat )
  IF ( istat /= 0 ) THEN
    CALL Fatal( 'ElementSizeSolver', 'Memory allocation error.' )
  END IF
  
  ElemMin =  HUGE(ElemMin)
  ElemMax = -HUGE(ElemMax)

  !Initialize the system and do the assembly:
  !------------------------------------------
  Power = 1.0_dp / expo
  active = Mesh % NumberOfBulkElements

  A % RHS=0._dp
  A % Values=0._dp
  DO t=1,active
    Element => Mesh % Elements(t)
    Model % CurrentElement => Element
    n = Element % Type % NumberOfNodes
    
    !Get element local matrix and rhs vector:
    !----------------------------------------
    CALL LocalMatrix(  STIFF, FORCE, Element, n )
    
    !Update global matrix and rhs vector from local matrix & vector:
    !---------------------------------------------------------------
    CALL CRS_GlueLocalMatrix( A,n,1,Element % NodeIndexes,STIFF )
    A % RHS(Element % NodeIndexes) = &
             A % RHS(Element % NodeIndexes)+FORCE(1:n)
  END DO
  
  h=0
  IF (ASSOCIATED(A % ParMatrix)) THEN
    CALL ParallelIter(A,A % ParallelInfo,1,h,A % RHS,Solver,A % ParMatrix)
  ELSE
    CALL IterSolver(A,h,A % RHS,Solver)
  END IF
  

  WRITE(Message,'(A,2ES12.4)') 'Minimum Element Size: ',ElemMin, MINVAL(h)
  CALL Info('ElementSizeSolver',Message)
  WRITE(Message,'(A,2ES12.4)') 'Maximum Element Size: ',ElemMax, MAXVAL(h)
  CALL Info('ElementSizeSolver',Message)
  WRITE(Message,'(A,2ES12.4)') 'Element Size Ratio: ',ElemMax / ElemMin, MAXVAL(h)/MINVAL(h)
  CALL Info('ElementSizeSolver',Message)

  Model % Solver=>Null()
  DEALLOCATE(Mesh % Variables)
  Mesh % Variables => Null()

  CALL FreeMatrix(A)
  DEALLOCATE( FORCE, STIFF,Cperm )
 
CONTAINS

!------------------------------------------------------------------------------
  SUBROUTINE LocalMatrix(  STIFF, FORCE, Element, n )
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: STIFF(:,:), FORCE(:)
    INTEGER :: n
    TYPE(Element_t), POINTER :: Element
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: Basis(n),DetJ,LoadAtIP,Weight
    LOGICAL :: Stat
    INTEGER :: i,j,t
    TYPE(GaussIntegrationPoints_t) :: IP

    TYPE(Nodes_t) :: Nodes
    SAVE Nodes
!------------------------------------------------------------------------------
    STIFF = 0.0_dp
    FORCE = 0.0_dp

    ALLOCATE(Nodes % x(n), Nodes % y(n), Nodes % z(n))
    Nodes % x = Mesh  % Nodes % x(Element % NodeIndexes)
    Nodes % y = Mesh  % Nodes % y(Element % NodeIndexes)
    Nodes % z = Mesh  % Nodes % z(Element % NodeIndexes)

    ! Numerical integration:
    !----------------------
    IP = GaussPoints( Element )

    DO t=1,IP % n
       ! Basis function values & derivatives at the integration point:
       !--------------------------------------------------------------
       stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), &
               IP % W(t),  detJ, Basis )

       ! The source term at the integration point:
       !------------------------------------------
       LoadAtIP = DetJ ** Power
       IF( NoWeight ) THEN
         Weight = IP % s(t) 
       ELSE
         Weight = IP % s(t) * DetJ
       END IF

       ElemMin = MIN( ElemMin, LoadAtIP )
       ElemMax = MAX( ElemMax, LoadAtIP )
       
       ! Finally, the elemental matrix & vector:
       !----------------------------------------
       DO i = 1, n
         DO j = 1, n
           STIFF(i,j) = STIFF(i,j) + Weight * &
               Basis(i) * Basis(j)
         END DO
         FORCE(i) = FORCE(i) + Weight * Basis(i) * LoadAtIp
       END DO
    END DO
    DEALLOCATE(Nodes % x, Nodes % y, Nodes % z)
!------------------------------------------------------------------------------
  END SUBROUTINE LocalMatrix
!------------------------------------------------------------------------------
END SUBROUTINE GetNodalElementSize
!------------------------------------------------------------------------------

END MODULE ModelDescription
