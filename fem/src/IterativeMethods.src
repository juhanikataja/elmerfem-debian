!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Module containing iterative methods. Uses the calling procedure of the 
! *  HUTIter package for similar interfacing. The idea is that the future 
! *  development of iterative methods could be placed in this module. 
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen, Peter Råback
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 20.9.2007
! *
! ****************************************************************************/




#include "huti_fdefs.h"

! if using old huti_fdefs.h, later obsolite
#ifndef HUTI_MAXTOLERANCE
#define HUTI_MAXTOLERANCE dpar(2)
#endif
#ifndef HUTI_SGSPARAM
#define HUTI_SGSPARAM dpar(3)
#endif
#ifndef HUTI_BICGSTABL_L
#define HUTI_BICGSTABL_L ipar(16)
#endif
#ifndef HUTI_DIVERGENCE
#define HUTI_DIVERGENCE 3
#endif


MODULE IterativeMethods
  
  USE Types
  USE CRSMatrix  

  IMPLICIT NONE
  
  
CONTAINS
  

!------------------------------------------------------------------------------
  SUBROUTINE itermethod_sgs( xvec, rhsvec, &
      ipar, dpar, work, matvecsubr, pcondlsubr, &
      pcondrsubr, dotprodfun, normfun, stopcfun )
        
    IMPLICIT NONE

    EXTERNAL matvecsubr, pcondlsubr, pcondrsubr
    EXTERNAL dotprodfun, normfun, stopcfun
    REAL(KIND=dp) :: dotprodfun
    REAL(KIND=dp) :: normfun
    REAL(KIND=dp) :: stopcfun
    
    ! Parameters
    INTEGER, DIMENSION(HUTI_IPAR_DFLTSIZE) :: ipar
    REAL(KIND=dp), DIMENSION(HUTI_DPAR_DFLTSIZE) :: dpar
    REAL(KIND=dp) :: &
      xvec(HUTI_NDIM),rhsvec(HUTI_NDIM),work(HUTI_WRKDIM,HUTI_NDIM)

    INTEGER :: ndim
    INTEGER :: Rounds, OutputInterval
    REAL(KIND=dp) :: MinTol, MaxTol, Residual, Omega
    LOGICAL :: Converged, Diverged

    ndim = HUTI_NDIM
    Rounds = HUTI_MAXIT
    MinTol = HUTI_TOLERANCE
    MaxTol = HUTI_MAXTOLERANCE
    OutputInterval = HUTI_DBUGLVL 
    Omega = HUTI_SGSPARAM

    CALL sgs(ndim, GlobalMatrix, xvec, rhsvec, Rounds, MinTol, MaxTol, Residual, &
        Converged, Diverged, OutputInterval, Omega)

    IF(Converged) HUTI_INFO = HUTI_CONVERGENCE
    IF(Diverged) HUTI_INFO = HUTI_DIVERGENCE
    
  CONTAINS 
 
!------------------------------------------------------------------------------
    SUBROUTINE SGS( n, A, x, b, Rounds, MinTolerance, MaxTolerance, Residual, &
        Converged, Diverged, OutputInterval, Omega )
 !------------------------------------------------------------------------------
      TYPE(Matrix_t), POINTER :: A
      INTEGER :: Rounds
      REAL(KIND=dp) :: x(:),b(:)
      REAL(KIND=dp) :: Omega
      INTEGER :: i,j,k,n
      INTEGER, POINTER :: Cols(:),Rows(:)
      REAL(KIND=dp), POINTER :: Values(:), R(:)
      LOGICAL :: Converged, Diverged
      INTEGER :: OutputInterval
      REAL(KIND=dp) :: MinTolerance, MaxTolerance, Residual, bnorm,rnorm,w,s

      Rows   => A % Rows
      Cols   => A % Cols
      Values => A % Values
      
      ALLOCATE( R(n) )
      
      CALL matvecsubr( x, r, ipar )
     
      r(1:n) = b(1:n) - r(1:n)
      bnorm = normfun(n, b, 1)
      rnorm = normfun(n, r, 1) 

      Residual = rnorm / bnorm
      Converged = (Residual < MinTolerance) 
      Diverged = (Residual > MaxTolerance)     
      IF( Converged .OR. Diverged) RETURN

      DO k=1,Rounds
        DO i=1,n
          s = 0.0d0
          DO j=Rows(i),Rows(i+1)-1
            s = s + x(Cols(j)) * Values(j)
          END DO
          x(i) = x(i) + Omega * (b(i)-s) / Values(A % Diag(i))
        END DO
        
        DO i=n,1,-1
          s = 0.0d0
          DO j=Rows(i),Rows(i+1)-1
            s = s + x(Cols(j)) * Values(j)
          END DO
          x(i) = x(i) + Omega * (b(i)-s) / Values(A % Diag(i))
        END DO
        
        CALL matvecsubr( x, r, ipar )
        r(1:n) = b(1:n) - r(1:n)
        rnorm = normfun(n, r, 1)
        
        Residual = rnorm / bnorm
        IF( MOD(k,OutputInterval) == 0) THEN
          WRITE (*, '(I8, 2E11.4)') k, rnorm, residual
        END IF
        
        Converged = (Residual < MinTolerance) 
        Diverged = (Residual > MaxTolerance)     
        IF( Converged .OR. Diverged) RETURN
        
      END DO
    END SUBROUTINE SGS
!------------------------------------------------------------------------------
  END SUBROUTINE itermethod_sgs
 !------------------------------------------------------------------------------
 


 !------------------------------------------------------------------------------
 SUBROUTINE itermethod_jacobi( xvec, rhsvec, &
      ipar, dpar, work, matvecsubr, pcondlsubr, &
      pcondrsubr, dotprodfun, normfun, stopcfun )
       
    IMPLICIT NONE

    EXTERNAL matvecsubr, pcondlsubr, pcondrsubr
    EXTERNAL dotprodfun, normfun, stopcfun
    REAL(KIND=dp) :: dotprodfun
    REAL(KIND=dp) :: normfun
    REAL(KIND=dp) :: stopcfun
    
    ! Parameters
    INTEGER, DIMENSION(HUTI_IPAR_DFLTSIZE) :: ipar
    REAL(KIND=dp), DIMENSION(HUTI_DPAR_DFLTSIZE) :: dpar
    REAL(KIND=dp) :: &
       xvec(HUTI_NDIM),rhsvec(HUTI_NDIM),work(HUTI_WRKDIM,HUTI_NDIM)

    INTEGER :: ndim
    INTEGER :: Rounds, OutputInterval
    REAL(KIND=dp) :: MinTol, MaxTol, Residual
    LOGICAL :: Converged, Diverged
    
    ndim = HUTI_NDIM
    Rounds = HUTI_MAXIT
    MinTol = HUTI_TOLERANCE
    MaxTol = HUTI_MAXTOLERANCE
    OutputInterval = HUTI_DBUGLVL 
       
    CALL jacobi(ndim, GlobalMatrix, xvec, rhsvec, Rounds, MinTol, MaxTol, Residual, &
        Converged, Diverged, OutputInterval )

    IF(Converged) HUTI_INFO = HUTI_CONVERGENCE
    IF(Diverged) HUTI_INFO = HUTI_DIVERGENCE
   

  CONTAINS 
    
    
    SUBROUTINE Jacobi( n, A, x, b, Rounds, MinTolerance, MaxTolerance, Residual, &
        Converged, Diverged, OutputInterval) 
!------------------------------------------------------------------------------
      TYPE(Matrix_t), POINTER :: A
      INTEGER :: Rounds
      REAL(KIND=dp) :: x(:),b(:)
      LOGICAL :: Converged, Diverged
      REAL(KIND=dp) :: MinTolerance, MaxTolerance, Residual
      INTEGER :: OutputInterval
      REAL(KIND=dp) :: bnorm,rnorm
      REAL(KIND=dp), POINTER :: R(:)
!------------------------------------------------------------------------------
      INTEGER :: i,n
!------------------------------------------------------------------------------
      
      Converged = .FALSE.
      Diverged = .FALSE.
      
      ALLOCATE( R(n) )
      
      CALL matvecsubr( x, r, ipar )
      r(1:n) = b(1:n) - r(1:n)
      
      bnorm = normfun(n, b, 1)
      rnorm = normfun(n, r, 1)
      
      Residual = rnorm / bnorm
      Converged = (Residual < MinTolerance) 
      Diverged = (Residual > MaxTolerance)     
      IF( Converged .OR. Diverged) RETURN
      
      DO i=1,Rounds
        x(1:n) = x(1:n) + r(1:n) / A % Values(A % diag(1:n))
        CALL matvecsubr( x, r, ipar )
        
        r(1:n) = b(1:n) - r(1:n)
        rnorm = normfun(n, r, 1)
        
        Residual = rnorm / bnorm
        
        IF( MOD(i,OutputInterval) == 0) THEN
          WRITE (*, '(I8, 2E11.4)') i, rnorm, residual
        END IF
        
        Converged = (Residual < MinTolerance) 
        Diverged = (Residual > MaxTolerance)     
        IF( Converged .OR. Diverged) EXIT
      END DO
      
      DEALLOCATE( R )
      
    END SUBROUTINE Jacobi
    
!------------------------------------------------------------------------------
  END SUBROUTINE itermethod_jacobi
!------------------------------------------------------------------------------
  


!------------------------------------------------------------------------------
  SUBROUTINE itermethod_bicgstabl( xvec, rhsvec, &
      ipar, dpar, work, matvecsubr, pcondlsubr, &
      pcondrsubr, dotprodfun, normfun, stopcfun )
    

    IMPLICIT NONE

    EXTERNAL matvecsubr, pcondlsubr, pcondrsubr
    EXTERNAL dotprodfun, normfun, stopcfun
    REAL(KIND=dp) :: dotprodfun
    REAL(KIND=dp) :: normfun
    REAL(KIND=dp) :: stopcfun
    
    ! Parameters
    INTEGER, DIMENSION(HUTI_IPAR_DFLTSIZE) :: ipar
    REAL(KIND=dp), DIMENSION(HUTI_DPAR_DFLTSIZE) :: dpar
    REAL(KIND=dp) :: &
       xvec(HUTI_NDIM),rhsvec(HUTI_NDIM),work(HUTI_WRKDIM,HUTI_NDIM)

    INTEGER :: ndim
    INTEGER :: Rounds, OutputInterval, PolynomialDegree
    REAL(KIND=dp) :: MinTol, MaxTol, Residual
    LOGICAL :: Converged, Diverged
    
    ndim = HUTI_NDIM
    Rounds = HUTI_MAXIT
    MinTol = HUTI_TOLERANCE
    MaxTol = HUTI_MAXTOLERANCE
    OutputInterval = HUTI_DBUGLVL 
    PolynomialDegree = HUTI_BICGSTABL_L 
 
    CALL RealBiCGStabl(ndim, GlobalMatrix, xvec, rhsvec, Rounds, MinTol, MaxTol, &
        Converged, Diverged, OutputInterval, PolynomialDegree )

    IF(Converged) HUTI_INFO = HUTI_CONVERGENCE
    IF(Diverged) HUTI_INFO = HUTI_DIVERGENCE


  CONTAINS

!-----------------------------------------------------------------------------------
    SUBROUTINE RealBiCGStabl( n, A, x, b, MaxRounds, Tol, MaxTol, Converged, &
        Diverged, OutputInterval, l, StoppingCriterionType )
!-----------------------------------------------------------------------------------
!   This subroutine solves real linear systems Ax = b by using the BiCGStab(l) algorithm 
!   with l >= 2 and the right-oriented ILU(n) preconditioning. 
!
!   The subroutine has been written using as a starting point the work of D.R. Fokkema 
!   (subroutine zbistbl v1.1 1998). Dr. Fokkema has given the right to distribute
!   the derived work under GPL and hence the original copyright notice of the subroutine
!   has been removed accordingly.  
!
!----------------------------------------------------------------------------------- 
      INTEGER :: l   ! polynomial degree
      INTEGER :: n, MaxRounds, OutputInterval   
      LOGICAL :: Converged, Diverged
      TYPE(Matrix_t), POINTER :: A
      REAL(KIND=dp) :: x(n), b(n)
      REAL(KIND=dp) :: Tol, MaxTol
      INTEGER, OPTIONAL :: StoppingCriterionType 
!------------------------------------------------------------------------------
      REAL(KIND=dp) :: zero, one, t(n), kappa0, kappal 
      REAL(KIND=dp) :: dnrm2, rnrm0, rnrm, mxnrmx, mxnrmr, errorind, &
          delta = 1.0d-2, bnrm, bw_errorind, tottime
      INTEGER :: i, j, rr, r, u, xp, bp, z, zz, y0, yl, y, k, iwork(l-1), stat, Round, &
          IluOrder
      REAL(KIND=dp) :: work(n,3+2*(l+1)), rwork(l+1,3+2*(l+1)), &
          alpha, beta, omega, rho0, rho1, sigma, ddot, varrho, hatgamma
      LOGICAL rcmp, xpdt, GotIt, BackwardError  
      CHARACTER(LEN=MAX_NAME_LEN) :: str
!------------------------------------------------------------------------------
    
      IF ( l < 2) CALL Fatal( 'RealBiCGStabl', 'Polynomial degree < 2' )
      
      IF ( ALL(x == 0.0d0) ) x = b

      
      zero = 0.0d0
      one =  1.0d0

      work = 0.0d0
      rwork = 0.0d0
    
      rr = 1
      r = rr+1
      u = r+(l+1)
      xp = u+(l+1)
      bp = xp+1
    
      z = 1
      zz = z+(l+1)
      y0 = zz+(l+1)
      yl = y0+1
      y = yl+1
    
      CALL matvecsubr( x, work(1:n,r), ipar )
      work(1:n,r) = b(1:n) - work(1:n,r)
      bnrm  = normfun(n, b(1:n), 1 )
      rnrm0 = normfun(n, work(1:n,r), 1 )

      !-------------------------------------------------------------------
      ! Check whether the initial guess satisfies the stopping criterion
      !--------------------------------------------------------------------
      errorind = rnrm0 / bnrm
      Converged = (errorind < Tol)
      Diverged = (errorind > MaxTol)

      IF( Converged .OR. Diverged) RETURN

      work(1:n,rr) = work(1:n,r) 
      work(1:n,bp) = work(1:n,r)
      work(1:n,xp) = x(1:n)

      rnrm = rnrm0
      mxnrmx = rnrm0
      mxnrmr = rnrm0      
      x(1:n) = zero      
      alpha = zero
      omega = one
      sigma = one
      rho0 = one

      DO Round=1,MaxRounds
        !-------------------------
        ! --- The BiCG part ---
        !-------------------------
        rho0 = -omega*rho0
      
        DO k=1,l
          rho1 = dotprodfun(n, work(1:n,rr), 1, work(1:n,r+k-1), 1 )
          IF (rho0 == zero) THEN
            CALL Fatal( 'RealBiCGStab(l)', 'Breakdown error.' )
          ENDIF
          beta = alpha*(rho1/rho0)
          rho0 = rho1
          DO j=0,k-1
            work(1:n,u+j) = work(1:n,r+j) - beta*work(1:n,u+j)
          ENDDO
          CALL pcondlsubr( t, work(1:n,u+k-1), ipar )
          CALL matvecsubr( t, work(1:n,u+k),   ipar )

          sigma = dotprodfun(n, work(1:n,rr), 1, work(1:n,u+k), 1 )
          IF (sigma == zero) THEN
            CALL Fatal( 'RealBiCGStab(l)', 'Breakdown error.' )
          ENDIF
          alpha = rho1/sigma
          x(1:n) = x(1:n) + alpha * work(1:n,u)
          DO j=0,k-1
            work(1:n,r+j) = work(1:n,r+j) - alpha * work(1:n,u+j+1)
          ENDDO
          CALL pcondlsubr( t, work(1:n,r+k-1), ipar )
          CALL matvecsubr( t, work(1:n,r+k),   ipar )
          rnrm = normfun(n, work(1:n,r), 1 )
          mxnrmx = MAX (mxnrmx, rnrm)
          mxnrmr = MAX (mxnrmr, rnrm)
        ENDDO

        !--------------------------------------
        ! --- The convex polynomial part ---
        !--------------------------------------
        
        DO i=1,l+1
          DO j=1,i
            rwork(i,j) = dotprodfun(n, work(1:n,r+i-1), 1, work(1:n,r+j-1), 1 ) 
          END DO
        END DO
        DO j=2,l+1
          rwork(1:j-1,j) = rwork(j,1:j-1)
        END DO
          
        rwork(1:l+1,zz:zz+l) = rwork(1:l+1,z:z+l)
        CALL dgetrf (l-1, l-1, rwork(2:l,zz+1:zz+l-1), l-1, &
            iwork, stat)
      
        ! --- tilde r0 and tilde rl (small vectors)
      
        rwork(1,y0) = -one
        rwork(2:l,y0) = rwork(2:l,z) 
        CALL dgetrs('n', l-1, 1, rwork(2:l,zz+1:zz+l-1), l-1, iwork, &
            rwork(2:l,y0), l-1, stat)
        rwork(l+1,y0) = zero
        
        rwork(1,yl) = zero
        rwork(2:l,yl) = rwork(2:l,z+l) 
        CALL dgetrs ('n', l-1, 1, rwork(2:l,zz+1:zz+l-1), l-1, iwork, &
            rwork(2:l,yl), l-1, stat)
        rwork(l+1,yl) = -one
      
        ! --- Convex combination
      
        CALL dsymv ('u', l+1, one, rwork(1:l+1,z:z+l), l+1, &
            rwork(1:l+1,y0), 1, zero, rwork(1:l+1,y), 1)
        kappa0 = SQRT( ddot(l+1, rwork(1:l+1,y0), 1, rwork(1:l+1,y), 1) )
        CALL dsymv ('u', l+1, one, rwork(1:l+1,z:z+l), l+1, &
            rwork(1:l+1,yl), 1, zero, rwork(1:l+1,y), 1)
        kappal = SQRT( ddot(l+1, rwork(1:l+1,yl), 1, rwork(1:l+1,y), 1) )
        CALL dsymv ('u', l+1, one, rwork(1:l+1,z:z+l), l+1, &
          rwork(1:l+1,y0), 1, zero, rwork(1:l+1,y), 1)
        varrho = ddot(l+1, rwork(1:l+1,yl), 1, rwork(1:l+1,y), 1) / &
            (kappa0*kappal)
        hatgamma = varrho/ABS(varrho) * MAX(ABS(varrho),7d-1) * &
            kappa0/kappal
        rwork(1:l+1,y0) = rwork(1:l+1,y0) - hatgamma * rwork(1:l+1,yl)
        
        !  --- Update
        
        omega = rwork(l+1,y0)
        DO j=1,l
          work(1:n,u) = work(1:n,u) - rwork(j+1,y0) * work(1:n,u+j)
          x(1:n) = x(1:n) + rwork(j+1,y0) * work(1:n,r+j-1)
          work(1:n,r) = work(1:n,r) - rwork(j+1,y0) * work(1:n,r+j)
        ENDDO
    
        CALL dsymv ('u', l+1, one, rwork(1:l+1,z:z+l), l+1, &
            rwork(1:l+1,y0), 1, zero, rwork(1:l+1,y), 1)
        rnrm = SQRT( ddot(l+1, rwork(1:l+1,y0), 1, rwork(1:l+1,y), 1) )
        
        !---------------------------------------
        !  --- The reliable update part ---
        !---------------------------------------
        
        mxnrmx = MAX (mxnrmx, rnrm)
        mxnrmr = MAX (mxnrmr, rnrm)
        xpdt = (rnrm < delta*rnrm0 .AND. rnrm0 < mxnrmx)
        rcmp = ((rnrm < delta*mxnrmr .AND. rnrm0 < mxnrmr) .OR. xpdt)
        IF (rcmp) THEN
          ! PRINT *, 'Performing residual update...'
          CALL pcondlsubr( t, x, ipar )
          CALL matvecsubr( t, work(1:n,r), ipar )
          work(1:n,r) = work(1:n,bp) - work(1:n,r)
          mxnrmr = rnrm
          IF (xpdt) THEN
            ! PRINT *, 'Performing solution update...'
            work(1:n,xp) = work(1:n,xp) + t(1:n)
            x(1:n) = zero
            work(1:n,bp) = work(1:n,r)
            mxnrmx = rnrm
          ENDIF
        ENDIF
        
        IF (rcmp) THEN
          IF (xpdt) THEN       
            t(1:n) = work(1:n,xp)
          ELSE
            t(1:n) = t(1:n) + work(1:n,xp)  
          END IF
        ELSE
          CALL pcondlsubr( t, x, ipar )
          t(1:n) = t(1:n)+work(1:n,xp)
        END IF
      
        errorind = rnrm / bnrm
        IF( MOD(Round,OutputInterval) == 0) THEN
          WRITE (Message, '(I8, 2E11.4)') Round, rnrm, errorind
          CALL Info( '', Message, Level=6 )
        END IF
    
        Converged = (errorind < Tol) 
        Diverged = (errorind > MaxTol)     
        IF( Converged .OR. Diverged) EXIT    
      END DO

      IF(OutputInterval/=HUGE(OutputInterval)) THEN
        WRITE (Message, '(I8, 2E11.4)') Round, rnrm, errorind
        CALL Info( '', Message, Level=6 )
      END IF
    
      !------------------------------------------------------------
      ! We have solved z = P*x, with P the preconditioner, so finally 
      ! solve the true unknown x
      !------------------------------------------------------------
      t(1:n) = x(1:n)
      CALL pcondlsubr( x, t, ipar )
      x(1:n) = x(1:n) + work(1:n,xp)        
!------------------------------------------------------------------------------
    END SUBROUTINE RealBiCGStabl
!------------------------------------------------------------------------------

  END SUBROUTINE itermethod_bicgstabl
!------------------------------------------------------------------------------


END MODULE IterativeMethods
